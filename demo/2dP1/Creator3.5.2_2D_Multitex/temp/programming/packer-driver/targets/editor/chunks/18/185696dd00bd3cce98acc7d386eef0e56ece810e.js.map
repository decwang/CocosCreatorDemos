{"version":3,"sources":["file:///Users/mu/work/gitee/CocosCreatorDemos/demo/2dP1/Creator3.5.1_2D_Multitex/assets/scripts/MTBatcher2D.ts"],"names":["MTBatcher2D","StencilManager","Color","textures","samplers","textureHashs","samplerHashs","curIsMTSprite","texBindingMap","Map","getTexturesIdx","textHash","i","length","addTexture","texture","maxTextureSize","push","canBatchTexture","getSamplerIdx","samplerHash","addSampler","sampler","canBatchSampler","reset","getInstance","gInstance","setTexturesBindingMap","bm","hackBatch2d","batcher","isHacked","mtBatcher","commitComp","origin_getDescriptorSet","_descriptorSetCache","getDescriptorSet","batch","ds","call","fromMTSprite","pass","passes","texName","has","binding","get","bindTexture","bindSampler","origin_autoMergeBatches","autoMergeBatches","renderComp","originLength","_batches","newLength","isMTSprite","_isMTSprite","comp","data","frame","assembler","transform","samp","textureHash","getGFXTexture","getGFXSampler","getHash","getSamplerInfo","renderScene","_getRenderScene","mat","getRenderMaterial","stencilStage","sharedManager","stage","blendTargetHash","blendHash","depthStencilStateStage","_currScene","_currLayer","node","layer","_currMaterial","_currBlendTargetHash","_currDepthStencilStateStage","_currTransform","GL_MAX_Texture","_currComponent","_currTexture","_currSampler","_currTextureHash","_currSamplerHash","sp","color","fillBuffers"],"mappings":"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","sourcesContent":["\nimport { _decorator, Node, UI, Renderable2D, SpriteFrame, StencilManager, gfx, Color, Sprite, BaseRenderData } from 'cc';\n\nexport class MTBatcher2D {\n\n    private static readonly GL_MAX_Texture = 8;\n    private static isHacked = false;\n    private static gInstance: MTBatcher2D = new MTBatcher2D();\n\n    private textures: gfx.Texture[] = [];\n    private samplers: gfx.Sampler[] = [];\n    private textureHashs: number[] = [];\n    private samplerHashs: number[] = [];\n    private curIsMTSprite: boolean = false;\n    private texBindingMap: Map<string, number> = new Map<string, number>();\n\n    private getTexturesIdx(textHash: number): number {\n        for (let i = 0; i < this.textureHashs.length; i++) {\n            if (this.textureHashs[i] === textHash) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    private addTexture(texture: gfx.Texture, textHash: number, maxTextureSize: number): boolean {\n        if (this.textures.length >= maxTextureSize) {\n            return false;\n        }\n        this.textures.push(texture);\n        this.textureHashs.push(textHash);\n\n        return true;\n    }\n\n    private canBatchTexture(texture: gfx.Texture, textHash: number, maxTextureSize: number): boolean {\n        if (this.getTexturesIdx(textHash) >= 0) {\n            return true;\n        }\n        if (this.addTexture(texture, textHash, maxTextureSize)) {\n            return true;\n        }\n        return false;\n    }\n\n    private getSamplerIdx(samplerHash: number): number {\n        for (let i = 0; i < this.samplerHashs.length; i++) {\n            if (this.samplerHashs[i] === samplerHash) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    private addSampler(sampler: gfx.Sampler, samplerHash: number, maxTextureSize: number): boolean {\n        if (this.samplers.length >= maxTextureSize) {\n            return false;\n        }\n        this.samplers.push(sampler);\n        this.samplerHashs.push(samplerHash);\n\n        return true;\n    }\n\n    private canBatchSampler(sampler: gfx.Sampler, samplerHash: number, maxTextureSize: number): boolean {\n        if (this.getSamplerIdx(samplerHash) >= 0) {\n            return true;\n        }\n        if (this.addSampler(sampler, samplerHash, maxTextureSize)) {\n            return true;\n        }\n        return false;\n    }\n\n    private reset() {\n        this.textures.length = 0;\n        this.textureHashs.length = 0;\n        this.samplers.length = 0;\n        this.samplerHashs.length = 0;\n    }\n\n    public static getInstance(): MTBatcher2D {\n        return MTBatcher2D.gInstance;\n    }\n\n    public setTexturesBindingMap(bm: Map<string, number>) {\n        this.texBindingMap = bm;\n    }\n\n    public hackBatch2d(batcher: UI) {\n        if (MTBatcher2D.isHacked) {\n            return;\n        }\n        MTBatcher2D.isHacked = true;\n        const mtBatcher = MTBatcher2D.getInstance();\n        batcher.commitComp = MTBatcher2D.commitComp;\n        batcher.mtBatcher = mtBatcher;\n\n        const origin_getDescriptorSet = batcher._descriptorSetCache.getDescriptorSet;\n        batcher._descriptorSetCache.getDescriptorSet = function(batch: any) {\n            const ds = origin_getDescriptorSet.call(this, batch);\n            if (batch.fromMTSprite) {\n                const pass = batch.passes[0];\n                for (let i = 1; i < mtBatcher.textures.length; i++) {\n                    const texName = \"spriteTexture\" + i;\n                    if (mtBatcher.texBindingMap.has(texName)) {\n                        const binding = mtBatcher.texBindingMap.get(texName);\n                        if (mtBatcher.textures[i]) {\n                            pass.bindTexture(binding, mtBatcher.textures[i]);\n                        }\n                        if (mtBatcher.samplers[i]) {\n                            pass.bindSampler(binding, mtBatcher.samplers[i]);\n                        }\n                    }\n                }\n            }\n\n            return ds;\n        }\n\n        const origin_autoMergeBatches = batcher.autoMergeBatches;\n        batcher.autoMergeBatches = function(renderComp?: Renderable2D) {\n            const originLength = this._batches.length;\n            origin_autoMergeBatches.call(this, renderComp);\n            const newLength = this._batches.length;\n            if (newLength === originLength) {\n                return;\n            }\n            const isMTSprite: boolean = renderComp._isMTSprite || false;\n            this._batches.get(newLength-1).fromMTSprite = isMTSprite;\n        }\n    }\n\n    public static commitComp(comp: Renderable2D, data: BaseRenderData | null, frame: SpriteFrame | null, assembler: any, transform: Node | null) {\n        const renderComp = comp;\n        let texture;\n        let samp;\n        let textureHash = 0;\n        let samplerHash = 0;\n        if (frame) {\n            texture = frame.getGFXTexture();\n            samp = frame.getGFXSampler();\n            textureHash = frame.getHash();\n            samplerHash = frame.getSamplerInfo();\n        } else {\n            texture = null;\n            samp = null;\n        }\n\n        const renderScene = renderComp._getRenderScene();\n        const mat = renderComp.getRenderMaterial(0);\n        renderComp.stencilStage = StencilManager.sharedManager!.stage;\n\n        const blendTargetHash = renderComp.blendHash;\n        const depthStencilStateStage = renderComp.stencilStage;\n\n        const mtBatcher = this.mtBatcher as any as MTBatcher2D\n        const isMTSprite: boolean = comp._isMTSprite || false;\n\n        if (this._currScene !== renderScene\n            || this._currLayer !== comp.node.layer\n            || this._currMaterial !== mat\n            || this._currBlendTargetHash !== blendTargetHash\n            || this._currDepthStencilStateStage !== depthStencilStateStage\n            || this._currTransform !== transform\n            || mtBatcher.curIsMTSprite !== isMTSprite\n            || !mtBatcher.canBatchTexture(texture, textureHash, isMTSprite ? MTBatcher2D.GL_MAX_Texture : 1)\n            || !mtBatcher.canBatchSampler(samp, samplerHash, isMTSprite ? MTBatcher2D.GL_MAX_Texture : 1)\n            ) {\n            this.autoMergeBatches(this._currComponent!);\n            mtBatcher.reset();\n            mtBatcher.addTexture(texture, textureHash);\n            mtBatcher.addSampler(samp, samplerHash);\n            mtBatcher.curIsMTSprite = isMTSprite;\n\n            this._currScene = renderScene;\n            this._currComponent = renderComp;\n            this._currTransform = transform;\n            this._currMaterial = mat!;\n            this._currTexture = texture;\n            this._currSampler = samp;\n            this._currTextureHash = textureHash;\n            this._currSamplerHash = samplerHash;\n            this._currBlendTargetHash = blendTargetHash;\n            this._currDepthStencilStateStage = depthStencilStateStage;\n            this._currLayer = comp.node.layer;\n\n        }\n\n        if (isMTSprite) {\n            const sp = comp as Sprite;\n            sp.color = new Color(mtBatcher.getTexturesIdx(textureHash));\n        }\n        if (assembler) {\n            assembler.fillBuffers(renderComp, this);\n        }\n    }\n\n}\n\n"]}