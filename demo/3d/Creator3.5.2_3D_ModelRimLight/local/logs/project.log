2022-06-22T17:06:01.936Z - log: [Package] menu@1.0.0 enable
2022-06-22T17:06:01.939Z - log: [Package] profile@1.0.0 enable
2022-06-22T17:06:01.950Z - log: [Package] project@1.0.2 enable
2022-06-22T17:06:01.959Z - log: [Package] messages@1.0.0 enable
2022-06-22T17:06:01.962Z - log: [Package] program@1.0.0 enable
2022-06-22T17:06:01.968Z - log: [Package] tester@1.0.0 enable
2022-06-22T17:06:01.975Z - log: [Package] preferences@1.0.0 enable
2022-06-22T17:06:02.699Z - log: Setup mods mgr.: 323.124ms
2022-06-22T17:06:02.703Z - log: Profile changed: engine (modules.includeModules: 2d,animation,audio,base,dragon-bones,gfx-webgl,gfx-webgl2,intersection-2d,marionette,particle-2d,physics-2d-box2d,profiler,skeletal-animation,spine,tiled-map,tween,ui,video,webview)
2022-06-22T17:06:02.711Z - verbose: [Engine] QuickCompile engine (675ms)
2022-06-22T17:06:02.714Z - log: [Package] engine@1.0.6 enable
2022-06-22T17:06:03.533Z - log: [Package] programming@1.0.0 enable
2022-06-22T17:06:03.842Z - log: [Package] device@1.0.1 enable
2022-06-22T17:06:03.869Z - log: [Package] ui-kit@1.0.1 enable
2022-06-22T17:06:03.909Z - log: [Package] engine-extends@1.0.0 enable
2022-06-22T17:06:03.975Z - log: [Package] asset-db@1.0.0 enable
2022-06-22T17:06:04.020Z - log: [Package] scene@1.0.0 enable
2022-06-22T17:06:04.231Z - log: [Package] server@1.0.0 enable
2022-06-22T17:06:04.263Z - log: [Package] utils@1.0.0 enable
2022-06-22T17:06:08.468Z - log: [Package] preview@1.0.1 enable
2022-06-22T17:06:08.502Z - log: [Package] animator@1.0.0 enable
2022-06-22T17:06:08.617Z - log: 设置的 IP 地址不存在，将使用默认 IP
2022-06-22T17:06:09.501Z - log: [Package] builder@1.3.2 enable
2022-06-22T17:06:09.536Z - log: [Package] shortcuts@1.0.1 enable
2022-06-22T17:06:09.566Z - log: [Package] animation-graph@1.0.0 enable
2022-06-22T17:06:09.591Z - log: [Package] runtime-dev-tools@1.0.0 enable
2022-06-22T17:06:09.617Z - log: [Package] channel-upload-tools@1.0.0 enable
2022-06-22T17:06:09.647Z - log: [Package] about@1.0.0 enable
2022-06-22T17:06:09.682Z - log: [Package] assets@1.0.0 enable
2022-06-22T17:06:09.715Z - log: [Package] console@1.0.0 enable
2022-06-22T17:06:10.037Z - log: [Package] extension@3.0.16 enable
2022-06-22T17:06:10.087Z - log: [Package] hierarchy@1.0.0 enable
2022-06-22T17:06:10.134Z - log: [Package] inspector@1.0.0 enable
2022-06-22T17:06:10.178Z - log: [Package] lightmap@1.0.4 enable
2022-06-22T17:06:10.228Z - log: [Package] node-library@1.0.1 enable
2022-06-22T17:06:10.257Z - log: [Package] package-asset@1.0.0 enable
2022-06-22T17:06:10.299Z - log: [Package] process@1.0.0 enable
2022-06-22T17:06:10.339Z - log: [Package] reference-image@1.0.0 enable
2022-06-22T17:06:10.363Z - log: [Package] alipay-mini-game@1.0.0 enable
2022-06-22T17:06:10.392Z - log: [Package] android@1.0.0 enable
2022-06-22T17:06:10.419Z - log: [Package] baidu-mini-game@1.0.0 enable
2022-06-22T17:06:10.446Z - log: [Package] bytedance-mini-game@1.0.1 enable
2022-06-22T17:06:10.469Z - log: [Package] cocos-play@1.0.0 enable
2022-06-22T17:06:10.497Z - log: [Package] huawei-agc@1.0.0 enable
2022-06-22T17:06:10.526Z - log: [Package] huawei-quick-game@1.0.0 enable
2022-06-22T17:06:11.770Z - log: [Package] ios@1.0.0 enable
2022-06-22T17:06:11.802Z - log: [Package] ios-app-clip@1.0.0 enable
2022-06-22T17:06:11.826Z - log: [Package] link-sure@1.0.0 enable
2022-06-22T17:06:11.856Z - log: [Package] linux@1.0.0 enable
2022-06-22T17:06:11.880Z - log: [Package] mac@1.0.0 enable
2022-06-22T17:06:12.005Z - log: [Package] native@1.0.0 enable
2022-06-22T17:06:12.017Z - verbose: [AssetDB] Require engine code (2698ms)
2022-06-22T17:06:12.141Z - log: [Package] ohos@1.0.0 enable
2022-06-22T17:06:12.169Z - log: [Package] open-harmonyos@1.0.0 enable
2022-06-22T17:06:12.197Z - log: [Package] oppo-mini-game@1.0.0 enable
2022-06-22T17:06:12.221Z - log: [Package] qtt@1.0.0 enable
2022-06-22T17:06:12.250Z - log: [Package] vivo-mini-game@1.0.0 enable
2022-06-22T17:06:12.290Z - log: [Package] web-desktop@1.0.0 enable
2022-06-22T17:06:12.329Z - log: [Package] web-mobile@1.0.0 enable
2022-06-22T17:06:12.366Z - log: [Package] wechatgame@1.0.1 enable
2022-06-22T17:06:12.392Z - log: [Package] windows@1.0.0 enable
2022-06-22T17:06:12.419Z - log: [Package] xiaomi-quick-game@1.0.0 enable
2022-06-22T17:06:12.870Z - log: [Package] cocos-service@3.0.3 enable
2022-06-22T17:06:12.931Z - log: [Package] importer@1.0.0 enable
2022-06-22T17:06:13.343Z - log: [Im-plugin] Check im-plugin version.
2022-06-22T17:06:13.355Z - log: [Package] im-plugin@3.0.8 enable
2022-06-22T17:06:14.079Z - log: [Im-plugin] No online info of im-plugin.
2022-06-22T17:06:14.894Z - log: 设置的 IP 地址不存在，将使用默认 IP
2022-06-22T17:06:44.821Z - verbose: [Scene] Require engine code (1ms)
2022-06-22T17:06:44.837Z - verbose: [Scene] Startup engine (6ms)
2022-06-22T17:06:44.875Z - log: [Scene] Cocos Creator v3.5.2
2022-06-22T17:06:44.996Z - log: [Scene] No need to specify the "type" of "FollowCamera.lookAtOffset" because cc.Vec3 is a child class of ValueType.
2022-06-22T17:06:45.240Z - verbose: [Scene] Open engine (405ms)
2022-06-22T17:06:45.240Z - verbose: [Scene] Configure engine (0ms)
2022-06-22T17:06:45.009Z - info: [Scene] Forward render pipeline initialized.
2022-06-22T17:06:45.872Z - log: [Scene] No need to specify the "type" of "FollowCamera.lookAtOffset" because cc.Vec3 is a child class of ValueType.
2022-06-22T17:07:13.101Z - error: [Preview]Uncaught TypeError: Cannot read properties of undefined (reading 'createMesh') in http://localhost:7456/scripting/engine/bin/.cache/dev/preview/bundled/index.js
2022-06-22T17:07:13.133Z - error: [Preview]Uncaught TypeError: The thing you want to instantiate is nil in http://localhost:7456/scripting/engine/bin/.cache/dev/preview/bundled/index.js
2022-06-22T17:08:26.424Z - log: [Scene] No need to specify the "type" of "FollowCamera.lookAtOffset" because cc.Vec3 is a child class of ValueType.
2022-06-22T17:08:50.516Z - error: [Preview]Uncaught TypeError: The thing you want to instantiate is nil in http://localhost:7456/scripting/engine/bin/.cache/dev/preview/bundled/index.js
2022-06-22T17:10:22.412Z - error: [Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts'.[Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts'.  
at Object.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/programming/dist/packer-driver/packer-driver.ccc:1:14689)  
at QuickPack._inspect (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:258:26)  
at async QuickPack._inspectWithCache (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:166:30)  
at async QuickPack._getOrCreateInspectRecord (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:134:13)  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:219:35  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-common/lib/launch-policy.js:9:30
2022-06-22T17:10:22.418Z - error: [Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts'.[Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts'.  
at Object.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/programming/dist/packer-driver/packer-driver.ccc:1:14689)  
at QuickPack._inspect (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:258:26)  
at async QuickPack._inspectWithCache (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:166:30)  
at async QuickPack._getOrCreateInspectRecord (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:134:13)  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:219:35  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-common/lib/launch-policy.js:9:30
2022-06-22T17:10:22.718Z - error: [Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts'.[Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts'.  
at Object.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/programming/dist/packer-driver/packer-driver.ccc:1:14689)  
at QuickPack._inspect (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:258:26)  
at async QuickPack._inspectWithCache (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:166:30)  
at async QuickPack._getOrCreateInspectRecord (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:134:13)  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:219:35  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-common/lib/launch-policy.js:9:30
2022-06-22T17:10:22.723Z - error: [Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts'.[Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts'.  
at Object.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/programming/dist/packer-driver/packer-driver.ccc:1:14689)  
at QuickPack._inspect (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:258:26)  
at async QuickPack._inspectWithCache (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:166:30)  
at async QuickPack._getOrCreateInspectRecord (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:134:13)  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:219:35  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-common/lib/launch-policy.js:9:30
2022-06-22T17:10:22.729Z - log: [Scene] No need to specify the "type" of "FollowCamera.lookAtOffset" because cc.Vec3 is a child class of ValueType.
2022-06-22T17:10:22.732Z - error: [Scene] {hidden(::SceneExecutorImportExceptionHandler::)} Error: 无法从 pack:///chunks/4a/4ac232b6df7bdcccc2897ca5eb3d9bbdafdbc4ba.js 解析出模块 __unresolved_1。
    at ExecutorSystem._throwUnresolved (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:145:15)
    at ExecutorSystem._resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:94:21)
    at SystemJS.resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:28:23)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:355:37
    at Array.map (<anonymous>)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:353:41
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
    at async Object.execute (file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:8:7)
    at async Executor._importPrerequisiteModules (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:208:13)
    at async Executor.reload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:130:9)Error: [Scene] {hidden(::SceneExecutorImportExceptionHandler::)} Error: 无法从 pack:///chunks/4a/4ac232b6df7bdcccc2897ca5eb3d9bbdafdbc4ba.js 解析出模块 __unresolved_1。
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:355:37
    at Array.map (<anonymous>)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:353:41
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
    at async Object.execute (file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:8:7)
    at async Executor._importPrerequisiteModules (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:208:13)
    at async Executor.reload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:130:9)
    at Logger._logHandler (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/startup/log.ccc:1:289)
    at Logger.record (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:458)
    at console.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:1414)
    at ScriptManager._handleImportException (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/scripts.ccc:1:5116)
    at Executor.importExceptionHandler [as _importExceptionHandler] (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/scripts.ccc:1:3104)
    at Executor._onModuleLoaded (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:253:22)
    at SystemJS.onload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:62:18)
    at triggerOnload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:270:10)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:431:7
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
2022-06-22T17:10:22.734Z - error: [Scene] {hidden(::SceneExecutorImportExceptionHandler::)} Error: 无法从 pack:///chunks/a9/a91716237e784c8519852c2f65b9839ae5b3b70e.js 解析出模块 __unresolved_2。
    at ExecutorSystem._throwUnresolved (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:145:15)
    at ExecutorSystem._resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:94:21)
    at SystemJS.resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:28:23)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:355:37
    at Array.map (<anonymous>)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:353:41
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
    at async Object.execute (file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:8:7)
    at async Executor._importPrerequisiteModules (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:208:13)
    at async Executor.reload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:130:9)Error: [Scene] {hidden(::SceneExecutorImportExceptionHandler::)} Error: 无法从 pack:///chunks/a9/a91716237e784c8519852c2f65b9839ae5b3b70e.js 解析出模块 __unresolved_2。
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:355:37
    at Array.map (<anonymous>)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:353:41
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
    at async Object.execute (file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:8:7)
    at async Executor._importPrerequisiteModules (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:208:13)
    at async Executor.reload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:130:9)
    at Logger._logHandler (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/startup/log.ccc:1:289)
    at Logger.record (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:458)
    at console.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:1414)
    at ScriptManager._handleImportException (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/scripts.ccc:1:5116)
    at Executor.importExceptionHandler [as _importExceptionHandler] (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/scripts.ccc:1:3104)
    at Executor._onModuleLoaded (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:253:22)
    at SystemJS.onload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:62:18)
    at triggerOnload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:270:10)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:431:7
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
2022-06-22T17:10:22.768Z - warn: [Scene] Missing class: e8577Baw4xBIbU+5FUq3PXdError: [Scene] Missing class: e8577Baw4xBIbU+5FUq3PXd
    at Object.classFinder (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/missing-class-reporter.ccc:1:2218)
    at _Deserializer.classFinder [as _classFinder] (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:102743:32)
    at _Deserializer._deserializeTypeTaggedObject (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111572:24)
    at _Deserializer._deserializeObject (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111513:23)
    at _Deserializer._deserializeAndAssignField (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111722:32)
    at _Deserializer._deserializeArray (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111547:34)
    at _Deserializer._deserializeObject (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111519:23)
2022-06-22T17:10:22.790Z - error: [Scene] Script "e8577Baw4xBIbU+5FUq3PXd" attached to "Canvas" is missing or invalid. Detailed information:
Node path: "Canvas"
Script UUID: "e857705a-c38c-4121-b53e-e4552adcf5dd"
Class ID: "e8577Baw4xBIbU+5FUq3PXd"
Error: [Scene] Script "e8577Baw4xBIbU+5FUq3PXd" attached to "Canvas" is missing or invalid. Detailed information:
Node path: "Canvas"
Script UUID: "e857705a-c38c-4121-b53e-e4552adcf5dd"
Class ID: "e8577Baw4xBIbU+5FUq3PXd"

    at report (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/missing-class-reporter.ccc:1:1187)
    at reportByWalker (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/missing-class-reporter.ccc:1:1283)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/missing-class-reporter.ccc:1:1979
    at ObjectWalkerBehavior.walk (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/object-walker.ccc:1:2348)
    at ObjectWalkerBehavior.forEach (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/object-walker.ccc:1:812)
    at ObjectWalkerBehavior.parseObject (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/object-walker.ccc:1:306)
    at doWalkProperties (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/object-walker.ccc:1:2143)
2022-06-22T17:10:27.116Z - error: [Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts'.[Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts'.  
at Object.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/programming/dist/packer-driver/packer-driver.ccc:1:14689)  
at QuickPack._inspect (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:258:26)  
at async QuickPack._inspectWithCache (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:166:30)  
at async QuickPack._getOrCreateInspectRecord (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:134:13)  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:219:35  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-common/lib/launch-policy.js:9:30
2022-06-22T17:10:27.121Z - error: [Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts'.[Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts'.  
at Object.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/programming/dist/packer-driver/packer-driver.ccc:1:14689)  
at QuickPack._inspect (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:258:26)  
at async QuickPack._inspectWithCache (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:166:30)  
at async QuickPack._getOrCreateInspectRecord (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:134:13)  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:219:35  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-common/lib/launch-policy.js:9:30
2022-06-22T17:10:27.125Z - error: [Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/components/PlayerCtrl.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/components/PlayerCtrl.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/components/PlayerCtrl.ts'.[Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/components/PlayerCtrl.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/components/PlayerCtrl.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/components/PlayerCtrl.ts'.  
at Object.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/programming/dist/packer-driver/packer-driver.ccc:1:14689)  
at QuickPack._inspect (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:258:26)  
at async QuickPack._inspectWithCache (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:166:30)  
at async QuickPack._getOrCreateInspectRecord (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:134:13)  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:219:35  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-common/lib/launch-policy.js:9:30
2022-06-22T17:10:27.282Z - error: [Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts'.[Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIMgr.ts'.  
at Object.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/programming/dist/packer-driver/packer-driver.ccc:1:14689)  
at QuickPack._inspect (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:258:26)  
at async QuickPack._inspectWithCache (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:166:30)  
at async QuickPack._getOrCreateInspectRecord (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:134:13)  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:219:35  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-common/lib/launch-policy.js:9:30
2022-06-22T17:10:27.286Z - error: [Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts'.[Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/base/UIController.ts'.  
at Object.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/programming/dist/packer-driver/packer-driver.ccc:1:14689)  
at QuickPack._inspect (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:258:26)  
at async QuickPack._inspectWithCache (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:166:30)  
at async QuickPack._getOrCreateInspectRecord (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:134:13)  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:219:35  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-common/lib/launch-policy.js:9:30
2022-06-22T17:10:27.289Z - error: [Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/components/PlayerCtrl.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/components/PlayerCtrl.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/components/PlayerCtrl.ts'.[Programming] 无法加载模块 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/components/PlayerCtrl.ts ：Error: 在加载模块文件 /Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/components/PlayerCtrl.ts 时发生错误：Error: ENOENT: no such file or directory, open '/Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/resources/qfw/components/PlayerCtrl.ts'.  
at Object.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/programming/dist/packer-driver/packer-driver.ccc:1:14689)  
at QuickPack._inspect (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:258:26)  
at async QuickPack._inspectWithCache (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:166:30)  
at async QuickPack._getOrCreateInspectRecord (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:134:13)  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-quick-pack/lib/quick-pack.js:219:35  
at async /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@cocos/creator-programming-common/lib/launch-policy.js:9:30
2022-06-22T17:10:27.297Z - error: [Scene] {hidden(::SceneExecutorImportExceptionHandler::)} Error: 无法从 pack:///chunks/4a/4ac232b6df7bdcccc2897ca5eb3d9bbdafdbc4ba.js 解析出模块 __unresolved_1。
    at ExecutorSystem._throwUnresolved (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:145:15)
    at ExecutorSystem._resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:94:21)
    at SystemJS.resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:28:23)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:355:37
    at Array.map (<anonymous>)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:353:41
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
    at async Object.execute (file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:8:7)
    at async Executor._importPrerequisiteModules (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:208:13)
    at async Executor.reload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:130:9)Error: [Scene] {hidden(::SceneExecutorImportExceptionHandler::)} Error: 无法从 pack:///chunks/4a/4ac232b6df7bdcccc2897ca5eb3d9bbdafdbc4ba.js 解析出模块 __unresolved_1。
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:355:37
    at Array.map (<anonymous>)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:353:41
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
    at async Object.execute (file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:8:7)
    at async Executor._importPrerequisiteModules (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:208:13)
    at async Executor.reload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:130:9)
    at Logger._logHandler (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/startup/log.ccc:1:289)
    at Logger.record (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:458)
    at console.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:1414)
    at ScriptManager._handleImportException (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/scripts.ccc:1:5116)
    at Executor.importExceptionHandler [as _importExceptionHandler] (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/scripts.ccc:1:3104)
    at Executor._onModuleLoaded (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:253:22)
    at SystemJS.onload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:62:18)
    at triggerOnload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:270:10)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:431:7
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
2022-06-22T17:10:27.299Z - error: [Scene] {hidden(::SceneExecutorImportExceptionHandler::)} Error: 无法从 pack:///chunks/a9/a91716237e784c8519852c2f65b9839ae5b3b70e.js 解析出模块 __unresolved_2。
    at ExecutorSystem._throwUnresolved (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:145:15)
    at ExecutorSystem._resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:94:21)
    at SystemJS.resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:28:23)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:355:37
    at Array.map (<anonymous>)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:353:41
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
    at async Object.execute (file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:8:7)
    at async Executor._importPrerequisiteModules (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:208:13)
    at async Executor.reload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:130:9)Error: [Scene] {hidden(::SceneExecutorImportExceptionHandler::)} Error: 无法从 pack:///chunks/a9/a91716237e784c8519852c2f65b9839ae5b3b70e.js 解析出模块 __unresolved_2。
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:355:37
    at Array.map (<anonymous>)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:353:41
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
    at async Object.execute (file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:8:7)
    at async Executor._importPrerequisiteModules (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:208:13)
    at async Executor.reload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:130:9)
    at Logger._logHandler (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/startup/log.ccc:1:289)
    at Logger.record (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:458)
    at console.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:1414)
    at ScriptManager._handleImportException (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/scripts.ccc:1:5116)
    at Executor.importExceptionHandler [as _importExceptionHandler] (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/scripts.ccc:1:3104)
    at Executor._onModuleLoaded (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:253:22)
    at SystemJS.onload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:62:18)
    at triggerOnload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:270:10)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:431:7
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
2022-06-22T17:10:27.303Z - log: [Scene] No need to specify the "type" of "FollowCamera.lookAtOffset" because cc.Vec3 is a child class of ValueType.
2022-06-22T17:10:27.333Z - warn: [Scene] Missing class: e8577Baw4xBIbU+5FUq3PXdError: [Scene] Missing class: e8577Baw4xBIbU+5FUq3PXd
    at Object.classFinder (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/missing-class-reporter.ccc:1:2218)
    at _Deserializer.classFinder [as _classFinder] (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:102743:32)
    at _Deserializer._deserializeTypeTaggedObject (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111572:24)
    at _Deserializer._deserializeObject (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111513:23)
    at _Deserializer._deserializeAndAssignField (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111722:32)
    at _Deserializer._deserializeArray (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111547:34)
    at _Deserializer._deserializeObject (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111519:23)
2022-06-22T17:10:27.339Z - error: [Scene] Script "e8577Baw4xBIbU+5FUq3PXd" attached to "Canvas" is missing or invalid. Detailed information:
Node path: "Canvas"
Script UUID: "e857705a-c38c-4121-b53e-e4552adcf5dd"
Class ID: "e8577Baw4xBIbU+5FUq3PXd"
Error: [Scene] Script "e8577Baw4xBIbU+5FUq3PXd" attached to "Canvas" is missing or invalid. Detailed information:
Node path: "Canvas"
Script UUID: "e857705a-c38c-4121-b53e-e4552adcf5dd"
Class ID: "e8577Baw4xBIbU+5FUq3PXd"

    at report (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/missing-class-reporter.ccc:1:1187)
    at reportByWalker (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/missing-class-reporter.ccc:1:1283)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/missing-class-reporter.ccc:1:1979
    at ObjectWalkerBehavior.walk (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/object-walker.ccc:1:2348)
    at ObjectWalkerBehavior.forEach (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/object-walker.ccc:1:812)
    at ObjectWalkerBehavior.parseObject (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/object-walker.ccc:1:306)
    at doWalkProperties (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/object-walker.ccc:1:2143)
2022-06-22T17:10:36.010Z - warn: [Scene] 你是否遗漏了扩展名？请注意你不能在模块说明符中省略扩展名。Error: [Scene] 你是否遗漏了扩展名？请注意你不能在模块说明符中省略扩展名。
    at logger (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:728:13)
    at ExecutorSystem.resolve [as _detailResolve] (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:745:17)
    at ExecutorSystem._resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:86:14)
    at SystemJS.resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:28:23)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:355:37
    at Array.map (<anonymous>)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:353:41
2022-06-22T17:10:36.010Z - error: [Scene] {hidden(::SceneExecutorImportExceptionHandler::)} Error: Error: 以 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/src/AppStart_RimLight.ts 为起点找不到模块 "../../qfw/base/UIMgr"
    at rejector (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:732:15)
    at ExecutorSystem.resolve [as _detailResolve] (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:750:13)
    at ExecutorSystem._resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:86:14)
    at SystemJS.resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:28:23)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:355:37
    at Array.map (<anonymous>)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:353:41
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
    at async Object.execute (file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:8:7)
    at async Executor._importPrerequisiteModules (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:208:13)Error: [Scene] {hidden(::SceneExecutorImportExceptionHandler::)} Error: Error: 以 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/src/AppStart_RimLight.ts 为起点找不到模块 "../../qfw/base/UIMgr"
    at SystemJS.resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:28:23)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:355:37
    at Array.map (<anonymous>)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:353:41
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
    at async Object.execute (file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:8:7)
    at async Executor._importPrerequisiteModules (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:208:13)
    at Logger._logHandler (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/startup/log.ccc:1:289)
    at Logger.record (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:458)
    at console.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:1414)
    at ScriptManager._handleImportException (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/scripts.ccc:1:5116)
    at Executor.importExceptionHandler [as _importExceptionHandler] (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/scripts.ccc:1:3104)
    at Executor._onModuleLoaded (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:253:22)
    at SystemJS.onload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:62:18)
    at triggerOnload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:270:10)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:431:7
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
2022-06-22T17:10:36.011Z - log: [Scene] No need to specify the "type" of "FollowCamera.lookAtOffset" because cc.Vec3 is a child class of ValueType.
2022-06-22T17:10:36.022Z - warn: [Scene] 你是否遗漏了扩展名？请注意你不能在模块说明符中省略扩展名。Error: [Scene] 你是否遗漏了扩展名？请注意你不能在模块说明符中省略扩展名。
    at logger (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:728:13)
    at ExecutorSystem.resolve [as _detailResolve] (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:745:17)
    at ExecutorSystem._resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:86:14)
    at SystemJS.resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:28:23)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:355:37
    at Array.map (<anonymous>)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:353:41
2022-06-22T17:10:36.022Z - error: [Scene] {hidden(::SceneExecutorImportExceptionHandler::)} Error: Error: 以 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/src/UI_RimLight_HUD.ts 为起点找不到模块 "../../../qfw/base/UIController"
    at rejector (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:732:15)
    at ExecutorSystem.resolve [as _detailResolve] (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:750:13)
    at ExecutorSystem._resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:86:14)
    at SystemJS.resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:28:23)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:355:37
    at Array.map (<anonymous>)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:353:41
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
    at async Object.execute (file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:8:7)
    at async Executor._importPrerequisiteModules (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:208:13)Error: [Scene] {hidden(::SceneExecutorImportExceptionHandler::)} Error: Error: 以 file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/assets/src/UI_RimLight_HUD.ts 为起点找不到模块 "../../../qfw/base/UIController"
    at SystemJS.resolve (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/editor-systemjs/index.js:28:23)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:355:37
    at Array.map (<anonymous>)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:353:41
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
    at async Object.execute (file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:8:7)
    at async Executor._importPrerequisiteModules (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:208:13)
    at Logger._logHandler (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/startup/log.ccc:1:289)
    at Logger.record (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:458)
    at console.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:1414)
    at ScriptManager._handleImportException (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/scripts.ccc:1:5116)
    at Executor.importExceptionHandler [as _importExceptionHandler] (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/scene/dist/script/3d/manager/scripts.ccc:1:3104)
    at Executor._onModuleLoaded (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:253:22)
    at SystemJS.onload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/dist/executor/index.js:62:18)
    at triggerOnload (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:270:10)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/lib-programming/static/executor/systemjs-bridge/out/index.js:431:7
    at async file:///Users/mu/Desktop/Creator3.5.2_3D_ModelRimLight/temp/programming/packer-driver/targets/editor/chunks/09/09e496b395f3362281c93269a29d6d47678870a4.js:13:13
2022-06-22T17:10:36.036Z - warn: [Scene] Missing class: e8577Baw4xBIbU+5FUq3PXdError: [Scene] Missing class: e8577Baw4xBIbU+5FUq3PXd
    at Object.classFinder (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/missing-class-reporter.ccc:1:2218)
    at _Deserializer.classFinder [as _classFinder] (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:102743:32)
    at _Deserializer._deserializeTypeTaggedObject (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111572:24)
    at _Deserializer._deserializeObject (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111513:23)
    at _Deserializer._deserializeAndAssignField (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111722:32)
    at _Deserializer._deserializeArray (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111547:34)
    at _Deserializer._deserializeObject (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/resources/3d/engine/bin/.cache/dev/editor/bundled/index.js:111519:23)
2022-06-22T17:10:36.041Z - error: [Scene] Script "e8577Baw4xBIbU+5FUq3PXd" attached to "Canvas" is missing or invalid. Detailed information:
Node path: "Canvas"
Script UUID: "e857705a-c38c-4121-b53e-e4552adcf5dd"
Class ID: "e8577Baw4xBIbU+5FUq3PXd"
Error: [Scene] Script "e8577Baw4xBIbU+5FUq3PXd" attached to "Canvas" is missing or invalid. Detailed information:
Node path: "Canvas"
Script UUID: "e857705a-c38c-4121-b53e-e4552adcf5dd"
Class ID: "e8577Baw4xBIbU+5FUq3PXd"

    at report (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/missing-class-reporter.ccc:1:1187)
    at reportByWalker (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/missing-class-reporter.ccc:1:1283)
    at /Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/missing-class-reporter.ccc:1:1979
    at ObjectWalkerBehavior.walk (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/object-walker.ccc:1:2348)
    at ObjectWalkerBehavior.forEach (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/object-walker.ccc:1:812)
    at ObjectWalkerBehavior.parseObject (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/object-walker.ccc:1:306)
    at doWalkProperties (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/builtin/engine/dist/editor-extends/missing-reporter/object-walker.ccc:1:2143)
2022-06-22T17:13:11.587Z - log: [Scene] No need to specify the "type" of "FollowCamera.lookAtOffset" because cc.Vec3 is a child class of ValueType.
2022-06-22T17:14:19.854Z - warn: Metrics: no valid info
2022-06-23T02:04:55.091Z - log: [Package] menu@1.0.0 enable
2022-06-23T02:04:55.094Z - log: [Package] profile@1.0.0 enable
2022-06-23T02:04:55.108Z - log: [Package] project@1.0.2 enable
2022-06-23T02:04:55.115Z - log: [Package] messages@1.0.0 enable
2022-06-23T02:04:55.120Z - log: [Package] program@1.0.0 enable
2022-06-23T02:04:55.126Z - log: [Package] tester@1.0.0 enable
2022-06-23T02:04:55.131Z - log: [Package] preferences@1.0.0 enable
2022-06-23T02:04:55.884Z - log: Setup mods mgr.: 359.687ms
2022-06-23T02:04:55.886Z - log: Profile changed: engine (modules.includeModules: 2d,3d,animation,audio,base,dragon-bones,gfx-webgl,gfx-webgl2,intersection-2d,marionette,particle,particle-2d,physics-2d-box2d,physics-ammo,primitive,profiler,skeletal-animation,spine,terrain,tiled-map,tween,ui,video,webview)
2022-06-23T02:04:55.899Z - verbose: [Engine] QuickCompile engine (697ms)
2022-06-23T02:04:55.902Z - log: [Package] engine@1.0.6 enable
2022-06-23T02:04:56.842Z - log: [Package] programming@1.0.0 enable
2022-06-23T02:04:57.157Z - log: [Package] device@1.0.1 enable
2022-06-23T02:04:57.184Z - log: [Package] ui-kit@1.0.1 enable
2022-06-23T02:04:57.246Z - log: [Package] engine-extends@1.0.0 enable
2022-06-23T02:04:57.323Z - log: [Package] asset-db@1.0.0 enable
2022-06-23T02:04:57.415Z - log: [Package] scene@1.0.0 enable
2022-06-23T02:04:57.696Z - log: [Package] server@1.0.0 enable
2022-06-23T02:04:57.742Z - log: [Package] utils@1.0.0 enable
2022-06-23T02:05:02.610Z - log: [Package] preview@1.0.1 enable
2022-06-23T02:05:02.657Z - log: [Package] animator@1.0.0 enable
2022-06-23T02:05:02.790Z - log: 设置的 IP 地址不存在，将使用默认 IP
2022-06-23T02:05:03.934Z - log: [Package] builder@1.3.2 enable
2022-06-23T02:05:03.968Z - log: [Package] shortcuts@1.0.1 enable
2022-06-23T02:05:04.002Z - log: [Package] animation-graph@1.0.0 enable
2022-06-23T02:05:04.026Z - log: [Package] runtime-dev-tools@1.0.0 enable
2022-06-23T02:05:04.049Z - log: [Package] channel-upload-tools@1.0.0 enable
2022-06-23T02:05:04.090Z - log: [Package] about@1.0.0 enable
2022-06-23T02:05:04.131Z - log: [Package] assets@1.0.0 enable
2022-06-23T02:05:04.179Z - log: [Package] console@1.0.0 enable
2022-06-23T02:05:04.545Z - log: [Package] extension@3.0.16 enable
2022-06-23T02:05:04.593Z - log: [Package] hierarchy@1.0.0 enable
2022-06-23T02:05:04.641Z - log: [Package] inspector@1.0.0 enable
2022-06-23T02:05:04.682Z - log: [Package] lightmap@1.0.4 enable
2022-06-23T02:05:04.746Z - log: [Package] node-library@1.0.1 enable
2022-06-23T02:05:04.799Z - log: [Package] package-asset@1.0.0 enable
2022-06-23T02:05:04.913Z - log: [Package] process@1.0.0 enable
2022-06-23T02:05:04.970Z - log: [Package] reference-image@1.0.0 enable
2022-06-23T02:05:05.028Z - log: [Package] alipay-mini-game@1.0.0 enable
2022-06-23T02:05:05.052Z - log: [Package] android@1.0.0 enable
2022-06-23T02:05:05.078Z - log: [Package] baidu-mini-game@1.0.0 enable
2022-06-23T02:05:05.102Z - log: [Package] bytedance-mini-game@1.0.1 enable
2022-06-23T02:05:05.125Z - log: [Package] cocos-play@1.0.0 enable
2022-06-23T02:05:05.151Z - log: [Package] huawei-agc@1.0.0 enable
2022-06-23T02:05:05.175Z - log: [Package] huawei-quick-game@1.0.0 enable
2022-06-23T02:05:23.205Z - log: [Package] ios@1.0.0 enable
2022-06-23T02:05:23.236Z - log: [Package] ios-app-clip@1.0.0 enable
2022-06-23T02:05:23.266Z - log: [Package] link-sure@1.0.0 enable
2022-06-23T02:05:23.301Z - log: [Package] linux@1.0.0 enable
2022-06-23T02:05:23.347Z - log: [Package] mac@1.0.0 enable
2022-06-23T02:05:23.593Z - log: [Package] native@1.0.0 enable
2022-06-23T02:05:23.602Z - verbose: [AssetDB] Require engine code (19881ms)
2022-06-23T02:05:23.630Z - log: [Package] ohos@1.0.0 enable
2022-06-23T02:05:23.665Z - log: [Package] open-harmonyos@1.0.0 enable
2022-06-23T02:05:23.689Z - log: [Package] oppo-mini-game@1.0.0 enable
2022-06-23T02:05:23.714Z - log: [Package] qtt@1.0.0 enable
2022-06-23T02:05:23.779Z - log: [Package] vivo-mini-game@1.0.0 enable
2022-06-23T02:05:23.830Z - log: [Package] web-desktop@1.0.0 enable
2022-06-23T02:05:23.942Z - log: [Package] web-mobile@1.0.0 enable
2022-06-23T02:05:23.991Z - log: [Package] wechatgame@1.0.1 enable
2022-06-23T02:05:24.018Z - log: [Package] windows@1.0.0 enable
2022-06-23T02:05:24.046Z - log: [Package] xiaomi-quick-game@1.0.0 enable
2022-06-23T02:05:24.404Z - log: [Package] cocos-service@3.0.3 enable
2022-06-23T02:05:24.525Z - log: [Package] importer@1.0.0 enable
2022-06-23T02:05:25.003Z - log: [Im-plugin] Check im-plugin version.
2022-06-23T02:05:25.018Z - log: [Package] im-plugin@3.0.8 enable
2022-06-23T02:05:26.456Z - log: 设置的 IP 地址不存在，将使用默认 IP
2022-06-23T02:05:26.733Z - log: [Im-plugin] No online info of im-plugin.
2022-06-23T02:05:36.947Z - verbose: [Scene] Require engine code (0ms)
2022-06-23T02:05:36.949Z - verbose: [Scene] Startup engine (1ms)
2022-06-23T02:05:36.991Z - log: [Scene] Cocos Creator v3.5.2
2022-06-23T02:05:37.121Z - log: [Scene] No need to specify the "type" of "FollowCamera.lookAtOffset" because cc.Vec3 is a child class of ValueType.
2022-06-23T02:05:37.416Z - verbose: [Scene] Open engine (467ms)
2022-06-23T02:05:37.419Z - verbose: [Scene] Configure engine (0ms)
2022-06-23T02:05:37.132Z - info: [Scene] Forward render pipeline initialized.
2022-06-23T02:05:38.175Z - log: [Scene] No need to specify the "type" of "FollowCamera.lookAtOffset" because cc.Vec3 is a child class of ValueType.
2022-06-23T02:07:20.585Z - log: 设置的 IP 地址不存在，将使用默认 IP
2022-06-23T02:17:27.323Z - log: [Scene] No need to specify the "type" of "FollowCamera.lookAtOffset" because cc.Vec3 is a child class of ValueType.
2022-06-23T02:17:44.626Z - log: 设置的 IP 地址不存在，将使用默认 IP
2022-06-23T02:17:44.940Z - log: 设置的 IP 地址不存在，将使用默认 IP
2022-06-23T02:24:06.202Z - error: [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos   
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)  
at async ParallelQueue._generate (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/asset-db.ccc:1:2165)
2022-06-23T02:25:16.364Z - error: [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos   
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at runMicrotasks (<anonymous>)  
at runNextTicks (internal/process/task_queues.js:58:5)  
at processImmediate (internal/timers.js:434:9)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)
2022-06-23T02:25:28.971Z - error: [Asset DB] ../res/rim_light.effect - standard-fs:frag: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:570: 'v_shadowPos' : redefinition
 

1 #version 100
2 #define USE_INSTANCING 1
3 #define USE_BATCHING 1
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
13 #define CC_USE_SKINNING 1
14 #define CC_USE_BAKED_ANIMATION 1
15 #define CC_USE_LIGHTMAP 1
16 #define CC_RECEIVE_SHADOW 1
17 #define CC_USE_MORPH 1
18 #define CC_MORPH_TARGET_COUNT 2
19 #define CC_MORPH_PRECOMPUTED 1
20 #define CC_MORPH_TARGET_HAS_POSITION 1
21 #define CC_MORPH_TARGET_HAS_NORMAL 1
22 #define CC_MORPH_TARGET_HAS_TANGENT 1
23 #define USE_VERTEX_COLOR 1
24 #define USE_NORMAL_MAP 1
25 #define HAS_SECOND_UV 1
26 #define CC_USE_IBL 0
27 #define CC_USE_DIFFUSEMAP 0
28 #define USE_REFLECTION_DENOISE 1
29 #define CC_FORWARD_ADD 1
30 #define CC_USE_HDR 1
31 #define USE_ALBEDO_MAP 1
32 #define ALBEDO_UV v_uv
33 #define NORMAL_UV v_uv
34 #define USE_PBR_MAP 1
35 #define PBR_UV v_uv
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define METALLIC_ROUGHNESS_UV v_uv
38 #define USE_OCCLUSION_MAP 1
39 #define OCCLUSION_UV v_uv
40 #define USE_EMISSIVE_MAP 1
41 #define EMISSIVE_UV v_uv
42 #define OCCLUSION_CHANNEL r
43 #define ROUGHNESS_CHANNEL g
44 #define METALLIC_CHANNEL b
45 #define USE_ALPHA_TEST 1
46 #define ALPHA_TEST_CHANNEL a
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp vec4 cc_cameraPos;
58   uniform mediump vec4 cc_mainLitDir;
59   uniform mediump vec4 cc_mainLitColor;
60   uniform mediump vec4 cc_ambientSky;
61   uniform mediump vec4 cc_ambientGround;
62 
63 
64 
65 
66 
67 
68 #define QUATER_PI         0.78539816340
69 #define HALF_PI           1.57079632679
70 #define PI                3.14159265359
71 #define PI2               6.28318530718
72 #define PI4               12.5663706144
73      
74 #define INV_QUATER_PI     1.27323954474
75 #define INV_HALF_PI       0.63661977237
76 #define INV_PI            0.31830988618
77 #define INV_PI2           0.15915494309
78 #define INV_PI4           0.07957747155
79      
80 #define EPSILON           1e-6
81 #define EPSILON_LOWP      1e-4
82 #define LOG2              1.442695
83 #define EXP_VALUE         2.71828183f
84 #define FP_MAX            65504.0
85 #define FP_SCALE          0.0009765625
86 #define FP_SCALE_INV      1024.0
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
88 
89 
90 
91 
92 
93 
94 
95 vec3 SRGBToLinear (vec3 gamma) {
96   return gamma * gamma;
97 }
98 uniform highp mat4 cc_matLightView;
99   uniform highp vec4 cc_shadowProjDepthInfo;
100   uniform highp vec4 cc_shadowProjInfo;
101   uniform mediump vec4 cc_shadowNFLSInfo;
102   uniform mediump vec4 cc_shadowWHPBInfo;
103   uniform mediump vec4 cc_shadowLPNNInfo;
104 
105 
106 
107 
108 
109 
110 
111 
112 highp float unpackHighpData (float mainPart, float modPart) {
113   highp float data = mainPart;
114   return data + modPart;
115 }
116 
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
118   highp float data = mainPart * modValue;
119   return data + modPart * modValue;
120 }
121 
122 
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
124   highp vec2 data = mainPart;
125   return data + modPart;
126 }
127 
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
129   highp vec2 data = mainPart * modValue;
130   return data + modPart * modValue;
131 }
132 
133 
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
135   highp vec3 data = mainPart;
136   return data + modPart;
137 }
138 
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
140   highp vec3 data = mainPart * modValue;
141   return data + modPart * modValue;
142 }
143 
144 
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
146   highp vec4 data = mainPart;
147   return data + modPart;
148 }
149 
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
151   highp vec4 data = mainPart * modValue;
152   return data + modPart * modValue;
153 }
154 #if CC_RECEIVE_SHADOW
155   uniform highp sampler2D cc_shadowMap;
156   uniform highp sampler2D cc_spotLightingMap;
157 
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
159   {
160     vec4 newShadowPos = shadowPos;
161     if(normalBias > EPSILON_LOWP)
162     {
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
164       if(viewNormal.z < 0.1)
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
166     }
167     return newShadowPos;
168   }
169   
170   
171 
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
173   {
174     float coeffA = cc_shadowProjDepthInfo.x;
175     float coeffB = cc_shadowProjDepthInfo.y;
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
177     viewSpacePos_z += viewspaceDepthBias;
178     vec4 result = shadowPos;
179     result.z = viewSpacePos_z * coeffA + coeffB;
180     return result;
181   }
182   
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
190 
191     float shadow = 0.0;
192     float closestDepth = 0.0;
193     if (cc_shadowLPNNInfo.y > EPSILON) {
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
195     } else {
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
197     }
198     shadow = step(clipPos.z, closestDepth);
199 
200     return shadow;
201   }
202 
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
210 
211     float offsetDepth = clipPos.z;
212     vec2 mapSize = cc_shadowWHPBInfo.xy;
213     vec2 oneTap = 1.0 / mapSize;
214     vec2 clipPos_offset = clipPos.xy + oneTap;
215 
216     float block0, block1, block2, block3;
217     if (cc_shadowLPNNInfo.y > EPSILON) {
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
222     } else {
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
227     }
228 
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
230     float resultX = mix(block0, block1, coefX);
231     float resultY = mix(block2, block3, coefX);
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
233 
234     return mix(resultX, resultY, coefY);
235   }
236 
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
244 
245     float offsetDepth = clipPos.z;
246     vec2 mapSize = cc_shadowWHPBInfo.xy;
247     vec2 oneTap = 1.0 / mapSize;
248     float clipPos_offset_L = clipPos.x - oneTap.x;
249     float clipPos_offset_R = clipPos.x + oneTap.x;
250     float clipPos_offset_U = clipPos.y - oneTap.y;
251     float clipPos_offset_D = clipPos.y + oneTap.y;
252 
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
254     if (cc_shadowLPNNInfo.y > EPSILON) {
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
264     } else {
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
274     }
275 
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
278 
279     float shadow = 0.0;
280     float resultX = mix(block0, block1, coefX);
281     float resultY = mix(block3, block4, coefX);
282     shadow += mix(resultX , resultY, coefY);
283 
284     resultX = mix(block1, block2, coefX);
285     resultY = mix(block4, block5, coefX);
286     shadow += mix(resultX , resultY, coefY);
287 
288     resultX = mix(block3, block4, coefX);
289     resultY = mix(block6, block7, coefX);
290     shadow += mix(resultX, resultY, coefY);
291 
292     resultX = mix(block4, block5, coefX);
293     resultY = mix(block7, block8, coefX);
294     shadow += mix(resultX, resultY, coefY);
295 
296     return shadow * 0.25;
297   }
298 
299   
300 
301   
302 
303   
304 
305 
306 
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
308 {
309   float realtimeShadow = 1.0;
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
311   
312   float pcf = cc_shadowWHPBInfo.z;
313   if (pcf > 1.9) { 
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
315   }else if (pcf > 0.9) {
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
317   }else { 
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
319   }
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
321 }
322 #endif
323 
324 
325 
326 #if CC_USE_IBL
327   uniform samplerCube cc_environment;
328   
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
330     
331       #ifdef GL_EXT_shader_texture_lod
332         return texture2DLodEXT(tex, coord, lod);
333       #else
334         return texture2D(tex, coord, lod);
335       #endif
336     
337   }
338   
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
340     
341       #ifdef GL_EXT_shader_texture_lod
342         return textureCubeLodEXT(tex, coord, lod);
343       #else
344         return textureCube(tex, coord, lod);
345       #endif
346     
347   }
348   
349   
350   
351   
352   
353   
354   
355   vec3 unpackRGBE (vec4 rgbe) {
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
357   }
358   
359 
360   #if CC_USE_DIFFUSEMAP
361     uniform samplerCube cc_diffuseMap;
362   #endif
363 #endif
364 
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
366   vec3 NxH = cross(N, H);
367   float OneMinusNoHSqr = dot(NxH, NxH);
368   float a = roughness * roughness;
369   float n = NoH * a;
370   float p = a / (OneMinusNoHSqr + n * n);
371   return p * p;
372 }
373 
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
376 }
377 
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
381   vec4 r = roughness * c0 + c1;
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
385   return specular * AB.x + AB.y;
386 }
387 
388 #if USE_REFLECTION_DENOISE
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
390     #if CC_USE_IBL
391     	float mip = roughness * mipCount;
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
394 
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
396      	vec4 filtered = textureCube(cc_environment, R);
397 
398       #if CC_USE_IBL == 2
399       	biased.rgb = unpackRGBE(biased);
400       	filtered.rgb = unpackRGBE(filtered);
401       #else
402       	biased.rgb = SRGBToLinear(biased.rgb);
403       	filtered.rgb = SRGBToLinear(filtered.rgb);
404       #endif
405       	
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
407     #else
408       return vec3(0.0, 0.0, 0.0);
409     #endif
410   }
411 #endif
412 
413 
414 struct StandardSurface {
415   vec4 albedo;
416   
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
418   vec3 position, position_fract_part;
419   #else
420   vec3 position;
421   #endif
422   vec3 normal;
423   vec3 emissive;
424   vec3 lightmap;
425   float lightmap_test;
426   float roughness;
427   float metallic;
428   float occlusion;
429   float specularIntensity;
430 
431   #if CC_RECEIVE_SHADOW
432     vec2 shadowBias;
433   #endif
434 };
435 
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
440 
441   vec3 position;
442   
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
444   position = unpackHighpData(s.position, s.position_fract_part);
445   #else
446   position = s.position;
447   #endif
448 
449   vec3 N = normalize(s.normal);
450   vec3 V = normalize(cc_cameraPos.xyz - position);
451 
452   float NV = max(abs(dot(N, V)), 0.0);
453   specular = BRDFApprox(specular, s.roughness, NV);
454 
455   vec3 L = normalize(-cc_mainLitDir.xyz);
456   vec3 H = normalize(L + V);
457   float NH = max(dot(N, H), 0.0);
458   float NL = max(dot(N, L), 0.0);
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
460   vec3 diffuseContrib = diffuse / PI;
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);
463 
464   float shadow = 1.0;
465   #if CC_RECEIVE_SHADOW
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
468     }
469   #endif
470 
471   dirlightContrib *= shadow;
472   finalColor *= dirlightContrib;
473 
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
475     if (s.lightmap_test > EPSILON_LOWP) {
476       finalColor = diffuse * s.lightmap.rgb * shadow;
477     }
478   #endif
479 
480   float fAmb = 0.5 - N.y * 0.5;
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
482 
483 
484   #if CC_USE_IBL
485     #if CC_USE_DIFFUSEMAP
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
487       #if CC_USE_DIFFUSEMAP == 2
488         ambDiff = unpackRGBE(diffuseMap);
489       #else
490         ambDiff = SRGBToLinear(diffuseMap.rgb);
491       #endif
492     #endif
493 
494     vec3 R = normalize(reflect(-V, N));
495 
496     #if USE_REFLECTION_DENOISE
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
498     #else
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
500 
501       #if CC_USE_IBL == 2
502         vec3 env = unpackRGBE(envmap);
503       #else
504         vec3 env = SRGBToLinear(envmap.rgb);
505       #endif
506     #endif
507 
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
509   #endif
510 
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
512   
513 
514   finalColor += s.emissive;
515 
516   return vec4(finalColor, s.albedo.a);
517 }
518 
519 
520 
521 vec3 ACESToneMap (vec3 color) {
522   color = min(color, vec3(8.0));
523   const float A = 2.51;
524   const float B = 0.03;
525   const float C = 2.43;
526   const float D = 0.59;
527   const float E = 0.14;
528   return (color * (A * color + B)) / (color * (C * color + D) + E);
529 }
530 
531 
532 
533 vec4 CCFragOutput (vec4 color) {
534   #if CC_USE_HDR
535     color.rgb = ACESToneMap(color.rgb);
536   #endif
537   color.rgb = sqrt(color.rgb);
538   return color;
539 }
540 
541 
542 
543      uniform vec4 rimColor;
544      uniform vec4 albedo;
545      uniform vec4 albedoScaleAndCutoff;
546      uniform vec4 pbrParams;
547      uniform vec4 emissive;
548      uniform vec4 emissiveScaleParam;
549 
550 
551 
552 
553 varying highp vec4 v_shadowPos;
554 
555 
556 
557 #if CC_RECEIVE_SHADOW
558 
559 
560 
561 #endif
562 
563 
564 varying vec3 v_position;
565 varying vec3 v_view_position;
566 varying vec2 v_uv;
567 varying vec2 v_uv1;
568 varying vec3 v_normal;
569 varying vec3 v_view_normal;
570 varying vec4 v_shadowPos;
571 
572 #if USE_VERTEX_COLOR
573   varying vec3 v_color;
574 #endif
575 
576 #if USE_ALBEDO_MAP
577   uniform sampler2D albedoMap;
578 #endif
579 #if USE_NORMAL_MAP
580   varying vec3 v_tangent;
581   varying vec3 v_bitangent;
582   uniform sampler2D normalMap;
583 #endif
584 #if USE_PBR_MAP
585   uniform sampler2D pbrMap;
586 #endif
587 #if USE_METALLIC_ROUGHNESS_MAP
588   uniform sampler2D metallicRoughnessMap;
589 #endif
590 #if USE_OCCLUSION_MAP
591   uniform sampler2D occlusionMap;
592 #endif
593 #if USE_EMISSIVE_MAP
594   uniform sampler2D emissiveMap;
595 #endif
596 #if CC_USE_LIGHTMAP
597   varying vec2 v_luv;
598   uniform sampler2D cc_lightingMap;
599 #endif
600 #if USE_ALPHA_TEST
601 #endif
602 
603 void surf (out StandardSurface s) {
604   vec4 baseColor = albedo;
605   #if USE_VERTEX_COLOR
606     baseColor.rgb *= v_color;
607   #endif
608   #if USE_ALBEDO_MAP
609     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);
610     texColor.rgb = SRGBToLinear(texColor.rgb);
611     baseColor *= texColor;
612   #endif
613   s.albedo = baseColor;
614   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
615 
616   #if USE_ALPHA_TEST
617     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
618   #endif
619   float density = 0.001;
620   float dist2 = dot(v_view_position,v_view_position);
621   float fogFactor = exp( -density*density * dist2);
622   fogFactor = clamp(fogFactor, 0.0, 1.0);
623 
624   vec3 fogColor = vec3(1.0,1,1.0);
625   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);
626 
627   s.normal = v_normal;
628   #if USE_NORMAL_MAP
629     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);
630     s.normal =
631       (nmmp.x * pbrParams.w) * normalize(v_tangent) +
632       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +
633       nmmp.z * normalize(s.normal);
634   #endif
635 
636   s.position = v_position;
637 
638   vec4 pbr = pbrParams;
639   #if USE_PBR_MAP
640     vec4 res = texture2D(pbrMap, PBR_UV);
641     pbr.x *= res.OCCLUSION_CHANNEL;
642     pbr.y *= res.ROUGHNESS_CHANNEL;
643     pbr.z *= res.METALLIC_CHANNEL;
644   #endif
645   #if USE_METALLIC_ROUGHNESS_MAP
646     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);
647     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
648     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
649   #endif
650   #if USE_OCCLUSION_MAP
651     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;
652   #endif
653   s.occlusion = clamp(pbr.x, 0.0, 0.96);
654   s.roughness = clamp(pbr.y, 0.04, 1.0);
655   s.specularIntensity = 0.5;
656   s.metallic = pbr.z;
657 
658   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
659   #if USE_EMISSIVE_MAP
660     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);
661   #endif
662 }
663 
664 vec4 frag () {
665   StandardSurface s; surf(s);
666   vec4 color = CCStandardShadingBase(s, v_shadowPos);
667 
668   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING
669     vec4 lighting = texture2D(cc_lightingMap, v_luv);
670 
671     float fAmb = 0.5 - s.normal.y * 0.5;
672     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
673 
674     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);
675     finalColor += lighting.rgb *  s.albedo.rgb;
676     finalColor = finalColor * s.occlusion;
677     finalColor += s.emissive;
678 
679     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;
680   #endif
681 
682   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;
683 
684   color.rgb = mix(color.rgb,rimColor.rgb,fRim);
685 
686   return CCFragOutput(color);
687 }
688 
689 
690 void main() { gl_FragColor = frag(); }
691 [Asset DB] ../res/rim_light.effect - standard-fs:frag: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:570: 'v_shadowPos' : redefinition
 

1 #version 100
2 #define USE_INSTANCING 1
3 #define USE_BATCHING 1
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
13 #define CC_USE_SKINNING 1
14 #define CC_USE_BAKED_ANIMATION 1
15 #define CC_USE_LIGHTMAP 1
16 #define CC_RECEIVE_SHADOW 1
17 #define CC_USE_MORPH 1
18 #define CC_MORPH_TARGET_COUNT 2
19 #define CC_MORPH_PRECOMPUTED 1
20 #define CC_MORPH_TARGET_HAS_POSITION 1
21 #define CC_MORPH_TARGET_HAS_NORMAL 1
22 #define CC_MORPH_TARGET_HAS_TANGENT 1
23 #define USE_VERTEX_COLOR 1
24 #define USE_NORMAL_MAP 1
25 #define HAS_SECOND_UV 1
26 #define CC_USE_IBL 0
27 #define CC_USE_DIFFUSEMAP 0
28 #define USE_REFLECTION_DENOISE 1
29 #define CC_FORWARD_ADD 1
30 #define CC_USE_HDR 1
31 #define USE_ALBEDO_MAP 1
32 #define ALBEDO_UV v_uv
33 #define NORMAL_UV v_uv
34 #define USE_PBR_MAP 1
35 #define PBR_UV v_uv
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define METALLIC_ROUGHNESS_UV v_uv
38 #define USE_OCCLUSION_MAP 1
39 #define OCCLUSION_UV v_uv
40 #define USE_EMISSIVE_MAP 1
41 #define EMISSIVE_UV v_uv
42 #define OCCLUSION_CHANNEL r
43 #define ROUGHNESS_CHANNEL g
44 #define METALLIC_CHANNEL b
45 #define USE_ALPHA_TEST 1
46 #define ALPHA_TEST_CHANNEL a
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp vec4 cc_cameraPos;
58   uniform mediump vec4 cc_mainLitDir;
59   uniform mediump vec4 cc_mainLitColor;
60   uniform mediump vec4 cc_ambientSky;
61   uniform mediump vec4 cc_ambientGround;
62 
63 
64 
65 
66 
67 
68 #define QUATER_PI         0.78539816340
69 #define HALF_PI           1.57079632679
70 #define PI                3.14159265359
71 #define PI2               6.28318530718
72 #define PI4               12.5663706144
73      
74 #define INV_QUATER_PI     1.27323954474
75 #define INV_HALF_PI       0.63661977237
76 #define INV_PI            0.31830988618
77 #define INV_PI2           0.15915494309
78 #define INV_PI4           0.07957747155
79      
80 #define EPSILON           1e-6
81 #define EPSILON_LOWP      1e-4
82 #define LOG2              1.442695
83 #define EXP_VALUE         2.71828183f
84 #define FP_MAX            65504.0
85 #define FP_SCALE          0.0009765625
86 #define FP_SCALE_INV      1024.0
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
88 
89 
90 
91 
92 
93 
94 
95 vec3 SRGBToLinear (vec3 gamma) {
96   return gamma * gamma;
97 }
98 uniform highp mat4 cc_matLightView;
99   uniform highp vec4 cc_shadowProjDepthInfo;
100   uniform highp vec4 cc_shadowProjInfo;
101   uniform mediump vec4 cc_shadowNFLSInfo;
102   uniform mediump vec4 cc_shadowWHPBInfo;
103   uniform mediump vec4 cc_shadowLPNNInfo;
104 
105 
106 
107 
108 
109 
110 
111 
112 highp float unpackHighpData (float mainPart, float modPart) {
113   highp float data = mainPart;
114   return data + modPart;
115 }
116 
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
118   highp float data = mainPart * modValue;
119   return data + modPart * modValue;
120 }
121 
122 
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
124   highp vec2 data = mainPart;
125   return data + modPart;
126 }
127 
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
129   highp vec2 data = mainPart * modValue;
130   return data + modPart * modValue;
131 }
132 
133 
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
135   highp vec3 data = mainPart;
136   return data + modPart;
137 }
138 
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
140   highp vec3 data = mainPart * modValue;
141   return data + modPart * modValue;
142 }
143 
144 
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
146   highp vec4 data = mainPart;
147   return data + modPart;
148 }
149 
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
151   highp vec4 data = mainPart * modValue;
152   return data + modPart * modValue;
153 }
154 #if CC_RECEIVE_SHADOW
155   uniform highp sampler2D cc_shadowMap;
156   uniform highp sampler2D cc_spotLightingMap;
157 
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
159   {
160     vec4 newShadowPos = shadowPos;
161     if(normalBias > EPSILON_LOWP)
162     {
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
164       if(viewNormal.z < 0.1)
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
166     }
167     return newShadowPos;
168   }
169   
170   
171 
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
173   {
174     float coeffA = cc_shadowProjDepthInfo.x;
175     float coeffB = cc_shadowProjDepthInfo.y;
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
177     viewSpacePos_z += viewspaceDepthBias;
178     vec4 result = shadowPos;
179     result.z = viewSpacePos_z * coeffA + coeffB;
180     return result;
181   }
182   
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
190 
191     float shadow = 0.0;
192     float closestDepth = 0.0;
193     if (cc_shadowLPNNInfo.y > EPSILON) {
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
195     } else {
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
197     }
198     shadow = step(clipPos.z, closestDepth);
199 
200     return shadow;
201   }
202 
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
210 
211     float offsetDepth = clipPos.z;
212     vec2 mapSize = cc_shadowWHPBInfo.xy;
213     vec2 oneTap = 1.0 / mapSize;
214     vec2 clipPos_offset = clipPos.xy + oneTap;
215 
216     float block0, block1, block2, block3;
217     if (cc_shadowLPNNInfo.y > EPSILON) {
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
222     } else {
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
227     }
228 
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
230     float resultX = mix(block0, block1, coefX);
231     float resultY = mix(block2, block3, coefX);
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
233 
234     return mix(resultX, resultY, coefY);
235   }
236 
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
244 
245     float offsetDepth = clipPos.z;
246     vec2 mapSize = cc_shadowWHPBInfo.xy;
247     vec2 oneTap = 1.0 / mapSize;
248     float clipPos_offset_L = clipPos.x - oneTap.x;
249     float clipPos_offset_R = clipPos.x + oneTap.x;
250     float clipPos_offset_U = clipPos.y - oneTap.y;
251     float clipPos_offset_D = clipPos.y + oneTap.y;
252 
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
254     if (cc_shadowLPNNInfo.y > EPSILON) {
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
264     } else {
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
274     }
275 
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
278 
279     float shadow = 0.0;
280     float resultX = mix(block0, block1, coefX);
281     float resultY = mix(block3, block4, coefX);
282     shadow += mix(resultX , resultY, coefY);
283 
284     resultX = mix(block1, block2, coefX);
285     resultY = mix(block4, block5, coefX);
286     shadow += mix(resultX , resultY, coefY);
287 
288     resultX = mix(block3, block4, coefX);
289     resultY = mix(block6, block7, coefX);
290     shadow += mix(resultX, resultY, coefY);
291 
292     resultX = mix(block4, block5, coefX);
293     resultY = mix(block7, block8, coefX);
294     shadow += mix(resultX, resultY, coefY);
295 
296     return shadow * 0.25;
297   }
298 
299   
300 
301   
302 
303   
304 
305 
306 
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
308 {
309   float realtimeShadow = 1.0;
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
311   
312   float pcf = cc_shadowWHPBInfo.z;
313   if (pcf > 1.9) { 
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
315   }else if (pcf > 0.9) {
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
317   }else { 
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
319   }
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
321 }
322 #endif
323 
324 
325 
326 #if CC_USE_IBL
327   uniform samplerCube cc_environment;
328   
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
330     
331       #ifdef GL_EXT_shader_texture_lod
332         return texture2DLodEXT(tex, coord, lod);
333       #else
334         return texture2D(tex, coord, lod);
335       #endif
336     
337   }
338   
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
340     
341       #ifdef GL_EXT_shader_texture_lod
342         return textureCubeLodEXT(tex, coord, lod);
343       #else
344         return textureCube(tex, coord, lod);
345       #endif
346     
347   }
348   
349   
350   
351   
352   
353   
354   
355   vec3 unpackRGBE (vec4 rgbe) {
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
357   }
358   
359 
360   #if CC_USE_DIFFUSEMAP
361     uniform samplerCube cc_diffuseMap;
362   #endif
363 #endif
364 
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
366   vec3 NxH = cross(N, H);
367   float OneMinusNoHSqr = dot(NxH, NxH);
368   float a = roughness * roughness;
369   float n = NoH * a;
370   float p = a / (OneMinusNoHSqr + n * n);
371   return p * p;
372 }
373 
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
376 }
377 
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
381   vec4 r = roughness * c0 + c1;
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
385   return specular * AB.x + AB.y;
386 }
387 
388 #if USE_REFLECTION_DENOISE
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
390     #if CC_USE_IBL
391     	float mip = roughness * mipCount;
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
394 
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
396      	vec4 filtered = textureCube(cc_environment, R);
397 
398       #if CC_USE_IBL == 2
399       	biased.rgb = unpackRGBE(biased);
400       	filtered.rgb = unpackRGBE(filtered);
401       #else
402       	biased.rgb = SRGBToLinear(biased.rgb);
403       	filtered.rgb = SRGBToLinear(filtered.rgb);
404       #endif
405       	
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
407     #else
408       return vec3(0.0, 0.0, 0.0);
409     #endif
410   }
411 #endif
412 
413 
414 struct StandardSurface {
415   vec4 albedo;
416   
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
418   vec3 position, position_fract_part;
419   #else
420   vec3 position;
421   #endif
422   vec3 normal;
423   vec3 emissive;
424   vec3 lightmap;
425   float lightmap_test;
426   float roughness;
427   float metallic;
428   float occlusion;
429   float specularIntensity;
430 
431   #if CC_RECEIVE_SHADOW
432     vec2 shadowBias;
433   #endif
434 };
435 
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
440 
441   vec3 position;
442   
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
444   position = unpackHighpData(s.position, s.position_fract_part);
445   #else
446   position = s.position;
447   #endif
448 
449   vec3 N = normalize(s.normal);
450   vec3 V = normalize(cc_cameraPos.xyz - position);
451 
452   float NV = max(abs(dot(N, V)), 0.0);
453   specular = BRDFApprox(specular, s.roughness, NV);
454 
455   vec3 L = normalize(-cc_mainLitDir.xyz);
456   vec3 H = normalize(L + V);
457   float NH = max(dot(N, H), 0.0);
458   float NL = max(dot(N, L), 0.0);
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
460   vec3 diffuseContrib = diffuse / PI;
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);
463 
464   float shadow = 1.0;
465   #if CC_RECEIVE_SHADOW
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
468     }
469   #endif
470 
471   dirlightContrib *= shadow;
472   finalColor *= dirlightContrib;
473 
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
475     if (s.lightmap_test > EPSILON_LOWP) {
476       finalColor = diffuse * s.lightmap.rgb * shadow;
477     }
478   #endif
479 
480   float fAmb = 0.5 - N.y * 0.5;
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
482 
483 
484   #if CC_USE_IBL
485     #if CC_USE_DIFFUSEMAP
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
487       #if CC_USE_DIFFUSEMAP == 2
488         ambDiff = unpackRGBE(diffuseMap);
489       #else
490         ambDiff = SRGBToLinear(diffuseMap.rgb);
491       #endif
492     #endif
493 
494     vec3 R = normalize(reflect(-V, N));
495 
496     #if USE_REFLECTION_DENOISE
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
498     #else
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
500 
501       #if CC_USE_IBL == 2
502         vec3 env = unpackRGBE(envmap);
503       #else
504         vec3 env = SRGBToLinear(envmap.rgb);
505       #endif
506     #endif
507 
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
509   #endif
510 
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
512   
513 
514   finalColor += s.emissive;
515 
516   return vec4(finalColor, s.albedo.a);
517 }
518 
519 
520 
521 vec3 ACESToneMap (vec3 color) {
522   color = min(color, vec3(8.0));
523   const float A = 2.51;
524   const float B = 0.03;
525   const float C = 2.43;
526   const float D = 0.59;
527   const float E = 0.14;
528   return (color * (A * color + B)) / (color * (C * color + D) + E);
529 }
530 
531 
532 
533 vec4 CCFragOutput (vec4 color) {
534   #if CC_USE_HDR
535     color.rgb = ACESToneMap(color.rgb);
536   #endif
537   color.rgb = sqrt(color.rgb);
538   return color;
539 }
540 
541 
542 
543      uniform vec4 rimColor;
544      uniform vec4 albedo;
545      uniform vec4 albedoScaleAndCutoff;
546      uniform vec4 pbrParams;
547      uniform vec4 emissive;
548      uniform vec4 emissiveScaleParam;
549 
550 
551 
552 
553 varying highp vec4 v_shadowPos;
554 
555 
556 
557 #if CC_RECEIVE_SHADOW
558 
559 
560 
561 #endif
562 
563 
564 varying vec3 v_position;
565 varying vec3 v_view_position;
566 varying vec2 v_uv;
567 varying vec2 v_uv1;
568 varying vec3 v_normal;
569 varying vec3 v_view_normal;
570 varying vec4 v_shadowPos;
571 
572 #if USE_VERTEX_COLOR
573   varying vec3 v_color;
574 #endif
575 
576 #if USE_ALBEDO_MAP
577   uniform sampler2D albedoMap;
578 #endif
579 #if USE_NORMAL_MAP
580   varying vec3 v_tangent;
581   varying vec3 v_bitangent;
582   uniform sampler2D normalMap;
583 #endif
584 #if USE_PBR_MAP
585   uniform sampler2D pbrMap;
586 #endif
587 #if USE_METALLIC_ROUGHNESS_MAP
588   uniform sampler2D metallicRoughnessMap;
589 #endif
590 #if USE_OCCLUSION_MAP
591   uniform sampler2D occlusionMap;
592 #endif
593 #if USE_EMISSIVE_MAP
594   uniform sampler2D emissiveMap;
595 #endif
596 #if CC_USE_LIGHTMAP
597   varying vec2 v_luv;
598   uniform sampler2D cc_lightingMap;
599 #endif
600 #if USE_ALPHA_TEST
601 #endif
602 
603 void surf (out StandardSurface s) {
604   vec4 baseColor = albedo;
605   #if USE_VERTEX_COLOR
606     baseColor.rgb *= v_color;
607   #endif
608   #if USE_ALBEDO_MAP
609     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);
610     texColor.rgb = SRGBToLinear(texColor.rgb);
611     baseColor *= texColor;
612   #endif
613   s.albedo = baseColor;
614   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
615 
616   #if USE_ALPHA_TEST
617     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
618   #endif
619   float density = 0.001;
620   float dist2 = dot(v_view_position,v_view_position);
621   float fogFactor = exp( -density*density * dist2);
622   fogFactor = clamp(fogFactor, 0.0, 1.0);
623 
624   vec3 fogColor = vec3(1.0,1,1.0);
625   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);
626 
627   s.normal = v_normal;
628   #if USE_NORMAL_MAP
629     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);
630     s.normal =
631       (nmmp.x * pbrParams.w) * normalize(v_tangent) +
632       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +
633       nmmp.z * normalize(s.normal);
634   #endif
635 
636   s.position = v_position;
637 
638   vec4 pbr = pbrParams;
639   #if USE_PBR_MAP
640     vec4 res = texture2D(pbrMap, PBR_UV);
641     pbr.x *= res.OCCLUSION_CHANNEL;
642     pbr.y *= res.ROUGHNESS_CHANNEL;
643     pbr.z *= res.METALLIC_CHANNEL;
644   #endif
645   #if USE_METALLIC_ROUGHNESS_MAP
646     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);
647     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
648     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
649   #endif
650   #if USE_OCCLUSION_MAP
651     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;
652   #endif
653   s.occlusion = clamp(pbr.x, 0.0, 0.96);
654   s.roughness = clamp(pbr.y, 0.04, 1.0);
655   s.specularIntensity = 0.5;
656   s.metallic = pbr.z;
657 
658   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
659   #if USE_EMISSIVE_MAP
660     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);
661   #endif
662 }
663 
664 vec4 frag () {
665   StandardSurface s; surf(s);
666   vec4 color = CCStandardShadingBase(s, v_shadowPos);
667 
668   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING
669     vec4 lighting = texture2D(cc_lightingMap, v_luv);
670 
671     float fAmb = 0.5 - s.normal.y * 0.5;
672     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
673 
674     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);
675     finalColor += lighting.rgb *  s.albedo.rgb;
676     finalColor = finalColor * s.occlusion;
677     finalColor += s.emissive;
678 
679     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;
680   #endif
681 
682   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;
683 
684   color.rgb = mix(color.rgb,rimColor.rgb,fRim);
685 
686   return CCFragOutput(color);
687 }
688 
689 
690 void main() { gl_FragColor = frag(); }
691   
2 #define USE_INSTANCING 1  
3 #define USE_BATCHING 1  
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1  
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024  
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024  
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128  
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128  
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0  
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0  
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0  
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0  
13 #define CC_USE_SKINNING 1  
14 #define CC_USE_BAKED_ANIMATION 1  
15 #define CC_USE_LIGHTMAP 1  
16 #define CC_RECEIVE_SHADOW 1  
17 #define CC_USE_MORPH 1  
18 #define CC_MORPH_TARGET_COUNT 2  
19 #define CC_MORPH_PRECOMPUTED 1  
20 #define CC_MORPH_TARGET_HAS_POSITION 1  
21 #define CC_MORPH_TARGET_HAS_NORMAL 1  
22 #define CC_MORPH_TARGET_HAS_TANGENT 1  
23 #define USE_VERTEX_COLOR 1  
24 #define USE_NORMAL_MAP 1  
25 #define HAS_SECOND_UV 1  
26 #define CC_USE_IBL 0  
27 #define CC_USE_DIFFUSEMAP 0  
28 #define USE_REFLECTION_DENOISE 1  
29 #define CC_FORWARD_ADD 1  
30 #define CC_USE_HDR 1  
31 #define USE_ALBEDO_MAP 1  
32 #define ALBEDO_UV v_uv  
33 #define NORMAL_UV v_uv  
34 #define USE_PBR_MAP 1  
35 #define PBR_UV v_uv  
36 #define USE_METALLIC_ROUGHNESS_MAP 1  
37 #define METALLIC_ROUGHNESS_UV v_uv  
38 #define USE_OCCLUSION_MAP 1  
39 #define OCCLUSION_UV v_uv  
40 #define USE_EMISSIVE_MAP 1  
41 #define EMISSIVE_UV v_uv  
42 #define OCCLUSION_CHANNEL r  
43 #define ROUGHNESS_CHANNEL g  
44 #define METALLIC_CHANNEL b  
45 #define USE_ALPHA_TEST 1  
46 #define ALPHA_TEST_CHANNEL a  
47  
48 #ifdef GL_OES_standard_derivatives  
49 #extension GL_OES_standard_derivatives: enable  
50 #endif  
51  
52 #ifdef GL_EXT_shader_texture_lod  
53 #extension GL_EXT_shader_texture_lod: enable  
54 #endif  
55  
56 precision highp float;  
57 uniform highp vec4 cc_cameraPos;  
58   uniform mediump vec4 cc_mainLitDir;  
59   uniform mediump vec4 cc_mainLitColor;  
60   uniform mediump vec4 cc_ambientSky;  
61   uniform mediump vec4 cc_ambientGround;  
62  
63  
64  
65  
66  
67  
68 #define QUATER_PI         0.78539816340  
69 #define HALF_PI           1.57079632679  
70 #define PI                3.14159265359  
71 #define PI2               6.28318530718  
72 #define PI4               12.5663706144  
73  
74 #define INV_QUATER_PI     1.27323954474  
75 #define INV_HALF_PI       0.63661977237  
76 #define INV_PI            0.31830988618  
77 #define INV_PI2           0.15915494309  
78 #define INV_PI4           0.07957747155  
79  
80 #define EPSILON           1e-6  
81 #define EPSILON_LOWP      1e-4  
82 #define LOG2              1.442695  
83 #define EXP_VALUE         2.71828183f  
84 #define FP_MAX            65504.0  
85 #define FP_SCALE          0.0009765625  
86 #define FP_SCALE_INV      1024.0  
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)  
88  
89  
90  
91  
92  
93  
94  
95 vec3 SRGBToLinear (vec3 gamma) {  
96   return gamma * gamma;  
97 }  
98 uniform highp mat4 cc_matLightView;  
99   uniform highp vec4 cc_shadowProjDepthInfo;  
100   uniform highp vec4 cc_shadowProjInfo;  
101   uniform mediump vec4 cc_shadowNFLSInfo;  
102   uniform mediump vec4 cc_shadowWHPBInfo;  
103   uniform mediump vec4 cc_shadowLPNNInfo;  
104  
105  
106  
107  
108  
109  
110  
111  
112 highp float unpackHighpData (float mainPart, float modPart) {  
113   highp float data = mainPart;  
114   return data + modPart;  
115 }  
116  
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {  
118   highp float data = mainPart * modValue;  
119   return data + modPart * modValue;  
120 }  
121  
122  
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {  
124   highp vec2 data = mainPart;  
125   return data + modPart;  
126 }  
127  
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {  
129   highp vec2 data = mainPart * modValue;  
130   return data + modPart * modValue;  
131 }  
132  
133  
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {  
135   highp vec3 data = mainPart;  
136   return data + modPart;  
137 }  
138  
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {  
140   highp vec3 data = mainPart * modValue;  
141   return data + modPart * modValue;  
142 }  
143  
144  
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {  
146   highp vec4 data = mainPart;  
147   return data + modPart;  
148 }  
149  
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {  
151   highp vec4 data = mainPart * modValue;  
152   return data + modPart * modValue;  
153 }  
154 #if CC_RECEIVE_SHADOW  
155   uniform highp sampler2D cc_shadowMap;  
156   uniform highp sampler2D cc_spotLightingMap;  
157  
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)  
159   {  
160     vec4 newShadowPos = shadowPos;  
161     if(normalBias > EPSILON_LOWP)  
162     {  
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);  
164       if(viewNormal.z < 0.1)  
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);  
166     }  
167     return newShadowPos;  
168   }  
169  
170  
171  
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)  
173   {  
174     float coeffA = cc_shadowProjDepthInfo.x;  
175     float coeffB = cc_shadowProjDepthInfo.y;  
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;  
177     viewSpacePos_z += viewspaceDepthBias;  
178     vec4 result = shadowPos;  
179     result.z = viewSpacePos_z * coeffA + coeffB;  
180     return result;  
181   }  
182  
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {  
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
190  
191     float shadow = 0.0;  
192     float closestDepth = 0.0;  
193     if (cc_shadowLPNNInfo.y > EPSILON) {  
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));  
195     } else {  
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;  
197     }  
198     shadow = step(clipPos.z, closestDepth);  
199  
200     return shadow;  
201   }  
202  
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {  
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
210  
211     float offsetDepth = clipPos.z;  
212     vec2 mapSize = cc_shadowWHPBInfo.xy;  
213     vec2 oneTap = 1.0 / mapSize;  
214     vec2 clipPos_offset = clipPos.xy + oneTap;  
215  
216     float block0, block1, block2, block3;  
217     if (cc_shadowLPNNInfo.y > EPSILON) {  
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
222     } else {  
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);  
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);  
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);  
227     }  
228  
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;  
230     float resultX = mix(block0, block1, coefX);  
231     float resultY = mix(block2, block3, coefX);  
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;  
233  
234     return mix(resultX, resultY, coefY);  
235   }  
236  
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {  
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
244  
245     float offsetDepth = clipPos.z;  
246     vec2 mapSize = cc_shadowWHPBInfo.xy;  
247     vec2 oneTap = 1.0 / mapSize;  
248     float clipPos_offset_L = clipPos.x - oneTap.x;  
249     float clipPos_offset_R = clipPos.x + oneTap.x;  
250     float clipPos_offset_U = clipPos.y - oneTap.y;  
251     float clipPos_offset_D = clipPos.y + oneTap.y;  
252  
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;  
254     if (cc_shadowLPNNInfo.y > EPSILON) {  
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
264     } else {  
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);  
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);  
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);  
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);  
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);  
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);  
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);  
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);  
274     }  
275  
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;  
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;  
278  
279     float shadow = 0.0;  
280     float resultX = mix(block0, block1, coefX);  
281     float resultY = mix(block3, block4, coefX);  
282     shadow += mix(resultX , resultY, coefY);  
283  
284     resultX = mix(block1, block2, coefX);  
285     resultY = mix(block4, block5, coefX);  
286     shadow += mix(resultX , resultY, coefY);  
287  
288     resultX = mix(block3, block4, coefX);  
289     resultY = mix(block6, block7, coefX);  
290     shadow += mix(resultX, resultY, coefY);  
291  
292     resultX = mix(block4, block5, coefX);  
293     resultY = mix(block7, block8, coefX);  
294     shadow += mix(resultX, resultY, coefY);  
295  
296     return shadow * 0.25;  
297   }  
298  
299  
300  
301  
302  
303  
304  
305  
306  
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)  
308 {  
309   float realtimeShadow = 1.0;  
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);  
311  
312   float pcf = cc_shadowWHPBInfo.z;  
313   if (pcf > 1.9) {  
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);  
315   }else if (pcf > 0.9) {  
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);  
317   }else {  
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);  
319   }  
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);  
321 }  
322 #endif  
323  
324  
325  
326 #if CC_USE_IBL  
327   uniform samplerCube cc_environment;  
328  
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {  
330  
331       #ifdef GL_EXT_shader_texture_lod  
332         return texture2DLodEXT(tex, coord, lod);  
333       #else  
334         return texture2D(tex, coord, lod);  
335       #endif  
336  
337   }  
338  
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {  
340  
341       #ifdef GL_EXT_shader_texture_lod  
342         return textureCubeLodEXT(tex, coord, lod);  
343       #else  
344         return textureCube(tex, coord, lod);  
345       #endif  
346  
347   }  
348  
349  
350  
351  
352  
353  
354  
355   vec3 unpackRGBE (vec4 rgbe) {  
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);  
357   }  
358  
359  
360   #if CC_USE_DIFFUSEMAP  
361     uniform samplerCube cc_diffuseMap;  
362   #endif  
363 #endif  
364  
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {  
366   vec3 NxH = cross(N, H);  
367   float OneMinusNoHSqr = dot(NxH, NxH);  
368   float a = roughness * roughness;  
369   float n = NoH * a;  
370   float p = a / (OneMinusNoHSqr + n * n);  
371   return p * p;  
372 }  
373  
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {  
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);  
376 }  
377  
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {  
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);  
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);  
381   vec4 r = roughness * c0 + c1;  
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;  
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;  
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);  
385   return specular * AB.x + AB.y;  
386 }  
387  
388 #if USE_REFLECTION_DENOISE  
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {  
390     #if CC_USE_IBL  
391     	float mip = roughness * mipCount;  
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;  
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));  
394  
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);  
396      	vec4 filtered = textureCube(cc_environment, R);  
397  
398       #if CC_USE_IBL == 2  
399       	biased.rgb = unpackRGBE(biased);  
400       	filtered.rgb = unpackRGBE(filtered);  
401       #else  
402       	biased.rgb = SRGBToLinear(biased.rgb);  
403       	filtered.rgb = SRGBToLinear(filtered.rgb);  
404       #endif  
405  
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);  
407     #else  
408       return vec3(0.0, 0.0, 0.0);  
409     #endif  
410   }  
411 #endif  
412  
413  
414 struct StandardSurface {  
415   vec4 albedo;  
416  
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
418   vec3 position, position_fract_part;  
419   #else  
420   vec3 position;  
421   #endif  
422   vec3 normal;  
423   vec3 emissive;  
424   vec3 lightmap;  
425   float lightmap_test;  
426   float roughness;  
427   float metallic;  
428   float occlusion;  
429   float specularIntensity;  
430  
431   #if CC_RECEIVE_SHADOW  
432     vec2 shadowBias;  
433   #endif  
434 };  
435  
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {  
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);  
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);  
440  
441   vec3 position;  
442  
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
444   position = unpackHighpData(s.position, s.position_fract_part);  
445   #else  
446   position = s.position;  
447   #endif  
448  
449   vec3 N = normalize(s.normal);  
450   vec3 V = normalize(cc_cameraPos.xyz - position);  
451  
452   float NV = max(abs(dot(N, V)), 0.0);  
453   specular = BRDFApprox(specular, s.roughness, NV);  
454  
455   vec3 L = normalize(-cc_mainLitDir.xyz);  
456   vec3 H = normalize(L + V);  
457   float NH = max(dot(N, H), 0.0);  
458   float NL = max(dot(N, L), 0.0);  
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;  
460   vec3 diffuseContrib = diffuse / PI;  
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);  
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);  
463  
464   float shadow = 1.0;  
465   #if CC_RECEIVE_SHADOW  
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {  
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);  
468     }  
469   #endif  
470  
471   dirlightContrib *= shadow;  
472   finalColor *= dirlightContrib;  
473  
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD  
475     if (s.lightmap_test > EPSILON_LOWP) {  
476       finalColor = diffuse * s.lightmap.rgb * shadow;  
477     }  
478   #endif  
479  
480   float fAmb = 0.5 - N.y * 0.5;  
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);  
482  
483  
484   #if CC_USE_IBL  
485     #if CC_USE_DIFFUSEMAP  
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);  
487       #if CC_USE_DIFFUSEMAP == 2  
488         ambDiff = unpackRGBE(diffuseMap);  
489       #else  
490         ambDiff = SRGBToLinear(diffuseMap.rgb);  
491       #endif  
492     #endif  
493  
494     vec3 R = normalize(reflect(-V, N));  
495  
496     #if USE_REFLECTION_DENOISE  
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);  
498     #else  
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);  
500  
501       #if CC_USE_IBL == 2  
502         vec3 env = unpackRGBE(envmap);  
503       #else  
504         vec3 env = SRGBToLinear(envmap.rgb);  
505       #endif  
506     #endif  
507  
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;  
509   #endif  
510  
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;  
512  
513  
514   finalColor += s.emissive;  
515  
516   return vec4(finalColor, s.albedo.a);  
517 }  
518  
519  
520  
521 vec3 ACESToneMap (vec3 color) {  
522   color = min(color, vec3(8.0));  
523   const float A = 2.51;  
524   const float B = 0.03;  
525   const float C = 2.43;  
526   const float D = 0.59;  
527   const float E = 0.14;  
528   return (color * (A * color + B)) / (color * (C * color + D) + E);  
529 }  
530  
531  
532  
533 vec4 CCFragOutput (vec4 color) {  
534   #if CC_USE_HDR  
535     color.rgb = ACESToneMap(color.rgb);  
536   #endif  
537   color.rgb = sqrt(color.rgb);  
538   return color;  
539 }  
540  
541  
542  
543      uniform vec4 rimColor;  
544      uniform vec4 albedo;  
545      uniform vec4 albedoScaleAndCutoff;  
546      uniform vec4 pbrParams;  
547      uniform vec4 emissive;  
548      uniform vec4 emissiveScaleParam;  
549  
550  
551  
552  
553 varying highp vec4 v_shadowPos;  
554  
555  
556  
557 #if CC_RECEIVE_SHADOW  
558  
559  
560  
561 #endif  
562  
563  
564 varying vec3 v_position;  
565 varying vec3 v_view_position;  
566 varying vec2 v_uv;  
567 varying vec2 v_uv1;  
568 varying vec3 v_normal;  
569 varying vec3 v_view_normal;  
570 varying vec4 v_shadowPos;  
571  
572 #if USE_VERTEX_COLOR  
573   varying vec3 v_color;  
574 #endif  
575  
576 #if USE_ALBEDO_MAP  
577   uniform sampler2D albedoMap;  
578 #endif  
579 #if USE_NORMAL_MAP  
580   varying vec3 v_tangent;  
581   varying vec3 v_bitangent;  
582   uniform sampler2D normalMap;  
583 #endif  
584 #if USE_PBR_MAP  
585   uniform sampler2D pbrMap;  
586 #endif  
587 #if USE_METALLIC_ROUGHNESS_MAP  
588   uniform sampler2D metallicRoughnessMap;  
589 #endif  
590 #if USE_OCCLUSION_MAP  
591   uniform sampler2D occlusionMap;  
592 #endif  
593 #if USE_EMISSIVE_MAP  
594   uniform sampler2D emissiveMap;  
595 #endif  
596 #if CC_USE_LIGHTMAP  
597   varying vec2 v_luv;  
598   uniform sampler2D cc_lightingMap;  
599 #endif  
600 #if USE_ALPHA_TEST  
601 #endif  
602  
603 void surf (out StandardSurface s) {  
604   vec4 baseColor = albedo;  
605   #if USE_VERTEX_COLOR  
606     baseColor.rgb *= v_color;  
607   #endif  
608   #if USE_ALBEDO_MAP  
609     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);  
610     texColor.rgb = SRGBToLinear(texColor.rgb);  
611     baseColor *= texColor;  
612   #endif  
613   s.albedo = baseColor;  
614   s.albedo.rgb *= albedoScaleAndCutoff.xyz;  
615  
616   #if USE_ALPHA_TEST  
617     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;  
618   #endif  
619   float density = 0.001;  
620   float dist2 = dot(v_view_position,v_view_position);  
621   float fogFactor = exp( -density*density * dist2);  
622   fogFactor = clamp(fogFactor, 0.0, 1.0);  
623  
624   vec3 fogColor = vec3(1.0,1,1.0);  
625   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);  
626  
627   s.normal = v_normal;  
628   #if USE_NORMAL_MAP  
629     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);  
630     s.normal =  
631       (nmmp.x * pbrParams.w) * normalize(v_tangent) +  
632       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +  
633       nmmp.z * normalize(s.normal);  
634   #endif  
635  
636   s.position = v_position;  
637  
638   vec4 pbr = pbrParams;  
639   #if USE_PBR_MAP  
640     vec4 res = texture2D(pbrMap, PBR_UV);  
641     pbr.x *= res.OCCLUSION_CHANNEL;  
642     pbr.y *= res.ROUGHNESS_CHANNEL;  
643     pbr.z *= res.METALLIC_CHANNEL;  
644   #endif  
645   #if USE_METALLIC_ROUGHNESS_MAP  
646     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);  
647     pbr.z *= metallicRoughness.METALLIC_CHANNEL;  
648     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;  
649   #endif  
650   #if USE_OCCLUSION_MAP  
651     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;  
652   #endif  
653   s.occlusion = clamp(pbr.x, 0.0, 0.96);  
654   s.roughness = clamp(pbr.y, 0.04, 1.0);  
655   s.specularIntensity = 0.5;  
656   s.metallic = pbr.z;  
657  
658   s.emissive = emissive.rgb * emissiveScaleParam.xyz;  
659   #if USE_EMISSIVE_MAP  
660     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);  
661   #endif  
662 }  
663  
664 vec4 frag () {  
665   StandardSurface s; surf(s);  
666   vec4 color = CCStandardShadingBase(s, v_shadowPos);  
667  
668   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING  
669     vec4 lighting = texture2D(cc_lightingMap, v_luv);  
670  
671     float fAmb = 0.5 - s.normal.y * 0.5;  
672     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;  
673  
674     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);  
675     finalColor += lighting.rgb *  s.albedo.rgb;  
676     finalColor = finalColor * s.occlusion;  
677     finalColor += s.emissive;  
678  
679     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;  
680   #endif  
681  
682   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;  
683  
684   color.rgb = mix(color.rgb,rimColor.rgb,fRim);  
685  
686   return CCFragOutput(color);  
687 }  
688  
689  
690 void main() { gl_FragColor = frag(); }  
691  
at Object.encode (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-worker/node_modules/v-stacks/index.js:14:17)  
at Logger._logHandler (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-worker/static/script.ccc:1:531)  
at Logger.record (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:458)  
at console.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:1414)  
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)  
at async ParallelQueue._generate (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/asset-db.ccc:1:2165)
2022-06-23T02:25:40.201Z - error: [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos   
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at runMicrotasks (<anonymous>)  
at runNextTicks (internal/process/task_queues.js:58:5)  
at processImmediate (internal/timers.js:434:9)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)
2022-06-23T02:27:45.875Z - error: [Asset DB] ../res/rim_light.effect - standard-fs:frag: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:665: 'CC_SHANDOW_POSITION' : undeclared identifier
ERROR: 0:665: 'CCStandardShadingBase' : no matching overloaded function found
ERROR: 0:665: '=' : dimension mismatch
ERROR: 0:665: '=' : cannot convert from 'const mediump float' to 'highp 4-component vector of float'
 

1 #version 100
2 #define USE_INSTANCING 1
3 #define USE_BATCHING 1
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
13 #define CC_USE_SKINNING 1
14 #define CC_USE_BAKED_ANIMATION 1
15 #define CC_USE_LIGHTMAP 1
16 #define CC_RECEIVE_SHADOW 1
17 #define CC_USE_MORPH 1
18 #define CC_MORPH_TARGET_COUNT 2
19 #define CC_MORPH_PRECOMPUTED 1
20 #define CC_MORPH_TARGET_HAS_POSITION 1
21 #define CC_MORPH_TARGET_HAS_NORMAL 1
22 #define CC_MORPH_TARGET_HAS_TANGENT 1
23 #define USE_VERTEX_COLOR 1
24 #define USE_NORMAL_MAP 1
25 #define HAS_SECOND_UV 1
26 #define CC_USE_IBL 0
27 #define CC_USE_DIFFUSEMAP 0
28 #define USE_REFLECTION_DENOISE 1
29 #define CC_FORWARD_ADD 1
30 #define CC_USE_HDR 1
31 #define USE_ALBEDO_MAP 1
32 #define ALBEDO_UV v_uv
33 #define NORMAL_UV v_uv
34 #define USE_PBR_MAP 1
35 #define PBR_UV v_uv
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define METALLIC_ROUGHNESS_UV v_uv
38 #define USE_OCCLUSION_MAP 1
39 #define OCCLUSION_UV v_uv
40 #define USE_EMISSIVE_MAP 1
41 #define EMISSIVE_UV v_uv
42 #define OCCLUSION_CHANNEL r
43 #define ROUGHNESS_CHANNEL g
44 #define METALLIC_CHANNEL b
45 #define USE_ALPHA_TEST 1
46 #define ALPHA_TEST_CHANNEL a
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp vec4 cc_cameraPos;
58   uniform mediump vec4 cc_mainLitDir;
59   uniform mediump vec4 cc_mainLitColor;
60   uniform mediump vec4 cc_ambientSky;
61   uniform mediump vec4 cc_ambientGround;
62 
63 
64 
65 
66 
67 
68 #define QUATER_PI         0.78539816340
69 #define HALF_PI           1.57079632679
70 #define PI                3.14159265359
71 #define PI2               6.28318530718
72 #define PI4               12.5663706144
73      
74 #define INV_QUATER_PI     1.27323954474
75 #define INV_HALF_PI       0.63661977237
76 #define INV_PI            0.31830988618
77 #define INV_PI2           0.15915494309
78 #define INV_PI4           0.07957747155
79      
80 #define EPSILON           1e-6
81 #define EPSILON_LOWP      1e-4
82 #define LOG2              1.442695
83 #define EXP_VALUE         2.71828183f
84 #define FP_MAX            65504.0
85 #define FP_SCALE          0.0009765625
86 #define FP_SCALE_INV      1024.0
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
88 
89 
90 
91 
92 
93 
94 
95 vec3 SRGBToLinear (vec3 gamma) {
96   return gamma * gamma;
97 }
98 uniform highp mat4 cc_matLightView;
99   uniform highp vec4 cc_shadowProjDepthInfo;
100   uniform highp vec4 cc_shadowProjInfo;
101   uniform mediump vec4 cc_shadowNFLSInfo;
102   uniform mediump vec4 cc_shadowWHPBInfo;
103   uniform mediump vec4 cc_shadowLPNNInfo;
104 
105 
106 
107 
108 
109 
110 
111 
112 highp float unpackHighpData (float mainPart, float modPart) {
113   highp float data = mainPart;
114   return data + modPart;
115 }
116 
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
118   highp float data = mainPart * modValue;
119   return data + modPart * modValue;
120 }
121 
122 
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
124   highp vec2 data = mainPart;
125   return data + modPart;
126 }
127 
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
129   highp vec2 data = mainPart * modValue;
130   return data + modPart * modValue;
131 }
132 
133 
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
135   highp vec3 data = mainPart;
136   return data + modPart;
137 }
138 
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
140   highp vec3 data = mainPart * modValue;
141   return data + modPart * modValue;
142 }
143 
144 
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
146   highp vec4 data = mainPart;
147   return data + modPart;
148 }
149 
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
151   highp vec4 data = mainPart * modValue;
152   return data + modPart * modValue;
153 }
154 #if CC_RECEIVE_SHADOW
155   uniform highp sampler2D cc_shadowMap;
156   uniform highp sampler2D cc_spotLightingMap;
157 
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
159   {
160     vec4 newShadowPos = shadowPos;
161     if(normalBias > EPSILON_LOWP)
162     {
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
164       if(viewNormal.z < 0.1)
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
166     }
167     return newShadowPos;
168   }
169   
170   
171 
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
173   {
174     float coeffA = cc_shadowProjDepthInfo.x;
175     float coeffB = cc_shadowProjDepthInfo.y;
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
177     viewSpacePos_z += viewspaceDepthBias;
178     vec4 result = shadowPos;
179     result.z = viewSpacePos_z * coeffA + coeffB;
180     return result;
181   }
182   
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
190 
191     float shadow = 0.0;
192     float closestDepth = 0.0;
193     if (cc_shadowLPNNInfo.y > EPSILON) {
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
195     } else {
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
197     }
198     shadow = step(clipPos.z, closestDepth);
199 
200     return shadow;
201   }
202 
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
210 
211     float offsetDepth = clipPos.z;
212     vec2 mapSize = cc_shadowWHPBInfo.xy;
213     vec2 oneTap = 1.0 / mapSize;
214     vec2 clipPos_offset = clipPos.xy + oneTap;
215 
216     float block0, block1, block2, block3;
217     if (cc_shadowLPNNInfo.y > EPSILON) {
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
222     } else {
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
227     }
228 
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
230     float resultX = mix(block0, block1, coefX);
231     float resultY = mix(block2, block3, coefX);
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
233 
234     return mix(resultX, resultY, coefY);
235   }
236 
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
244 
245     float offsetDepth = clipPos.z;
246     vec2 mapSize = cc_shadowWHPBInfo.xy;
247     vec2 oneTap = 1.0 / mapSize;
248     float clipPos_offset_L = clipPos.x - oneTap.x;
249     float clipPos_offset_R = clipPos.x + oneTap.x;
250     float clipPos_offset_U = clipPos.y - oneTap.y;
251     float clipPos_offset_D = clipPos.y + oneTap.y;
252 
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
254     if (cc_shadowLPNNInfo.y > EPSILON) {
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
264     } else {
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
274     }
275 
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
278 
279     float shadow = 0.0;
280     float resultX = mix(block0, block1, coefX);
281     float resultY = mix(block3, block4, coefX);
282     shadow += mix(resultX , resultY, coefY);
283 
284     resultX = mix(block1, block2, coefX);
285     resultY = mix(block4, block5, coefX);
286     shadow += mix(resultX , resultY, coefY);
287 
288     resultX = mix(block3, block4, coefX);
289     resultY = mix(block6, block7, coefX);
290     shadow += mix(resultX, resultY, coefY);
291 
292     resultX = mix(block4, block5, coefX);
293     resultY = mix(block7, block8, coefX);
294     shadow += mix(resultX, resultY, coefY);
295 
296     return shadow * 0.25;
297   }
298 
299   
300 
301   
302 
303   
304 
305 
306 
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
308 {
309   float realtimeShadow = 1.0;
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
311   
312   float pcf = cc_shadowWHPBInfo.z;
313   if (pcf > 1.9) { 
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
315   }else if (pcf > 0.9) {
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
317   }else { 
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
319   }
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
321 }
322 #endif
323 
324 
325 
326 #if CC_USE_IBL
327   uniform samplerCube cc_environment;
328   
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
330     
331       #ifdef GL_EXT_shader_texture_lod
332         return texture2DLodEXT(tex, coord, lod);
333       #else
334         return texture2D(tex, coord, lod);
335       #endif
336     
337   }
338   
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
340     
341       #ifdef GL_EXT_shader_texture_lod
342         return textureCubeLodEXT(tex, coord, lod);
343       #else
344         return textureCube(tex, coord, lod);
345       #endif
346     
347   }
348   
349   
350   
351   
352   
353   
354   
355   vec3 unpackRGBE (vec4 rgbe) {
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
357   }
358   
359 
360   #if CC_USE_DIFFUSEMAP
361     uniform samplerCube cc_diffuseMap;
362   #endif
363 #endif
364 
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
366   vec3 NxH = cross(N, H);
367   float OneMinusNoHSqr = dot(NxH, NxH);
368   float a = roughness * roughness;
369   float n = NoH * a;
370   float p = a / (OneMinusNoHSqr + n * n);
371   return p * p;
372 }
373 
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
376 }
377 
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
381   vec4 r = roughness * c0 + c1;
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
385   return specular * AB.x + AB.y;
386 }
387 
388 #if USE_REFLECTION_DENOISE
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
390     #if CC_USE_IBL
391     	float mip = roughness * mipCount;
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
394 
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
396      	vec4 filtered = textureCube(cc_environment, R);
397 
398       #if CC_USE_IBL == 2
399       	biased.rgb = unpackRGBE(biased);
400       	filtered.rgb = unpackRGBE(filtered);
401       #else
402       	biased.rgb = SRGBToLinear(biased.rgb);
403       	filtered.rgb = SRGBToLinear(filtered.rgb);
404       #endif
405       	
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
407     #else
408       return vec3(0.0, 0.0, 0.0);
409     #endif
410   }
411 #endif
412 
413 
414 struct StandardSurface {
415   vec4 albedo;
416   
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
418   vec3 position, position_fract_part;
419   #else
420   vec3 position;
421   #endif
422   vec3 normal;
423   vec3 emissive;
424   vec3 lightmap;
425   float lightmap_test;
426   float roughness;
427   float metallic;
428   float occlusion;
429   float specularIntensity;
430 
431   #if CC_RECEIVE_SHADOW
432     vec2 shadowBias;
433   #endif
434 };
435 
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
440 
441   vec3 position;
442   
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
444   position = unpackHighpData(s.position, s.position_fract_part);
445   #else
446   position = s.position;
447   #endif
448 
449   vec3 N = normalize(s.normal);
450   vec3 V = normalize(cc_cameraPos.xyz - position);
451 
452   float NV = max(abs(dot(N, V)), 0.0);
453   specular = BRDFApprox(specular, s.roughness, NV);
454 
455   vec3 L = normalize(-cc_mainLitDir.xyz);
456   vec3 H = normalize(L + V);
457   float NH = max(dot(N, H), 0.0);
458   float NL = max(dot(N, L), 0.0);
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
460   vec3 diffuseContrib = diffuse / PI;
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);
463 
464   float shadow = 1.0;
465   #if CC_RECEIVE_SHADOW
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
468     }
469   #endif
470 
471   dirlightContrib *= shadow;
472   finalColor *= dirlightContrib;
473 
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
475     if (s.lightmap_test > EPSILON_LOWP) {
476       finalColor = diffuse * s.lightmap.rgb * shadow;
477     }
478   #endif
479 
480   float fAmb = 0.5 - N.y * 0.5;
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
482 
483 
484   #if CC_USE_IBL
485     #if CC_USE_DIFFUSEMAP
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
487       #if CC_USE_DIFFUSEMAP == 2
488         ambDiff = unpackRGBE(diffuseMap);
489       #else
490         ambDiff = SRGBToLinear(diffuseMap.rgb);
491       #endif
492     #endif
493 
494     vec3 R = normalize(reflect(-V, N));
495 
496     #if USE_REFLECTION_DENOISE
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
498     #else
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
500 
501       #if CC_USE_IBL == 2
502         vec3 env = unpackRGBE(envmap);
503       #else
504         vec3 env = SRGBToLinear(envmap.rgb);
505       #endif
506     #endif
507 
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
509   #endif
510 
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
512   
513 
514   finalColor += s.emissive;
515 
516   return vec4(finalColor, s.albedo.a);
517 }
518 
519 
520 
521 vec3 ACESToneMap (vec3 color) {
522   color = min(color, vec3(8.0));
523   const float A = 2.51;
524   const float B = 0.03;
525   const float C = 2.43;
526   const float D = 0.59;
527   const float E = 0.14;
528   return (color * (A * color + B)) / (color * (C * color + D) + E);
529 }
530 
531 
532 
533 vec4 CCFragOutput (vec4 color) {
534   #if CC_USE_HDR
535     color.rgb = ACESToneMap(color.rgb);
536   #endif
537   color.rgb = sqrt(color.rgb);
538   return color;
539 }
540 
541 
542 
543      uniform vec4 rimColor;
544      uniform vec4 albedo;
545      uniform vec4 albedoScaleAndCutoff;
546      uniform vec4 pbrParams;
547      uniform vec4 emissive;
548      uniform vec4 emissiveScaleParam;
549 
550 
551 
552 
553 varying highp vec4 v_shadowPos;
554 
555 
556 
557 #if CC_RECEIVE_SHADOW
558 
559 
560 
561 #endif
562 
563 
564 varying vec3 v_position;
565 varying vec3 v_view_position;
566 varying vec2 v_uv;
567 varying vec2 v_uv1;
568 varying vec3 v_normal;
569 varying vec3 v_view_normal;
570 
571 #if USE_VERTEX_COLOR
572   varying vec3 v_color;
573 #endif
574 
575 #if USE_ALBEDO_MAP
576   uniform sampler2D albedoMap;
577 #endif
578 #if USE_NORMAL_MAP
579   varying vec3 v_tangent;
580   varying vec3 v_bitangent;
581   uniform sampler2D normalMap;
582 #endif
583 #if USE_PBR_MAP
584   uniform sampler2D pbrMap;
585 #endif
586 #if USE_METALLIC_ROUGHNESS_MAP
587   uniform sampler2D metallicRoughnessMap;
588 #endif
589 #if USE_OCCLUSION_MAP
590   uniform sampler2D occlusionMap;
591 #endif
592 #if USE_EMISSIVE_MAP
593   uniform sampler2D emissiveMap;
594 #endif
595 #if CC_USE_LIGHTMAP
596   varying vec2 v_luv;
597   uniform sampler2D cc_lightingMap;
598 #endif
599 #if USE_ALPHA_TEST
600 #endif
601 
602 void surf (out StandardSurface s) {
603   vec4 baseColor = albedo;
604   #if USE_VERTEX_COLOR
605     baseColor.rgb *= v_color;
606   #endif
607   #if USE_ALBEDO_MAP
608     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);
609     texColor.rgb = SRGBToLinear(texColor.rgb);
610     baseColor *= texColor;
611   #endif
612   s.albedo = baseColor;
613   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
614 
615   #if USE_ALPHA_TEST
616     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
617   #endif
618   float density = 0.001;
619   float dist2 = dot(v_view_position,v_view_position);
620   float fogFactor = exp( -density*density * dist2);
621   fogFactor = clamp(fogFactor, 0.0, 1.0);
622 
623   vec3 fogColor = vec3(1.0,1,1.0);
624   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);
625 
626   s.normal = v_normal;
627   #if USE_NORMAL_MAP
628     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);
629     s.normal =
630       (nmmp.x * pbrParams.w) * normalize(v_tangent) +
631       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +
632       nmmp.z * normalize(s.normal);
633   #endif
634 
635   s.position = v_position;
636 
637   vec4 pbr = pbrParams;
638   #if USE_PBR_MAP
639     vec4 res = texture2D(pbrMap, PBR_UV);
640     pbr.x *= res.OCCLUSION_CHANNEL;
641     pbr.y *= res.ROUGHNESS_CHANNEL;
642     pbr.z *= res.METALLIC_CHANNEL;
643   #endif
644   #if USE_METALLIC_ROUGHNESS_MAP
645     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);
646     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
647     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
648   #endif
649   #if USE_OCCLUSION_MAP
650     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;
651   #endif
652   s.occlusion = clamp(pbr.x, 0.0, 0.96);
653   s.roughness = clamp(pbr.y, 0.04, 1.0);
654   s.specularIntensity = 0.5;
655   s.metallic = pbr.z;
656 
657   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
658   #if USE_EMISSIVE_MAP
659     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);
660   #endif
661 }
662 
663 vec4 frag () {
664   StandardSurface s; surf(s);
665   vec4 color = CCStandardShadingBase(s, CC_SHANDOW_POSITION);
666 
667   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING
668     vec4 lighting = texture2D(cc_lightingMap, v_luv);
669 
670     float fAmb = 0.5 - s.normal.y * 0.5;
671     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
672 
673     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);
674     finalColor += lighting.rgb *  s.albedo.rgb;
675     finalColor = finalColor * s.occlusion;
676     finalColor += s.emissive;
677 
678     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;
679   #endif
680 
681   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;
682 
683   color.rgb = mix(color.rgb,rimColor.rgb,fRim);
684 
685   return CCFragOutput(color);
686 }
687 
688 
689 void main() { gl_FragColor = frag(); }
690 [Asset DB] ../res/rim_light.effect - standard-fs:frag: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:665: 'CC_SHANDOW_POSITION' : undeclared identifier
ERROR: 0:665: 'CCStandardShadingBase' : no matching overloaded function found
ERROR: 0:665: '=' : dimension mismatch
ERROR: 0:665: '=' : cannot convert from 'const mediump float' to 'highp 4-component vector of float'
 

1 #version 100
2 #define USE_INSTANCING 1
3 #define USE_BATCHING 1
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
13 #define CC_USE_SKINNING 1
14 #define CC_USE_BAKED_ANIMATION 1
15 #define CC_USE_LIGHTMAP 1
16 #define CC_RECEIVE_SHADOW 1
17 #define CC_USE_MORPH 1
18 #define CC_MORPH_TARGET_COUNT 2
19 #define CC_MORPH_PRECOMPUTED 1
20 #define CC_MORPH_TARGET_HAS_POSITION 1
21 #define CC_MORPH_TARGET_HAS_NORMAL 1
22 #define CC_MORPH_TARGET_HAS_TANGENT 1
23 #define USE_VERTEX_COLOR 1
24 #define USE_NORMAL_MAP 1
25 #define HAS_SECOND_UV 1
26 #define CC_USE_IBL 0
27 #define CC_USE_DIFFUSEMAP 0
28 #define USE_REFLECTION_DENOISE 1
29 #define CC_FORWARD_ADD 1
30 #define CC_USE_HDR 1
31 #define USE_ALBEDO_MAP 1
32 #define ALBEDO_UV v_uv
33 #define NORMAL_UV v_uv
34 #define USE_PBR_MAP 1
35 #define PBR_UV v_uv
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define METALLIC_ROUGHNESS_UV v_uv
38 #define USE_OCCLUSION_MAP 1
39 #define OCCLUSION_UV v_uv
40 #define USE_EMISSIVE_MAP 1
41 #define EMISSIVE_UV v_uv
42 #define OCCLUSION_CHANNEL r
43 #define ROUGHNESS_CHANNEL g
44 #define METALLIC_CHANNEL b
45 #define USE_ALPHA_TEST 1
46 #define ALPHA_TEST_CHANNEL a
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp vec4 cc_cameraPos;
58   uniform mediump vec4 cc_mainLitDir;
59   uniform mediump vec4 cc_mainLitColor;
60   uniform mediump vec4 cc_ambientSky;
61   uniform mediump vec4 cc_ambientGround;
62 
63 
64 
65 
66 
67 
68 #define QUATER_PI         0.78539816340
69 #define HALF_PI           1.57079632679
70 #define PI                3.14159265359
71 #define PI2               6.28318530718
72 #define PI4               12.5663706144
73      
74 #define INV_QUATER_PI     1.27323954474
75 #define INV_HALF_PI       0.63661977237
76 #define INV_PI            0.31830988618
77 #define INV_PI2           0.15915494309
78 #define INV_PI4           0.07957747155
79      
80 #define EPSILON           1e-6
81 #define EPSILON_LOWP      1e-4
82 #define LOG2              1.442695
83 #define EXP_VALUE         2.71828183f
84 #define FP_MAX            65504.0
85 #define FP_SCALE          0.0009765625
86 #define FP_SCALE_INV      1024.0
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
88 
89 
90 
91 
92 
93 
94 
95 vec3 SRGBToLinear (vec3 gamma) {
96   return gamma * gamma;
97 }
98 uniform highp mat4 cc_matLightView;
99   uniform highp vec4 cc_shadowProjDepthInfo;
100   uniform highp vec4 cc_shadowProjInfo;
101   uniform mediump vec4 cc_shadowNFLSInfo;
102   uniform mediump vec4 cc_shadowWHPBInfo;
103   uniform mediump vec4 cc_shadowLPNNInfo;
104 
105 
106 
107 
108 
109 
110 
111 
112 highp float unpackHighpData (float mainPart, float modPart) {
113   highp float data = mainPart;
114   return data + modPart;
115 }
116 
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
118   highp float data = mainPart * modValue;
119   return data + modPart * modValue;
120 }
121 
122 
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
124   highp vec2 data = mainPart;
125   return data + modPart;
126 }
127 
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
129   highp vec2 data = mainPart * modValue;
130   return data + modPart * modValue;
131 }
132 
133 
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
135   highp vec3 data = mainPart;
136   return data + modPart;
137 }
138 
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
140   highp vec3 data = mainPart * modValue;
141   return data + modPart * modValue;
142 }
143 
144 
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
146   highp vec4 data = mainPart;
147   return data + modPart;
148 }
149 
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
151   highp vec4 data = mainPart * modValue;
152   return data + modPart * modValue;
153 }
154 #if CC_RECEIVE_SHADOW
155   uniform highp sampler2D cc_shadowMap;
156   uniform highp sampler2D cc_spotLightingMap;
157 
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
159   {
160     vec4 newShadowPos = shadowPos;
161     if(normalBias > EPSILON_LOWP)
162     {
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
164       if(viewNormal.z < 0.1)
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
166     }
167     return newShadowPos;
168   }
169   
170   
171 
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
173   {
174     float coeffA = cc_shadowProjDepthInfo.x;
175     float coeffB = cc_shadowProjDepthInfo.y;
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
177     viewSpacePos_z += viewspaceDepthBias;
178     vec4 result = shadowPos;
179     result.z = viewSpacePos_z * coeffA + coeffB;
180     return result;
181   }
182   
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
190 
191     float shadow = 0.0;
192     float closestDepth = 0.0;
193     if (cc_shadowLPNNInfo.y > EPSILON) {
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
195     } else {
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
197     }
198     shadow = step(clipPos.z, closestDepth);
199 
200     return shadow;
201   }
202 
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
210 
211     float offsetDepth = clipPos.z;
212     vec2 mapSize = cc_shadowWHPBInfo.xy;
213     vec2 oneTap = 1.0 / mapSize;
214     vec2 clipPos_offset = clipPos.xy + oneTap;
215 
216     float block0, block1, block2, block3;
217     if (cc_shadowLPNNInfo.y > EPSILON) {
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
222     } else {
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
227     }
228 
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
230     float resultX = mix(block0, block1, coefX);
231     float resultY = mix(block2, block3, coefX);
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
233 
234     return mix(resultX, resultY, coefY);
235   }
236 
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
244 
245     float offsetDepth = clipPos.z;
246     vec2 mapSize = cc_shadowWHPBInfo.xy;
247     vec2 oneTap = 1.0 / mapSize;
248     float clipPos_offset_L = clipPos.x - oneTap.x;
249     float clipPos_offset_R = clipPos.x + oneTap.x;
250     float clipPos_offset_U = clipPos.y - oneTap.y;
251     float clipPos_offset_D = clipPos.y + oneTap.y;
252 
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
254     if (cc_shadowLPNNInfo.y > EPSILON) {
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
264     } else {
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
274     }
275 
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
278 
279     float shadow = 0.0;
280     float resultX = mix(block0, block1, coefX);
281     float resultY = mix(block3, block4, coefX);
282     shadow += mix(resultX , resultY, coefY);
283 
284     resultX = mix(block1, block2, coefX);
285     resultY = mix(block4, block5, coefX);
286     shadow += mix(resultX , resultY, coefY);
287 
288     resultX = mix(block3, block4, coefX);
289     resultY = mix(block6, block7, coefX);
290     shadow += mix(resultX, resultY, coefY);
291 
292     resultX = mix(block4, block5, coefX);
293     resultY = mix(block7, block8, coefX);
294     shadow += mix(resultX, resultY, coefY);
295 
296     return shadow * 0.25;
297   }
298 
299   
300 
301   
302 
303   
304 
305 
306 
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
308 {
309   float realtimeShadow = 1.0;
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
311   
312   float pcf = cc_shadowWHPBInfo.z;
313   if (pcf > 1.9) { 
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
315   }else if (pcf > 0.9) {
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
317   }else { 
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
319   }
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
321 }
322 #endif
323 
324 
325 
326 #if CC_USE_IBL
327   uniform samplerCube cc_environment;
328   
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
330     
331       #ifdef GL_EXT_shader_texture_lod
332         return texture2DLodEXT(tex, coord, lod);
333       #else
334         return texture2D(tex, coord, lod);
335       #endif
336     
337   }
338   
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
340     
341       #ifdef GL_EXT_shader_texture_lod
342         return textureCubeLodEXT(tex, coord, lod);
343       #else
344         return textureCube(tex, coord, lod);
345       #endif
346     
347   }
348   
349   
350   
351   
352   
353   
354   
355   vec3 unpackRGBE (vec4 rgbe) {
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
357   }
358   
359 
360   #if CC_USE_DIFFUSEMAP
361     uniform samplerCube cc_diffuseMap;
362   #endif
363 #endif
364 
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
366   vec3 NxH = cross(N, H);
367   float OneMinusNoHSqr = dot(NxH, NxH);
368   float a = roughness * roughness;
369   float n = NoH * a;
370   float p = a / (OneMinusNoHSqr + n * n);
371   return p * p;
372 }
373 
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
376 }
377 
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
381   vec4 r = roughness * c0 + c1;
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
385   return specular * AB.x + AB.y;
386 }
387 
388 #if USE_REFLECTION_DENOISE
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
390     #if CC_USE_IBL
391     	float mip = roughness * mipCount;
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
394 
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
396      	vec4 filtered = textureCube(cc_environment, R);
397 
398       #if CC_USE_IBL == 2
399       	biased.rgb = unpackRGBE(biased);
400       	filtered.rgb = unpackRGBE(filtered);
401       #else
402       	biased.rgb = SRGBToLinear(biased.rgb);
403       	filtered.rgb = SRGBToLinear(filtered.rgb);
404       #endif
405       	
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
407     #else
408       return vec3(0.0, 0.0, 0.0);
409     #endif
410   }
411 #endif
412 
413 
414 struct StandardSurface {
415   vec4 albedo;
416   
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
418   vec3 position, position_fract_part;
419   #else
420   vec3 position;
421   #endif
422   vec3 normal;
423   vec3 emissive;
424   vec3 lightmap;
425   float lightmap_test;
426   float roughness;
427   float metallic;
428   float occlusion;
429   float specularIntensity;
430 
431   #if CC_RECEIVE_SHADOW
432     vec2 shadowBias;
433   #endif
434 };
435 
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
440 
441   vec3 position;
442   
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
444   position = unpackHighpData(s.position, s.position_fract_part);
445   #else
446   position = s.position;
447   #endif
448 
449   vec3 N = normalize(s.normal);
450   vec3 V = normalize(cc_cameraPos.xyz - position);
451 
452   float NV = max(abs(dot(N, V)), 0.0);
453   specular = BRDFApprox(specular, s.roughness, NV);
454 
455   vec3 L = normalize(-cc_mainLitDir.xyz);
456   vec3 H = normalize(L + V);
457   float NH = max(dot(N, H), 0.0);
458   float NL = max(dot(N, L), 0.0);
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
460   vec3 diffuseContrib = diffuse / PI;
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);
463 
464   float shadow = 1.0;
465   #if CC_RECEIVE_SHADOW
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
468     }
469   #endif
470 
471   dirlightContrib *= shadow;
472   finalColor *= dirlightContrib;
473 
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
475     if (s.lightmap_test > EPSILON_LOWP) {
476       finalColor = diffuse * s.lightmap.rgb * shadow;
477     }
478   #endif
479 
480   float fAmb = 0.5 - N.y * 0.5;
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
482 
483 
484   #if CC_USE_IBL
485     #if CC_USE_DIFFUSEMAP
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
487       #if CC_USE_DIFFUSEMAP == 2
488         ambDiff = unpackRGBE(diffuseMap);
489       #else
490         ambDiff = SRGBToLinear(diffuseMap.rgb);
491       #endif
492     #endif
493 
494     vec3 R = normalize(reflect(-V, N));
495 
496     #if USE_REFLECTION_DENOISE
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
498     #else
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
500 
501       #if CC_USE_IBL == 2
502         vec3 env = unpackRGBE(envmap);
503       #else
504         vec3 env = SRGBToLinear(envmap.rgb);
505       #endif
506     #endif
507 
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
509   #endif
510 
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
512   
513 
514   finalColor += s.emissive;
515 
516   return vec4(finalColor, s.albedo.a);
517 }
518 
519 
520 
521 vec3 ACESToneMap (vec3 color) {
522   color = min(color, vec3(8.0));
523   const float A = 2.51;
524   const float B = 0.03;
525   const float C = 2.43;
526   const float D = 0.59;
527   const float E = 0.14;
528   return (color * (A * color + B)) / (color * (C * color + D) + E);
529 }
530 
531 
532 
533 vec4 CCFragOutput (vec4 color) {
534   #if CC_USE_HDR
535     color.rgb = ACESToneMap(color.rgb);
536   #endif
537   color.rgb = sqrt(color.rgb);
538   return color;
539 }
540 
541 
542 
543      uniform vec4 rimColor;
544      uniform vec4 albedo;
545      uniform vec4 albedoScaleAndCutoff;
546      uniform vec4 pbrParams;
547      uniform vec4 emissive;
548      uniform vec4 emissiveScaleParam;
549 
550 
551 
552 
553 varying highp vec4 v_shadowPos;
554 
555 
556 
557 #if CC_RECEIVE_SHADOW
558 
559 
560 
561 #endif
562 
563 
564 varying vec3 v_position;
565 varying vec3 v_view_position;
566 varying vec2 v_uv;
567 varying vec2 v_uv1;
568 varying vec3 v_normal;
569 varying vec3 v_view_normal;
570 
571 #if USE_VERTEX_COLOR
572   varying vec3 v_color;
573 #endif
574 
575 #if USE_ALBEDO_MAP
576   uniform sampler2D albedoMap;
577 #endif
578 #if USE_NORMAL_MAP
579   varying vec3 v_tangent;
580   varying vec3 v_bitangent;
581   uniform sampler2D normalMap;
582 #endif
583 #if USE_PBR_MAP
584   uniform sampler2D pbrMap;
585 #endif
586 #if USE_METALLIC_ROUGHNESS_MAP
587   uniform sampler2D metallicRoughnessMap;
588 #endif
589 #if USE_OCCLUSION_MAP
590   uniform sampler2D occlusionMap;
591 #endif
592 #if USE_EMISSIVE_MAP
593   uniform sampler2D emissiveMap;
594 #endif
595 #if CC_USE_LIGHTMAP
596   varying vec2 v_luv;
597   uniform sampler2D cc_lightingMap;
598 #endif
599 #if USE_ALPHA_TEST
600 #endif
601 
602 void surf (out StandardSurface s) {
603   vec4 baseColor = albedo;
604   #if USE_VERTEX_COLOR
605     baseColor.rgb *= v_color;
606   #endif
607   #if USE_ALBEDO_MAP
608     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);
609     texColor.rgb = SRGBToLinear(texColor.rgb);
610     baseColor *= texColor;
611   #endif
612   s.albedo = baseColor;
613   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
614 
615   #if USE_ALPHA_TEST
616     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
617   #endif
618   float density = 0.001;
619   float dist2 = dot(v_view_position,v_view_position);
620   float fogFactor = exp( -density*density * dist2);
621   fogFactor = clamp(fogFactor, 0.0, 1.0);
622 
623   vec3 fogColor = vec3(1.0,1,1.0);
624   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);
625 
626   s.normal = v_normal;
627   #if USE_NORMAL_MAP
628     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);
629     s.normal =
630       (nmmp.x * pbrParams.w) * normalize(v_tangent) +
631       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +
632       nmmp.z * normalize(s.normal);
633   #endif
634 
635   s.position = v_position;
636 
637   vec4 pbr = pbrParams;
638   #if USE_PBR_MAP
639     vec4 res = texture2D(pbrMap, PBR_UV);
640     pbr.x *= res.OCCLUSION_CHANNEL;
641     pbr.y *= res.ROUGHNESS_CHANNEL;
642     pbr.z *= res.METALLIC_CHANNEL;
643   #endif
644   #if USE_METALLIC_ROUGHNESS_MAP
645     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);
646     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
647     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
648   #endif
649   #if USE_OCCLUSION_MAP
650     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;
651   #endif
652   s.occlusion = clamp(pbr.x, 0.0, 0.96);
653   s.roughness = clamp(pbr.y, 0.04, 1.0);
654   s.specularIntensity = 0.5;
655   s.metallic = pbr.z;
656 
657   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
658   #if USE_EMISSIVE_MAP
659     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);
660   #endif
661 }
662 
663 vec4 frag () {
664   StandardSurface s; surf(s);
665   vec4 color = CCStandardShadingBase(s, CC_SHANDOW_POSITION);
666 
667   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING
668     vec4 lighting = texture2D(cc_lightingMap, v_luv);
669 
670     float fAmb = 0.5 - s.normal.y * 0.5;
671     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
672 
673     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);
674     finalColor += lighting.rgb *  s.albedo.rgb;
675     finalColor = finalColor * s.occlusion;
676     finalColor += s.emissive;
677 
678     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;
679   #endif
680 
681   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;
682 
683   color.rgb = mix(color.rgb,rimColor.rgb,fRim);
684 
685   return CCFragOutput(color);
686 }
687 
688 
689 void main() { gl_FragColor = frag(); }
690   
   
  
1 #version 100  
2 #define USE_INSTANCING 1  
3 #define USE_BATCHING 1  
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1  
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024  
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024  
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128  
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128  
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0  
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0  
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0  
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0  
13 #define CC_USE_SKINNING 1  
14 #define CC_USE_BAKED_ANIMATION 1  
15 #define CC_USE_LIGHTMAP 1  
16 #define CC_RECEIVE_SHADOW 1  
17 #define CC_USE_MORPH 1  
18 #define CC_MORPH_TARGET_COUNT 2  
19 #define CC_MORPH_PRECOMPUTED 1  
20 #define CC_MORPH_TARGET_HAS_POSITION 1  
21 #define CC_MORPH_TARGET_HAS_NORMAL 1  
22 #define CC_MORPH_TARGET_HAS_TANGENT 1  
23 #define USE_VERTEX_COLOR 1  
24 #define USE_NORMAL_MAP 1  
25 #define HAS_SECOND_UV 1  
26 #define CC_USE_IBL 0  
27 #define CC_USE_DIFFUSEMAP 0  
28 #define USE_REFLECTION_DENOISE 1  
29 #define CC_FORWARD_ADD 1  
30 #define CC_USE_HDR 1  
31 #define USE_ALBEDO_MAP 1  
32 #define ALBEDO_UV v_uv  
33 #define NORMAL_UV v_uv  
34 #define USE_PBR_MAP 1  
35 #define PBR_UV v_uv  
36 #define USE_METALLIC_ROUGHNESS_MAP 1  
37 #define METALLIC_ROUGHNESS_UV v_uv  
38 #define USE_OCCLUSION_MAP 1  
39 #define OCCLUSION_UV v_uv  
40 #define USE_EMISSIVE_MAP 1  
41 #define EMISSIVE_UV v_uv  
42 #define OCCLUSION_CHANNEL r  
43 #define ROUGHNESS_CHANNEL g  
44 #define METALLIC_CHANNEL b  
45 #define USE_ALPHA_TEST 1  
46 #define ALPHA_TEST_CHANNEL a  
47  
48 #ifdef GL_OES_standard_derivatives  
49 #extension GL_OES_standard_derivatives: enable  
50 #endif  
51  
52 #ifdef GL_EXT_shader_texture_lod  
53 #extension GL_EXT_shader_texture_lod: enable  
54 #endif  
55  
56 precision highp float;  
57 uniform highp vec4 cc_cameraPos;  
58   uniform mediump vec4 cc_mainLitDir;  
59   uniform mediump vec4 cc_mainLitColor;  
60   uniform mediump vec4 cc_ambientSky;  
61   uniform mediump vec4 cc_ambientGround;  
62  
63  
64  
65  
66  
67  
68 #define QUATER_PI         0.78539816340  
69 #define HALF_PI           1.57079632679  
70 #define PI                3.14159265359  
71 #define PI2               6.28318530718  
72 #define PI4               12.5663706144  
73  
74 #define INV_QUATER_PI     1.27323954474  
75 #define INV_HALF_PI       0.63661977237  
76 #define INV_PI            0.31830988618  
77 #define INV_PI2           0.15915494309  
78 #define INV_PI4           0.07957747155  
79  
80 #define EPSILON           1e-6  
81 #define EPSILON_LOWP      1e-4  
82 #define LOG2              1.442695  
83 #define EXP_VALUE         2.71828183f  
84 #define FP_MAX            65504.0  
85 #define FP_SCALE          0.0009765625  
86 #define FP_SCALE_INV      1024.0  
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)  
88  
89  
90  
91  
92  
93  
94  
95 vec3 SRGBToLinear (vec3 gamma) {  
96   return gamma * gamma;  
97 }  
98 uniform highp mat4 cc_matLightView;  
99   uniform highp vec4 cc_shadowProjDepthInfo;  
100   uniform highp vec4 cc_shadowProjInfo;  
101   uniform mediump vec4 cc_shadowNFLSInfo;  
102   uniform mediump vec4 cc_shadowWHPBInfo;  
103   uniform mediump vec4 cc_shadowLPNNInfo;  
104  
105  
106  
107  
108  
109  
110  
111  
112 highp float unpackHighpData (float mainPart, float modPart) {  
113   highp float data = mainPart;  
114   return data + modPart;  
115 }  
116  
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {  
118   highp float data = mainPart * modValue;  
119   return data + modPart * modValue;  
120 }  
121  
122  
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {  
124   highp vec2 data = mainPart;  
125   return data + modPart;  
126 }  
127  
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {  
129   highp vec2 data = mainPart * modValue;  
130   return data + modPart * modValue;  
131 }  
132  
133  
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {  
135   highp vec3 data = mainPart;  
136   return data + modPart;  
137 }  
138  
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {  
140   highp vec3 data = mainPart * modValue;  
141   return data + modPart * modValue;  
142 }  
143  
144  
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {  
146   highp vec4 data = mainPart;  
147   return data + modPart;  
148 }  
149  
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {  
151   highp vec4 data = mainPart * modValue;  
152   return data + modPart * modValue;  
153 }  
154 #if CC_RECEIVE_SHADOW  
155   uniform highp sampler2D cc_shadowMap;  
156   uniform highp sampler2D cc_spotLightingMap;  
157  
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)  
159   {  
160     vec4 newShadowPos = shadowPos;  
161     if(normalBias > EPSILON_LOWP)  
162     {  
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);  
164       if(viewNormal.z < 0.1)  
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);  
166     }  
167     return newShadowPos;  
168   }  
169  
170  
171  
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)  
173   {  
174     float coeffA = cc_shadowProjDepthInfo.x;  
175     float coeffB = cc_shadowProjDepthInfo.y;  
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;  
177     viewSpacePos_z += viewspaceDepthBias;  
178     vec4 result = shadowPos;  
179     result.z = viewSpacePos_z * coeffA + coeffB;  
180     return result;  
181   }  
182  
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {  
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
190  
191     float shadow = 0.0;  
192     float closestDepth = 0.0;  
193     if (cc_shadowLPNNInfo.y > EPSILON) {  
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));  
195     } else {  
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;  
197     }  
198     shadow = step(clipPos.z, closestDepth);  
199  
200     return shadow;  
201   }  
202  
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {  
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
210  
211     float offsetDepth = clipPos.z;  
212     vec2 mapSize = cc_shadowWHPBInfo.xy;  
213     vec2 oneTap = 1.0 / mapSize;  
214     vec2 clipPos_offset = clipPos.xy + oneTap;  
215  
216     float block0, block1, block2, block3;  
217     if (cc_shadowLPNNInfo.y > EPSILON) {  
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
222     } else {  
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);  
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);  
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);  
227     }  
228  
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;  
230     float resultX = mix(block0, block1, coefX);  
231     float resultY = mix(block2, block3, coefX);  
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;  
233  
234     return mix(resultX, resultY, coefY);  
235   }  
236  
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {  
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
244  
245     float offsetDepth = clipPos.z;  
246     vec2 mapSize = cc_shadowWHPBInfo.xy;  
247     vec2 oneTap = 1.0 / mapSize;  
248     float clipPos_offset_L = clipPos.x - oneTap.x;  
249     float clipPos_offset_R = clipPos.x + oneTap.x;  
250     float clipPos_offset_U = clipPos.y - oneTap.y;  
251     float clipPos_offset_D = clipPos.y + oneTap.y;  
252  
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;  
254     if (cc_shadowLPNNInfo.y > EPSILON) {  
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
264     } else {  
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);  
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);  
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);  
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);  
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);  
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);  
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);  
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);  
274     }  
275  
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;  
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;  
278  
279     float shadow = 0.0;  
280     float resultX = mix(block0, block1, coefX);  
281     float resultY = mix(block3, block4, coefX);  
282     shadow += mix(resultX , resultY, coefY);  
283  
284     resultX = mix(block1, block2, coefX);  
285     resultY = mix(block4, block5, coefX);  
286     shadow += mix(resultX , resultY, coefY);  
287  
288     resultX = mix(block3, block4, coefX);  
289     resultY = mix(block6, block7, coefX);  
290     shadow += mix(resultX, resultY, coefY);  
291  
292     resultX = mix(block4, block5, coefX);  
293     resultY = mix(block7, block8, coefX);  
294     shadow += mix(resultX, resultY, coefY);  
295  
296     return shadow * 0.25;  
297   }  
298  
299  
300  
301  
302  
303  
304  
305  
306  
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)  
308 {  
309   float realtimeShadow = 1.0;  
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);  
311  
312   float pcf = cc_shadowWHPBInfo.z;  
313   if (pcf > 1.9) {  
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);  
315   }else if (pcf > 0.9) {  
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);  
317   }else {  
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);  
319   }  
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);  
321 }  
322 #endif  
323  
324  
325  
326 #if CC_USE_IBL  
327   uniform samplerCube cc_environment;  
328  
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {  
330  
331       #ifdef GL_EXT_shader_texture_lod  
332         return texture2DLodEXT(tex, coord, lod);  
333       #else  
334         return texture2D(tex, coord, lod);  
335       #endif  
336  
337   }  
338  
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {  
340  
341       #ifdef GL_EXT_shader_texture_lod  
342         return textureCubeLodEXT(tex, coord, lod);  
343       #else  
344         return textureCube(tex, coord, lod);  
345       #endif  
346  
347   }  
348  
349  
350  
351  
352  
353  
354  
355   vec3 unpackRGBE (vec4 rgbe) {  
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);  
357   }  
358  
359  
360   #if CC_USE_DIFFUSEMAP  
361     uniform samplerCube cc_diffuseMap;  
362   #endif  
363 #endif  
364  
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {  
366   vec3 NxH = cross(N, H);  
367   float OneMinusNoHSqr = dot(NxH, NxH);  
368   float a = roughness * roughness;  
369   float n = NoH * a;  
370   float p = a / (OneMinusNoHSqr + n * n);  
371   return p * p;  
372 }  
373  
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {  
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);  
376 }  
377  
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {  
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);  
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);  
381   vec4 r = roughness * c0 + c1;  
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;  
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;  
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);  
385   return specular * AB.x + AB.y;  
386 }  
387  
388 #if USE_REFLECTION_DENOISE  
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {  
390     #if CC_USE_IBL  
391     	float mip = roughness * mipCount;  
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;  
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));  
394  
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);  
396      	vec4 filtered = textureCube(cc_environment, R);  
397  
398       #if CC_USE_IBL == 2  
399       	biased.rgb = unpackRGBE(biased);  
400       	filtered.rgb = unpackRGBE(filtered);  
401       #else  
402       	biased.rgb = SRGBToLinear(biased.rgb);  
403       	filtered.rgb = SRGBToLinear(filtered.rgb);  
404       #endif  
405  
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);  
407     #else  
408       return vec3(0.0, 0.0, 0.0);  
409     #endif  
410   }  
411 #endif  
412  
413  
414 struct StandardSurface {  
415   vec4 albedo;  
416  
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
418   vec3 position, position_fract_part;  
419   #else  
420   vec3 position;  
421   #endif  
422   vec3 normal;  
423   vec3 emissive;  
424   vec3 lightmap;  
425   float lightmap_test;  
426   float roughness;  
427   float metallic;  
428   float occlusion;  
429   float specularIntensity;  
430  
431   #if CC_RECEIVE_SHADOW  
432     vec2 shadowBias;  
433   #endif  
434 };  
435  
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {  
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);  
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);  
440  
441   vec3 position;  
442  
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
444   position = unpackHighpData(s.position, s.position_fract_part);  
445   #else  
446   position = s.position;  
447   #endif  
448  
449   vec3 N = normalize(s.normal);  
450   vec3 V = normalize(cc_cameraPos.xyz - position);  
451  
452   float NV = max(abs(dot(N, V)), 0.0);  
453   specular = BRDFApprox(specular, s.roughness, NV);  
454  
455   vec3 L = normalize(-cc_mainLitDir.xyz);  
456   vec3 H = normalize(L + V);  
457   float NH = max(dot(N, H), 0.0);  
458   float NL = max(dot(N, L), 0.0);  
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;  
460   vec3 diffuseContrib = diffuse / PI;  
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);  
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);  
463  
464   float shadow = 1.0;  
465   #if CC_RECEIVE_SHADOW  
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {  
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);  
468     }  
469   #endif  
470  
471   dirlightContrib *= shadow;  
472   finalColor *= dirlightContrib;  
473  
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD  
475     if (s.lightmap_test > EPSILON_LOWP) {  
476       finalColor = diffuse * s.lightmap.rgb * shadow;  
477     }  
478   #endif  
479  
480   float fAmb = 0.5 - N.y * 0.5;  
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);  
482  
483  
484   #if CC_USE_IBL  
485     #if CC_USE_DIFFUSEMAP  
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);  
487       #if CC_USE_DIFFUSEMAP == 2  
488         ambDiff = unpackRGBE(diffuseMap);  
489       #else  
490         ambDiff = SRGBToLinear(diffuseMap.rgb);  
491       #endif  
492     #endif  
493  
494     vec3 R = normalize(reflect(-V, N));  
495  
496     #if USE_REFLECTION_DENOISE  
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);  
498     #else  
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);  
500  
501       #if CC_USE_IBL == 2  
502         vec3 env = unpackRGBE(envmap);  
503       #else  
504         vec3 env = SRGBToLinear(envmap.rgb);  
505       #endif  
506     #endif  
507  
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;  
509   #endif  
510  
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;  
512  
513  
514   finalColor += s.emissive;  
515  
516   return vec4(finalColor, s.albedo.a);  
517 }  
518  
519  
520  
521 vec3 ACESToneMap (vec3 color) {  
522   color = min(color, vec3(8.0));  
523   const float A = 2.51;  
524   const float B = 0.03;  
525   const float C = 2.43;  
526   const float D = 0.59;  
527   const float E = 0.14;  
528   return (color * (A * color + B)) / (color * (C * color + D) + E);  
529 }  
530  
531  
532  
533 vec4 CCFragOutput (vec4 color) {  
534   #if CC_USE_HDR  
535     color.rgb = ACESToneMap(color.rgb);  
536   #endif  
537   color.rgb = sqrt(color.rgb);  
538   return color;  
539 }  
540  
541  
542  
543      uniform vec4 rimColor;  
544      uniform vec4 albedo;  
545      uniform vec4 albedoScaleAndCutoff;  
546      uniform vec4 pbrParams;  
547      uniform vec4 emissive;  
548      uniform vec4 emissiveScaleParam;  
549  
550  
551  
552  
553 varying highp vec4 v_shadowPos;  
554  
555  
556  
557 #if CC_RECEIVE_SHADOW  
558  
559  
560  
561 #endif  
562  
563  
564 varying vec3 v_position;  
565 varying vec3 v_view_position;  
566 varying vec2 v_uv;  
567 varying vec2 v_uv1;  
568 varying vec3 v_normal;  
569 varying vec3 v_view_normal;  
570  
571 #if USE_VERTEX_COLOR  
572   varying vec3 v_color;  
573 #endif  
574  
575 #if USE_ALBEDO_MAP  
576   uniform sampler2D albedoMap;  
577 #endif  
578 #if USE_NORMAL_MAP  
579   varying vec3 v_tangent;  
580   varying vec3 v_bitangent;  
581   uniform sampler2D normalMap;  
582 #endif  
583 #if USE_PBR_MAP  
584   uniform sampler2D pbrMap;  
585 #endif  
586 #if USE_METALLIC_ROUGHNESS_MAP  
587   uniform sampler2D metallicRoughnessMap;  
588 #endif  
589 #if USE_OCCLUSION_MAP  
590   uniform sampler2D occlusionMap;  
591 #endif  
592 #if USE_EMISSIVE_MAP  
593   uniform sampler2D emissiveMap;  
594 #endif  
595 #if CC_USE_LIGHTMAP  
596   varying vec2 v_luv;  
597   uniform sampler2D cc_lightingMap;  
598 #endif  
599 #if USE_ALPHA_TEST  
600 #endif  
601  
602 void surf (out StandardSurface s) {  
603   vec4 baseColor = albedo;  
604   #if USE_VERTEX_COLOR  
605     baseColor.rgb *= v_color;  
606   #endif  
607   #if USE_ALBEDO_MAP  
608     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);  
609     texColor.rgb = SRGBToLinear(texColor.rgb);  
610     baseColor *= texColor;  
611   #endif  
612   s.albedo = baseColor;  
613   s.albedo.rgb *= albedoScaleAndCutoff.xyz;  
614  
615   #if USE_ALPHA_TEST  
616     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;  
617   #endif  
618   float density = 0.001;  
619   float dist2 = dot(v_view_position,v_view_position);  
620   float fogFactor = exp( -density*density * dist2);  
621   fogFactor = clamp(fogFactor, 0.0, 1.0);  
622  
623   vec3 fogColor = vec3(1.0,1,1.0);  
624   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);  
625  
626   s.normal = v_normal;  
627   #if USE_NORMAL_MAP  
628     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);  
629     s.normal =  
630       (nmmp.x * pbrParams.w) * normalize(v_tangent) +  
631       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +  
632       nmmp.z * normalize(s.normal);  
633   #endif  
634  
635   s.position = v_position;  
636  
637   vec4 pbr = pbrParams;  
638   #if USE_PBR_MAP  
639     vec4 res = texture2D(pbrMap, PBR_UV);  
640     pbr.x *= res.OCCLUSION_CHANNEL;  
641     pbr.y *= res.ROUGHNESS_CHANNEL;  
642     pbr.z *= res.METALLIC_CHANNEL;  
643   #endif  
644   #if USE_METALLIC_ROUGHNESS_MAP  
645     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);  
646     pbr.z *= metallicRoughness.METALLIC_CHANNEL;  
647     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;  
648   #endif  
649   #if USE_OCCLUSION_MAP  
650     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;  
651   #endif  
652   s.occlusion = clamp(pbr.x, 0.0, 0.96);  
653   s.roughness = clamp(pbr.y, 0.04, 1.0);  
654   s.specularIntensity = 0.5;  
655   s.metallic = pbr.z;  
656  
657   s.emissive = emissive.rgb * emissiveScaleParam.xyz;  
658   #if USE_EMISSIVE_MAP  
659     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);  
660   #endif  
661 }  
662  
663 vec4 frag () {  
664   StandardSurface s; surf(s);  
665   vec4 color = CCStandardShadingBase(s, CC_SHANDOW_POSITION);  
666  
667   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING  
668     vec4 lighting = texture2D(cc_lightingMap, v_luv);  
669  
670     float fAmb = 0.5 - s.normal.y * 0.5;  
671     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;  
672  
673     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);  
674     finalColor += lighting.rgb *  s.albedo.rgb;  
675     finalColor = finalColor * s.occlusion;  
676     finalColor += s.emissive;  
677  
678     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;  
679   #endif  
680  
681   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;  
682  
683   color.rgb = mix(color.rgb,rimColor.rgb,fRim);  
684  
685   return CCFragOutput(color);  
686 }  
687  
688  
689 void main() { gl_FragColor = frag(); }  
690  
at Object.encode (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-worker/node_modules/v-stacks/index.js:14:17)  
at Logger._logHandler (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-worker/static/script.ccc:1:531)  
at Logger.record (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:458)  
at console.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:1414)  
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)  
at async ParallelQueue._generate (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/asset-db.ccc:1:2165)
2022-06-23T02:28:14.220Z - error: [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos   
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)  
at async ParallelQueue._generate (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/asset-db.ccc:1:2165)
2022-06-23T02:41:24.566Z - error: [Asset DB] ../res/rim_light.effect - standard-fs:frag: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:570: 'v_shadowPos' : redefinition
 

1 #version 100
2 #define USE_INSTANCING 1
3 #define USE_BATCHING 1
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
13 #define CC_USE_SKINNING 1
14 #define CC_USE_BAKED_ANIMATION 1
15 #define CC_USE_LIGHTMAP 1
16 #define CC_RECEIVE_SHADOW 1
17 #define CC_USE_MORPH 1
18 #define CC_MORPH_TARGET_COUNT 2
19 #define CC_MORPH_PRECOMPUTED 1
20 #define CC_MORPH_TARGET_HAS_POSITION 1
21 #define CC_MORPH_TARGET_HAS_NORMAL 1
22 #define CC_MORPH_TARGET_HAS_TANGENT 1
23 #define USE_VERTEX_COLOR 1
24 #define USE_NORMAL_MAP 1
25 #define HAS_SECOND_UV 1
26 #define CC_USE_IBL 0
27 #define CC_USE_DIFFUSEMAP 0
28 #define USE_REFLECTION_DENOISE 1
29 #define CC_FORWARD_ADD 1
30 #define CC_USE_HDR 1
31 #define USE_ALBEDO_MAP 1
32 #define ALBEDO_UV v_uv
33 #define NORMAL_UV v_uv
34 #define USE_PBR_MAP 1
35 #define PBR_UV v_uv
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define METALLIC_ROUGHNESS_UV v_uv
38 #define USE_OCCLUSION_MAP 1
39 #define OCCLUSION_UV v_uv
40 #define USE_EMISSIVE_MAP 1
41 #define EMISSIVE_UV v_uv
42 #define OCCLUSION_CHANNEL r
43 #define ROUGHNESS_CHANNEL g
44 #define METALLIC_CHANNEL b
45 #define USE_ALPHA_TEST 1
46 #define ALPHA_TEST_CHANNEL a
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp vec4 cc_cameraPos;
58   uniform mediump vec4 cc_mainLitDir;
59   uniform mediump vec4 cc_mainLitColor;
60   uniform mediump vec4 cc_ambientSky;
61   uniform mediump vec4 cc_ambientGround;
62 
63 
64 
65 
66 
67 
68 #define QUATER_PI         0.78539816340
69 #define HALF_PI           1.57079632679
70 #define PI                3.14159265359
71 #define PI2               6.28318530718
72 #define PI4               12.5663706144
73      
74 #define INV_QUATER_PI     1.27323954474
75 #define INV_HALF_PI       0.63661977237
76 #define INV_PI            0.31830988618
77 #define INV_PI2           0.15915494309
78 #define INV_PI4           0.07957747155
79      
80 #define EPSILON           1e-6
81 #define EPSILON_LOWP      1e-4
82 #define LOG2              1.442695
83 #define EXP_VALUE         2.71828183f
84 #define FP_MAX            65504.0
85 #define FP_SCALE          0.0009765625
86 #define FP_SCALE_INV      1024.0
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
88 
89 
90 
91 
92 
93 
94 
95 vec3 SRGBToLinear (vec3 gamma) {
96   return gamma * gamma;
97 }
98 uniform highp mat4 cc_matLightView;
99   uniform highp vec4 cc_shadowProjDepthInfo;
100   uniform highp vec4 cc_shadowProjInfo;
101   uniform mediump vec4 cc_shadowNFLSInfo;
102   uniform mediump vec4 cc_shadowWHPBInfo;
103   uniform mediump vec4 cc_shadowLPNNInfo;
104 
105 
106 
107 
108 
109 
110 
111 
112 highp float unpackHighpData (float mainPart, float modPart) {
113   highp float data = mainPart;
114   return data + modPart;
115 }
116 
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
118   highp float data = mainPart * modValue;
119   return data + modPart * modValue;
120 }
121 
122 
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
124   highp vec2 data = mainPart;
125   return data + modPart;
126 }
127 
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
129   highp vec2 data = mainPart * modValue;
130   return data + modPart * modValue;
131 }
132 
133 
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
135   highp vec3 data = mainPart;
136   return data + modPart;
137 }
138 
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
140   highp vec3 data = mainPart * modValue;
141   return data + modPart * modValue;
142 }
143 
144 
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
146   highp vec4 data = mainPart;
147   return data + modPart;
148 }
149 
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
151   highp vec4 data = mainPart * modValue;
152   return data + modPart * modValue;
153 }
154 #if CC_RECEIVE_SHADOW
155   uniform highp sampler2D cc_shadowMap;
156   uniform highp sampler2D cc_spotLightingMap;
157 
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
159   {
160     vec4 newShadowPos = shadowPos;
161     if(normalBias > EPSILON_LOWP)
162     {
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
164       if(viewNormal.z < 0.1)
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
166     }
167     return newShadowPos;
168   }
169   
170   
171 
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
173   {
174     float coeffA = cc_shadowProjDepthInfo.x;
175     float coeffB = cc_shadowProjDepthInfo.y;
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
177     viewSpacePos_z += viewspaceDepthBias;
178     vec4 result = shadowPos;
179     result.z = viewSpacePos_z * coeffA + coeffB;
180     return result;
181   }
182   
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
190 
191     float shadow = 0.0;
192     float closestDepth = 0.0;
193     if (cc_shadowLPNNInfo.y > EPSILON) {
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
195     } else {
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
197     }
198     shadow = step(clipPos.z, closestDepth);
199 
200     return shadow;
201   }
202 
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
210 
211     float offsetDepth = clipPos.z;
212     vec2 mapSize = cc_shadowWHPBInfo.xy;
213     vec2 oneTap = 1.0 / mapSize;
214     vec2 clipPos_offset = clipPos.xy + oneTap;
215 
216     float block0, block1, block2, block3;
217     if (cc_shadowLPNNInfo.y > EPSILON) {
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
222     } else {
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
227     }
228 
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
230     float resultX = mix(block0, block1, coefX);
231     float resultY = mix(block2, block3, coefX);
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
233 
234     return mix(resultX, resultY, coefY);
235   }
236 
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
244 
245     float offsetDepth = clipPos.z;
246     vec2 mapSize = cc_shadowWHPBInfo.xy;
247     vec2 oneTap = 1.0 / mapSize;
248     float clipPos_offset_L = clipPos.x - oneTap.x;
249     float clipPos_offset_R = clipPos.x + oneTap.x;
250     float clipPos_offset_U = clipPos.y - oneTap.y;
251     float clipPos_offset_D = clipPos.y + oneTap.y;
252 
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
254     if (cc_shadowLPNNInfo.y > EPSILON) {
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
264     } else {
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
274     }
275 
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
278 
279     float shadow = 0.0;
280     float resultX = mix(block0, block1, coefX);
281     float resultY = mix(block3, block4, coefX);
282     shadow += mix(resultX , resultY, coefY);
283 
284     resultX = mix(block1, block2, coefX);
285     resultY = mix(block4, block5, coefX);
286     shadow += mix(resultX , resultY, coefY);
287 
288     resultX = mix(block3, block4, coefX);
289     resultY = mix(block6, block7, coefX);
290     shadow += mix(resultX, resultY, coefY);
291 
292     resultX = mix(block4, block5, coefX);
293     resultY = mix(block7, block8, coefX);
294     shadow += mix(resultX, resultY, coefY);
295 
296     return shadow * 0.25;
297   }
298 
299   
300 
301   
302 
303   
304 
305 
306 
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
308 {
309   float realtimeShadow = 1.0;
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
311   
312   float pcf = cc_shadowWHPBInfo.z;
313   if (pcf > 1.9) { 
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
315   }else if (pcf > 0.9) {
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
317   }else { 
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
319   }
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
321 }
322 #endif
323 
324 
325 
326 #if CC_USE_IBL
327   uniform samplerCube cc_environment;
328   
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
330     
331       #ifdef GL_EXT_shader_texture_lod
332         return texture2DLodEXT(tex, coord, lod);
333       #else
334         return texture2D(tex, coord, lod);
335       #endif
336     
337   }
338   
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
340     
341       #ifdef GL_EXT_shader_texture_lod
342         return textureCubeLodEXT(tex, coord, lod);
343       #else
344         return textureCube(tex, coord, lod);
345       #endif
346     
347   }
348   
349   
350   
351   
352   
353   
354   
355   vec3 unpackRGBE (vec4 rgbe) {
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
357   }
358   
359 
360   #if CC_USE_DIFFUSEMAP
361     uniform samplerCube cc_diffuseMap;
362   #endif
363 #endif
364 
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
366   vec3 NxH = cross(N, H);
367   float OneMinusNoHSqr = dot(NxH, NxH);
368   float a = roughness * roughness;
369   float n = NoH * a;
370   float p = a / (OneMinusNoHSqr + n * n);
371   return p * p;
372 }
373 
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
376 }
377 
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
381   vec4 r = roughness * c0 + c1;
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
385   return specular * AB.x + AB.y;
386 }
387 
388 #if USE_REFLECTION_DENOISE
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
390     #if CC_USE_IBL
391     	float mip = roughness * mipCount;
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
394 
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
396      	vec4 filtered = textureCube(cc_environment, R);
397 
398       #if CC_USE_IBL == 2
399       	biased.rgb = unpackRGBE(biased);
400       	filtered.rgb = unpackRGBE(filtered);
401       #else
402       	biased.rgb = SRGBToLinear(biased.rgb);
403       	filtered.rgb = SRGBToLinear(filtered.rgb);
404       #endif
405       	
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
407     #else
408       return vec3(0.0, 0.0, 0.0);
409     #endif
410   }
411 #endif
412 
413 
414 struct StandardSurface {
415   vec4 albedo;
416   
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
418   vec3 position, position_fract_part;
419   #else
420   vec3 position;
421   #endif
422   vec3 normal;
423   vec3 emissive;
424   vec3 lightmap;
425   float lightmap_test;
426   float roughness;
427   float metallic;
428   float occlusion;
429   float specularIntensity;
430 
431   #if CC_RECEIVE_SHADOW
432     vec2 shadowBias;
433   #endif
434 };
435 
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
440 
441   vec3 position;
442   
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
444   position = unpackHighpData(s.position, s.position_fract_part);
445   #else
446   position = s.position;
447   #endif
448 
449   vec3 N = normalize(s.normal);
450   vec3 V = normalize(cc_cameraPos.xyz - position);
451 
452   float NV = max(abs(dot(N, V)), 0.0);
453   specular = BRDFApprox(specular, s.roughness, NV);
454 
455   vec3 L = normalize(-cc_mainLitDir.xyz);
456   vec3 H = normalize(L + V);
457   float NH = max(dot(N, H), 0.0);
458   float NL = max(dot(N, L), 0.0);
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
460   vec3 diffuseContrib = diffuse / PI;
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);
463 
464   float shadow = 1.0;
465   #if CC_RECEIVE_SHADOW
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
468     }
469   #endif
470 
471   dirlightContrib *= shadow;
472   finalColor *= dirlightContrib;
473 
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
475     if (s.lightmap_test > EPSILON_LOWP) {
476       finalColor = diffuse * s.lightmap.rgb * shadow;
477     }
478   #endif
479 
480   float fAmb = 0.5 - N.y * 0.5;
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
482 
483 
484   #if CC_USE_IBL
485     #if CC_USE_DIFFUSEMAP
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
487       #if CC_USE_DIFFUSEMAP == 2
488         ambDiff = unpackRGBE(diffuseMap);
489       #else
490         ambDiff = SRGBToLinear(diffuseMap.rgb);
491       #endif
492     #endif
493 
494     vec3 R = normalize(reflect(-V, N));
495 
496     #if USE_REFLECTION_DENOISE
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
498     #else
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
500 
501       #if CC_USE_IBL == 2
502         vec3 env = unpackRGBE(envmap);
503       #else
504         vec3 env = SRGBToLinear(envmap.rgb);
505       #endif
506     #endif
507 
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
509   #endif
510 
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
512   
513 
514   finalColor += s.emissive;
515 
516   return vec4(finalColor, s.albedo.a);
517 }
518 
519 
520 
521 vec3 ACESToneMap (vec3 color) {
522   color = min(color, vec3(8.0));
523   const float A = 2.51;
524   const float B = 0.03;
525   const float C = 2.43;
526   const float D = 0.59;
527   const float E = 0.14;
528   return (color * (A * color + B)) / (color * (C * color + D) + E);
529 }
530 
531 
532 
533 vec4 CCFragOutput (vec4 color) {
534   #if CC_USE_HDR
535     color.rgb = ACESToneMap(color.rgb);
536   #endif
537   color.rgb = sqrt(color.rgb);
538   return color;
539 }
540 
541 
542 
543      uniform vec4 rimColor;
544      uniform vec4 albedo;
545      uniform vec4 albedoScaleAndCutoff;
546      uniform vec4 pbrParams;
547      uniform vec4 emissive;
548      uniform vec4 emissiveScaleParam;
549 
550 
551 
552 
553 varying highp vec4 v_shadowPos;
554 
555 
556 
557 #if CC_RECEIVE_SHADOW
558 
559 
560 
561 #endif
562 
563 
564 varying vec3 v_position;
565 varying vec3 v_view_position;
566 varying vec2 v_uv;
567 varying vec2 v_uv1;
568 varying vec3 v_normal;
569 varying vec3 v_view_normal;
570 varying vec4 v_shadowPos;
571 
572 #if USE_VERTEX_COLOR
573   varying vec3 v_color;
574 #endif
575 
576 #if USE_ALBEDO_MAP
577   uniform sampler2D albedoMap;
578 #endif
579 #if USE_NORMAL_MAP
580   varying vec3 v_tangent;
581   varying vec3 v_bitangent;
582   uniform sampler2D normalMap;
583 #endif
584 #if USE_PBR_MAP
585   uniform sampler2D pbrMap;
586 #endif
587 #if USE_METALLIC_ROUGHNESS_MAP
588   uniform sampler2D metallicRoughnessMap;
589 #endif
590 #if USE_OCCLUSION_MAP
591   uniform sampler2D occlusionMap;
592 #endif
593 #if USE_EMISSIVE_MAP
594   uniform sampler2D emissiveMap;
595 #endif
596 #if CC_USE_LIGHTMAP
597   varying vec2 v_luv;
598   uniform sampler2D cc_lightingMap;
599 #endif
600 #if USE_ALPHA_TEST
601 #endif
602 
603 void surf (out StandardSurface s) {
604   vec4 baseColor = albedo;
605   #if USE_VERTEX_COLOR
606     baseColor.rgb *= v_color;
607   #endif
608   #if USE_ALBEDO_MAP
609     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);
610     texColor.rgb = SRGBToLinear(texColor.rgb);
611     baseColor *= texColor;
612   #endif
613   s.albedo = baseColor;
614   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
615 
616   #if USE_ALPHA_TEST
617     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
618   #endif
619   float density = 0.001;
620   float dist2 = dot(v_view_position,v_view_position);
621   float fogFactor = exp( -density*density * dist2);
622   fogFactor = clamp(fogFactor, 0.0, 1.0);
623 
624   vec3 fogColor = vec3(1.0,1,1.0);
625   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);
626 
627   s.normal = v_normal;
628   #if USE_NORMAL_MAP
629     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);
630     s.normal =
631       (nmmp.x * pbrParams.w) * normalize(v_tangent) +
632       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +
633       nmmp.z * normalize(s.normal);
634   #endif
635 
636   s.position = v_position;
637 
638   vec4 pbr = pbrParams;
639   #if USE_PBR_MAP
640     vec4 res = texture2D(pbrMap, PBR_UV);
641     pbr.x *= res.OCCLUSION_CHANNEL;
642     pbr.y *= res.ROUGHNESS_CHANNEL;
643     pbr.z *= res.METALLIC_CHANNEL;
644   #endif
645   #if USE_METALLIC_ROUGHNESS_MAP
646     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);
647     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
648     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
649   #endif
650   #if USE_OCCLUSION_MAP
651     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;
652   #endif
653   s.occlusion = clamp(pbr.x, 0.0, 0.96);
654   s.roughness = clamp(pbr.y, 0.04, 1.0);
655   s.specularIntensity = 0.5;
656   s.metallic = pbr.z;
657 
658   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
659   #if USE_EMISSIVE_MAP
660     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);
661   #endif
662 }
663 
664 vec4 frag () {
665   StandardSurface s; surf(s);
666   vec4 color = CCStandardShadingBase(s, v_shadowPos);
667 
668   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING
669     vec4 lighting = texture2D(cc_lightingMap, v_luv);
670 
671     float fAmb = 0.5 - s.normal.y * 0.5;
672     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
673 
674     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);
675     finalColor += lighting.rgb *  s.albedo.rgb;
676     finalColor = finalColor * s.occlusion;
677     finalColor += s.emissive;
678 
679     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;
680   #endif
681 
682   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;
683 
684   color.rgb = mix(color.rgb,rimColor.rgb,fRim);
685 
686   return CCFragOutput(color);
687 }
688 
689 
690 void main() { gl_FragColor = frag(); }
691 [Asset DB] ../res/rim_light.effect - standard-fs:frag: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:570: 'v_shadowPos' : redefinition
 

1 #version 100
2 #define USE_INSTANCING 1
3 #define USE_BATCHING 1
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
13 #define CC_USE_SKINNING 1
14 #define CC_USE_BAKED_ANIMATION 1
15 #define CC_USE_LIGHTMAP 1
16 #define CC_RECEIVE_SHADOW 1
17 #define CC_USE_MORPH 1
18 #define CC_MORPH_TARGET_COUNT 2
19 #define CC_MORPH_PRECOMPUTED 1
20 #define CC_MORPH_TARGET_HAS_POSITION 1
21 #define CC_MORPH_TARGET_HAS_NORMAL 1
22 #define CC_MORPH_TARGET_HAS_TANGENT 1
23 #define USE_VERTEX_COLOR 1
24 #define USE_NORMAL_MAP 1
25 #define HAS_SECOND_UV 1
26 #define CC_USE_IBL 0
27 #define CC_USE_DIFFUSEMAP 0
28 #define USE_REFLECTION_DENOISE 1
29 #define CC_FORWARD_ADD 1
30 #define CC_USE_HDR 1
31 #define USE_ALBEDO_MAP 1
32 #define ALBEDO_UV v_uv
33 #define NORMAL_UV v_uv
34 #define USE_PBR_MAP 1
35 #define PBR_UV v_uv
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define METALLIC_ROUGHNESS_UV v_uv
38 #define USE_OCCLUSION_MAP 1
39 #define OCCLUSION_UV v_uv
40 #define USE_EMISSIVE_MAP 1
41 #define EMISSIVE_UV v_uv
42 #define OCCLUSION_CHANNEL r
43 #define ROUGHNESS_CHANNEL g
44 #define METALLIC_CHANNEL b
45 #define USE_ALPHA_TEST 1
46 #define ALPHA_TEST_CHANNEL a
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp vec4 cc_cameraPos;
58   uniform mediump vec4 cc_mainLitDir;
59   uniform mediump vec4 cc_mainLitColor;
60   uniform mediump vec4 cc_ambientSky;
61   uniform mediump vec4 cc_ambientGround;
62 
63 
64 
65 
66 
67 
68 #define QUATER_PI         0.78539816340
69 #define HALF_PI           1.57079632679
70 #define PI                3.14159265359
71 #define PI2               6.28318530718
72 #define PI4               12.5663706144
73      
74 #define INV_QUATER_PI     1.27323954474
75 #define INV_HALF_PI       0.63661977237
76 #define INV_PI            0.31830988618
77 #define INV_PI2           0.15915494309
78 #define INV_PI4           0.07957747155
79      
80 #define EPSILON           1e-6
81 #define EPSILON_LOWP      1e-4
82 #define LOG2              1.442695
83 #define EXP_VALUE         2.71828183f
84 #define FP_MAX            65504.0
85 #define FP_SCALE          0.0009765625
86 #define FP_SCALE_INV      1024.0
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
88 
89 
90 
91 
92 
93 
94 
95 vec3 SRGBToLinear (vec3 gamma) {
96   return gamma * gamma;
97 }
98 uniform highp mat4 cc_matLightView;
99   uniform highp vec4 cc_shadowProjDepthInfo;
100   uniform highp vec4 cc_shadowProjInfo;
101   uniform mediump vec4 cc_shadowNFLSInfo;
102   uniform mediump vec4 cc_shadowWHPBInfo;
103   uniform mediump vec4 cc_shadowLPNNInfo;
104 
105 
106 
107 
108 
109 
110 
111 
112 highp float unpackHighpData (float mainPart, float modPart) {
113   highp float data = mainPart;
114   return data + modPart;
115 }
116 
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
118   highp float data = mainPart * modValue;
119   return data + modPart * modValue;
120 }
121 
122 
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
124   highp vec2 data = mainPart;
125   return data + modPart;
126 }
127 
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
129   highp vec2 data = mainPart * modValue;
130   return data + modPart * modValue;
131 }
132 
133 
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
135   highp vec3 data = mainPart;
136   return data + modPart;
137 }
138 
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
140   highp vec3 data = mainPart * modValue;
141   return data + modPart * modValue;
142 }
143 
144 
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
146   highp vec4 data = mainPart;
147   return data + modPart;
148 }
149 
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
151   highp vec4 data = mainPart * modValue;
152   return data + modPart * modValue;
153 }
154 #if CC_RECEIVE_SHADOW
155   uniform highp sampler2D cc_shadowMap;
156   uniform highp sampler2D cc_spotLightingMap;
157 
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
159   {
160     vec4 newShadowPos = shadowPos;
161     if(normalBias > EPSILON_LOWP)
162     {
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
164       if(viewNormal.z < 0.1)
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
166     }
167     return newShadowPos;
168   }
169   
170   
171 
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
173   {
174     float coeffA = cc_shadowProjDepthInfo.x;
175     float coeffB = cc_shadowProjDepthInfo.y;
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
177     viewSpacePos_z += viewspaceDepthBias;
178     vec4 result = shadowPos;
179     result.z = viewSpacePos_z * coeffA + coeffB;
180     return result;
181   }
182   
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
190 
191     float shadow = 0.0;
192     float closestDepth = 0.0;
193     if (cc_shadowLPNNInfo.y > EPSILON) {
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
195     } else {
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
197     }
198     shadow = step(clipPos.z, closestDepth);
199 
200     return shadow;
201   }
202 
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
210 
211     float offsetDepth = clipPos.z;
212     vec2 mapSize = cc_shadowWHPBInfo.xy;
213     vec2 oneTap = 1.0 / mapSize;
214     vec2 clipPos_offset = clipPos.xy + oneTap;
215 
216     float block0, block1, block2, block3;
217     if (cc_shadowLPNNInfo.y > EPSILON) {
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
222     } else {
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
227     }
228 
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
230     float resultX = mix(block0, block1, coefX);
231     float resultY = mix(block2, block3, coefX);
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
233 
234     return mix(resultX, resultY, coefY);
235   }
236 
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
244 
245     float offsetDepth = clipPos.z;
246     vec2 mapSize = cc_shadowWHPBInfo.xy;
247     vec2 oneTap = 1.0 / mapSize;
248     float clipPos_offset_L = clipPos.x - oneTap.x;
249     float clipPos_offset_R = clipPos.x + oneTap.x;
250     float clipPos_offset_U = clipPos.y - oneTap.y;
251     float clipPos_offset_D = clipPos.y + oneTap.y;
252 
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
254     if (cc_shadowLPNNInfo.y > EPSILON) {
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
264     } else {
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
274     }
275 
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
278 
279     float shadow = 0.0;
280     float resultX = mix(block0, block1, coefX);
281     float resultY = mix(block3, block4, coefX);
282     shadow += mix(resultX , resultY, coefY);
283 
284     resultX = mix(block1, block2, coefX);
285     resultY = mix(block4, block5, coefX);
286     shadow += mix(resultX , resultY, coefY);
287 
288     resultX = mix(block3, block4, coefX);
289     resultY = mix(block6, block7, coefX);
290     shadow += mix(resultX, resultY, coefY);
291 
292     resultX = mix(block4, block5, coefX);
293     resultY = mix(block7, block8, coefX);
294     shadow += mix(resultX, resultY, coefY);
295 
296     return shadow * 0.25;
297   }
298 
299   
300 
301   
302 
303   
304 
305 
306 
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
308 {
309   float realtimeShadow = 1.0;
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
311   
312   float pcf = cc_shadowWHPBInfo.z;
313   if (pcf > 1.9) { 
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
315   }else if (pcf > 0.9) {
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
317   }else { 
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
319   }
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
321 }
322 #endif
323 
324 
325 
326 #if CC_USE_IBL
327   uniform samplerCube cc_environment;
328   
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
330     
331       #ifdef GL_EXT_shader_texture_lod
332         return texture2DLodEXT(tex, coord, lod);
333       #else
334         return texture2D(tex, coord, lod);
335       #endif
336     
337   }
338   
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
340     
341       #ifdef GL_EXT_shader_texture_lod
342         return textureCubeLodEXT(tex, coord, lod);
343       #else
344         return textureCube(tex, coord, lod);
345       #endif
346     
347   }
348   
349   
350   
351   
352   
353   
354   
355   vec3 unpackRGBE (vec4 rgbe) {
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
357   }
358   
359 
360   #if CC_USE_DIFFUSEMAP
361     uniform samplerCube cc_diffuseMap;
362   #endif
363 #endif
364 
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
366   vec3 NxH = cross(N, H);
367   float OneMinusNoHSqr = dot(NxH, NxH);
368   float a = roughness * roughness;
369   float n = NoH * a;
370   float p = a / (OneMinusNoHSqr + n * n);
371   return p * p;
372 }
373 
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
376 }
377 
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
381   vec4 r = roughness * c0 + c1;
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
385   return specular * AB.x + AB.y;
386 }
387 
388 #if USE_REFLECTION_DENOISE
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
390     #if CC_USE_IBL
391     	float mip = roughness * mipCount;
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
394 
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
396      	vec4 filtered = textureCube(cc_environment, R);
397 
398       #if CC_USE_IBL == 2
399       	biased.rgb = unpackRGBE(biased);
400       	filtered.rgb = unpackRGBE(filtered);
401       #else
402       	biased.rgb = SRGBToLinear(biased.rgb);
403       	filtered.rgb = SRGBToLinear(filtered.rgb);
404       #endif
405       	
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
407     #else
408       return vec3(0.0, 0.0, 0.0);
409     #endif
410   }
411 #endif
412 
413 
414 struct StandardSurface {
415   vec4 albedo;
416   
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
418   vec3 position, position_fract_part;
419   #else
420   vec3 position;
421   #endif
422   vec3 normal;
423   vec3 emissive;
424   vec3 lightmap;
425   float lightmap_test;
426   float roughness;
427   float metallic;
428   float occlusion;
429   float specularIntensity;
430 
431   #if CC_RECEIVE_SHADOW
432     vec2 shadowBias;
433   #endif
434 };
435 
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
440 
441   vec3 position;
442   
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
444   position = unpackHighpData(s.position, s.position_fract_part);
445   #else
446   position = s.position;
447   #endif
448 
449   vec3 N = normalize(s.normal);
450   vec3 V = normalize(cc_cameraPos.xyz - position);
451 
452   float NV = max(abs(dot(N, V)), 0.0);
453   specular = BRDFApprox(specular, s.roughness, NV);
454 
455   vec3 L = normalize(-cc_mainLitDir.xyz);
456   vec3 H = normalize(L + V);
457   float NH = max(dot(N, H), 0.0);
458   float NL = max(dot(N, L), 0.0);
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
460   vec3 diffuseContrib = diffuse / PI;
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);
463 
464   float shadow = 1.0;
465   #if CC_RECEIVE_SHADOW
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
468     }
469   #endif
470 
471   dirlightContrib *= shadow;
472   finalColor *= dirlightContrib;
473 
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
475     if (s.lightmap_test > EPSILON_LOWP) {
476       finalColor = diffuse * s.lightmap.rgb * shadow;
477     }
478   #endif
479 
480   float fAmb = 0.5 - N.y * 0.5;
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
482 
483 
484   #if CC_USE_IBL
485     #if CC_USE_DIFFUSEMAP
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
487       #if CC_USE_DIFFUSEMAP == 2
488         ambDiff = unpackRGBE(diffuseMap);
489       #else
490         ambDiff = SRGBToLinear(diffuseMap.rgb);
491       #endif
492     #endif
493 
494     vec3 R = normalize(reflect(-V, N));
495 
496     #if USE_REFLECTION_DENOISE
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
498     #else
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
500 
501       #if CC_USE_IBL == 2
502         vec3 env = unpackRGBE(envmap);
503       #else
504         vec3 env = SRGBToLinear(envmap.rgb);
505       #endif
506     #endif
507 
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
509   #endif
510 
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
512   
513 
514   finalColor += s.emissive;
515 
516   return vec4(finalColor, s.albedo.a);
517 }
518 
519 
520 
521 vec3 ACESToneMap (vec3 color) {
522   color = min(color, vec3(8.0));
523   const float A = 2.51;
524   const float B = 0.03;
525   const float C = 2.43;
526   const float D = 0.59;
527   const float E = 0.14;
528   return (color * (A * color + B)) / (color * (C * color + D) + E);
529 }
530 
531 
532 
533 vec4 CCFragOutput (vec4 color) {
534   #if CC_USE_HDR
535     color.rgb = ACESToneMap(color.rgb);
536   #endif
537   color.rgb = sqrt(color.rgb);
538   return color;
539 }
540 
541 
542 
543      uniform vec4 rimColor;
544      uniform vec4 albedo;
545      uniform vec4 albedoScaleAndCutoff;
546      uniform vec4 pbrParams;
547      uniform vec4 emissive;
548      uniform vec4 emissiveScaleParam;
549 
550 
551 
552 
553 varying highp vec4 v_shadowPos;
554 
555 
556 
557 #if CC_RECEIVE_SHADOW
558 
559 
560 
561 #endif
562 
563 
564 varying vec3 v_position;
565 varying vec3 v_view_position;
566 varying vec2 v_uv;
567 varying vec2 v_uv1;
568 varying vec3 v_normal;
569 varying vec3 v_view_normal;
570 varying vec4 v_shadowPos;
571 
572 #if USE_VERTEX_COLOR
573   varying vec3 v_color;
574 #endif
575 
576 #if USE_ALBEDO_MAP
577   uniform sampler2D albedoMap;
578 #endif
579 #if USE_NORMAL_MAP
580   varying vec3 v_tangent;
581   varying vec3 v_bitangent;
582   uniform sampler2D normalMap;
583 #endif
584 #if USE_PBR_MAP
585   uniform sampler2D pbrMap;
586 #endif
587 #if USE_METALLIC_ROUGHNESS_MAP
588   uniform sampler2D metallicRoughnessMap;
589 #endif
590 #if USE_OCCLUSION_MAP
591   uniform sampler2D occlusionMap;
592 #endif
593 #if USE_EMISSIVE_MAP
594   uniform sampler2D emissiveMap;
595 #endif
596 #if CC_USE_LIGHTMAP
597   varying vec2 v_luv;
598   uniform sampler2D cc_lightingMap;
599 #endif
600 #if USE_ALPHA_TEST
601 #endif
602 
603 void surf (out StandardSurface s) {
604   vec4 baseColor = albedo;
605   #if USE_VERTEX_COLOR
606     baseColor.rgb *= v_color;
607   #endif
608   #if USE_ALBEDO_MAP
609     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);
610     texColor.rgb = SRGBToLinear(texColor.rgb);
611     baseColor *= texColor;
612   #endif
613   s.albedo = baseColor;
614   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
615 
616   #if USE_ALPHA_TEST
617     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
618   #endif
619   float density = 0.001;
620   float dist2 = dot(v_view_position,v_view_position);
621   float fogFactor = exp( -density*density * dist2);
622   fogFactor = clamp(fogFactor, 0.0, 1.0);
623 
624   vec3 fogColor = vec3(1.0,1,1.0);
625   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);
626 
627   s.normal = v_normal;
628   #if USE_NORMAL_MAP
629     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);
630     s.normal =
631       (nmmp.x * pbrParams.w) * normalize(v_tangent) +
632       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +
633       nmmp.z * normalize(s.normal);
634   #endif
635 
636   s.position = v_position;
637 
638   vec4 pbr = pbrParams;
639   #if USE_PBR_MAP
640     vec4 res = texture2D(pbrMap, PBR_UV);
641     pbr.x *= res.OCCLUSION_CHANNEL;
642     pbr.y *= res.ROUGHNESS_CHANNEL;
643     pbr.z *= res.METALLIC_CHANNEL;
644   #endif
645   #if USE_METALLIC_ROUGHNESS_MAP
646     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);
647     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
648     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
649   #endif
650   #if USE_OCCLUSION_MAP
651     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;
652   #endif
653   s.occlusion = clamp(pbr.x, 0.0, 0.96);
654   s.roughness = clamp(pbr.y, 0.04, 1.0);
655   s.specularIntensity = 0.5;
656   s.metallic = pbr.z;
657 
658   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
659   #if USE_EMISSIVE_MAP
660     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);
661   #endif
662 }
663 
664 vec4 frag () {
665   StandardSurface s; surf(s);
666   vec4 color = CCStandardShadingBase(s, v_shadowPos);
667 
668   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING
669     vec4 lighting = texture2D(cc_lightingMap, v_luv);
670 
671     float fAmb = 0.5 - s.normal.y * 0.5;
672     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
673 
674     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);
675     finalColor += lighting.rgb *  s.albedo.rgb;
676     finalColor = finalColor * s.occlusion;
677     finalColor += s.emissive;
678 
679     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;
680   #endif
681 
682   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;
683 
684   color.rgb = mix(color.rgb,rimColor.rgb,fRim);
685 
686   return CCFragOutput(color);
687 }
688 
689 
690 void main() { gl_FragColor = frag(); }
691   
2 #define USE_INSTANCING 1  
3 #define USE_BATCHING 1  
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1  
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024  
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024  
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128  
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128  
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0  
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0  
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0  
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0  
13 #define CC_USE_SKINNING 1  
14 #define CC_USE_BAKED_ANIMATION 1  
15 #define CC_USE_LIGHTMAP 1  
16 #define CC_RECEIVE_SHADOW 1  
17 #define CC_USE_MORPH 1  
18 #define CC_MORPH_TARGET_COUNT 2  
19 #define CC_MORPH_PRECOMPUTED 1  
20 #define CC_MORPH_TARGET_HAS_POSITION 1  
21 #define CC_MORPH_TARGET_HAS_NORMAL 1  
22 #define CC_MORPH_TARGET_HAS_TANGENT 1  
23 #define USE_VERTEX_COLOR 1  
24 #define USE_NORMAL_MAP 1  
25 #define HAS_SECOND_UV 1  
26 #define CC_USE_IBL 0  
27 #define CC_USE_DIFFUSEMAP 0  
28 #define USE_REFLECTION_DENOISE 1  
29 #define CC_FORWARD_ADD 1  
30 #define CC_USE_HDR 1  
31 #define USE_ALBEDO_MAP 1  
32 #define ALBEDO_UV v_uv  
33 #define NORMAL_UV v_uv  
34 #define USE_PBR_MAP 1  
35 #define PBR_UV v_uv  
36 #define USE_METALLIC_ROUGHNESS_MAP 1  
37 #define METALLIC_ROUGHNESS_UV v_uv  
38 #define USE_OCCLUSION_MAP 1  
39 #define OCCLUSION_UV v_uv  
40 #define USE_EMISSIVE_MAP 1  
41 #define EMISSIVE_UV v_uv  
42 #define OCCLUSION_CHANNEL r  
43 #define ROUGHNESS_CHANNEL g  
44 #define METALLIC_CHANNEL b  
45 #define USE_ALPHA_TEST 1  
46 #define ALPHA_TEST_CHANNEL a  
47  
48 #ifdef GL_OES_standard_derivatives  
49 #extension GL_OES_standard_derivatives: enable  
50 #endif  
51  
52 #ifdef GL_EXT_shader_texture_lod  
53 #extension GL_EXT_shader_texture_lod: enable  
54 #endif  
55  
56 precision highp float;  
57 uniform highp vec4 cc_cameraPos;  
58   uniform mediump vec4 cc_mainLitDir;  
59   uniform mediump vec4 cc_mainLitColor;  
60   uniform mediump vec4 cc_ambientSky;  
61   uniform mediump vec4 cc_ambientGround;  
62  
63  
64  
65  
66  
67  
68 #define QUATER_PI         0.78539816340  
69 #define HALF_PI           1.57079632679  
70 #define PI                3.14159265359  
71 #define PI2               6.28318530718  
72 #define PI4               12.5663706144  
73  
74 #define INV_QUATER_PI     1.27323954474  
75 #define INV_HALF_PI       0.63661977237  
76 #define INV_PI            0.31830988618  
77 #define INV_PI2           0.15915494309  
78 #define INV_PI4           0.07957747155  
79  
80 #define EPSILON           1e-6  
81 #define EPSILON_LOWP      1e-4  
82 #define LOG2              1.442695  
83 #define EXP_VALUE         2.71828183f  
84 #define FP_MAX            65504.0  
85 #define FP_SCALE          0.0009765625  
86 #define FP_SCALE_INV      1024.0  
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)  
88  
89  
90  
91  
92  
93  
94  
95 vec3 SRGBToLinear (vec3 gamma) {  
96   return gamma * gamma;  
97 }  
98 uniform highp mat4 cc_matLightView;  
99   uniform highp vec4 cc_shadowProjDepthInfo;  
100   uniform highp vec4 cc_shadowProjInfo;  
101   uniform mediump vec4 cc_shadowNFLSInfo;  
102   uniform mediump vec4 cc_shadowWHPBInfo;  
103   uniform mediump vec4 cc_shadowLPNNInfo;  
104  
105  
106  
107  
108  
109  
110  
111  
112 highp float unpackHighpData (float mainPart, float modPart) {  
113   highp float data = mainPart;  
114   return data + modPart;  
115 }  
116  
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {  
118   highp float data = mainPart * modValue;  
119   return data + modPart * modValue;  
120 }  
121  
122  
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {  
124   highp vec2 data = mainPart;  
125   return data + modPart;  
126 }  
127  
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {  
129   highp vec2 data = mainPart * modValue;  
130   return data + modPart * modValue;  
131 }  
132  
133  
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {  
135   highp vec3 data = mainPart;  
136   return data + modPart;  
137 }  
138  
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {  
140   highp vec3 data = mainPart * modValue;  
141   return data + modPart * modValue;  
142 }  
143  
144  
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {  
146   highp vec4 data = mainPart;  
147   return data + modPart;  
148 }  
149  
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {  
151   highp vec4 data = mainPart * modValue;  
152   return data + modPart * modValue;  
153 }  
154 #if CC_RECEIVE_SHADOW  
155   uniform highp sampler2D cc_shadowMap;  
156   uniform highp sampler2D cc_spotLightingMap;  
157  
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)  
159   {  
160     vec4 newShadowPos = shadowPos;  
161     if(normalBias > EPSILON_LOWP)  
162     {  
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);  
164       if(viewNormal.z < 0.1)  
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);  
166     }  
167     return newShadowPos;  
168   }  
169  
170  
171  
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)  
173   {  
174     float coeffA = cc_shadowProjDepthInfo.x;  
175     float coeffB = cc_shadowProjDepthInfo.y;  
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;  
177     viewSpacePos_z += viewspaceDepthBias;  
178     vec4 result = shadowPos;  
179     result.z = viewSpacePos_z * coeffA + coeffB;  
180     return result;  
181   }  
182  
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {  
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
190  
191     float shadow = 0.0;  
192     float closestDepth = 0.0;  
193     if (cc_shadowLPNNInfo.y > EPSILON) {  
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));  
195     } else {  
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;  
197     }  
198     shadow = step(clipPos.z, closestDepth);  
199  
200     return shadow;  
201   }  
202  
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {  
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
210  
211     float offsetDepth = clipPos.z;  
212     vec2 mapSize = cc_shadowWHPBInfo.xy;  
213     vec2 oneTap = 1.0 / mapSize;  
214     vec2 clipPos_offset = clipPos.xy + oneTap;  
215  
216     float block0, block1, block2, block3;  
217     if (cc_shadowLPNNInfo.y > EPSILON) {  
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
222     } else {  
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);  
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);  
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);  
227     }  
228  
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;  
230     float resultX = mix(block0, block1, coefX);  
231     float resultY = mix(block2, block3, coefX);  
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;  
233  
234     return mix(resultX, resultY, coefY);  
235   }  
236  
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {  
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
244  
245     float offsetDepth = clipPos.z;  
246     vec2 mapSize = cc_shadowWHPBInfo.xy;  
247     vec2 oneTap = 1.0 / mapSize;  
248     float clipPos_offset_L = clipPos.x - oneTap.x;  
249     float clipPos_offset_R = clipPos.x + oneTap.x;  
250     float clipPos_offset_U = clipPos.y - oneTap.y;  
251     float clipPos_offset_D = clipPos.y + oneTap.y;  
252  
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;  
254     if (cc_shadowLPNNInfo.y > EPSILON) {  
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
264     } else {  
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);  
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);  
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);  
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);  
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);  
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);  
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);  
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);  
274     }  
275  
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;  
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;  
278  
279     float shadow = 0.0;  
280     float resultX = mix(block0, block1, coefX);  
281     float resultY = mix(block3, block4, coefX);  
282     shadow += mix(resultX , resultY, coefY);  
283  
284     resultX = mix(block1, block2, coefX);  
285     resultY = mix(block4, block5, coefX);  
286     shadow += mix(resultX , resultY, coefY);  
287  
288     resultX = mix(block3, block4, coefX);  
289     resultY = mix(block6, block7, coefX);  
290     shadow += mix(resultX, resultY, coefY);  
291  
292     resultX = mix(block4, block5, coefX);  
293     resultY = mix(block7, block8, coefX);  
294     shadow += mix(resultX, resultY, coefY);  
295  
296     return shadow * 0.25;  
297   }  
298  
299  
300  
301  
302  
303  
304  
305  
306  
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)  
308 {  
309   float realtimeShadow = 1.0;  
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);  
311  
312   float pcf = cc_shadowWHPBInfo.z;  
313   if (pcf > 1.9) {  
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);  
315   }else if (pcf > 0.9) {  
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);  
317   }else {  
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);  
319   }  
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);  
321 }  
322 #endif  
323  
324  
325  
326 #if CC_USE_IBL  
327   uniform samplerCube cc_environment;  
328  
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {  
330  
331       #ifdef GL_EXT_shader_texture_lod  
332         return texture2DLodEXT(tex, coord, lod);  
333       #else  
334         return texture2D(tex, coord, lod);  
335       #endif  
336  
337   }  
338  
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {  
340  
341       #ifdef GL_EXT_shader_texture_lod  
342         return textureCubeLodEXT(tex, coord, lod);  
343       #else  
344         return textureCube(tex, coord, lod);  
345       #endif  
346  
347   }  
348  
349  
350  
351  
352  
353  
354  
355   vec3 unpackRGBE (vec4 rgbe) {  
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);  
357   }  
358  
359  
360   #if CC_USE_DIFFUSEMAP  
361     uniform samplerCube cc_diffuseMap;  
362   #endif  
363 #endif  
364  
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {  
366   vec3 NxH = cross(N, H);  
367   float OneMinusNoHSqr = dot(NxH, NxH);  
368   float a = roughness * roughness;  
369   float n = NoH * a;  
370   float p = a / (OneMinusNoHSqr + n * n);  
371   return p * p;  
372 }  
373  
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {  
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);  
376 }  
377  
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {  
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);  
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);  
381   vec4 r = roughness * c0 + c1;  
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;  
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;  
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);  
385   return specular * AB.x + AB.y;  
386 }  
387  
388 #if USE_REFLECTION_DENOISE  
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {  
390     #if CC_USE_IBL  
391     	float mip = roughness * mipCount;  
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;  
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));  
394  
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);  
396      	vec4 filtered = textureCube(cc_environment, R);  
397  
398       #if CC_USE_IBL == 2  
399       	biased.rgb = unpackRGBE(biased);  
400       	filtered.rgb = unpackRGBE(filtered);  
401       #else  
402       	biased.rgb = SRGBToLinear(biased.rgb);  
403       	filtered.rgb = SRGBToLinear(filtered.rgb);  
404       #endif  
405  
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);  
407     #else  
408       return vec3(0.0, 0.0, 0.0);  
409     #endif  
410   }  
411 #endif  
412  
413  
414 struct StandardSurface {  
415   vec4 albedo;  
416  
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
418   vec3 position, position_fract_part;  
419   #else  
420   vec3 position;  
421   #endif  
422   vec3 normal;  
423   vec3 emissive;  
424   vec3 lightmap;  
425   float lightmap_test;  
426   float roughness;  
427   float metallic;  
428   float occlusion;  
429   float specularIntensity;  
430  
431   #if CC_RECEIVE_SHADOW  
432     vec2 shadowBias;  
433   #endif  
434 };  
435  
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {  
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);  
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);  
440  
441   vec3 position;  
442  
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
444   position = unpackHighpData(s.position, s.position_fract_part);  
445   #else  
446   position = s.position;  
447   #endif  
448  
449   vec3 N = normalize(s.normal);  
450   vec3 V = normalize(cc_cameraPos.xyz - position);  
451  
452   float NV = max(abs(dot(N, V)), 0.0);  
453   specular = BRDFApprox(specular, s.roughness, NV);  
454  
455   vec3 L = normalize(-cc_mainLitDir.xyz);  
456   vec3 H = normalize(L + V);  
457   float NH = max(dot(N, H), 0.0);  
458   float NL = max(dot(N, L), 0.0);  
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;  
460   vec3 diffuseContrib = diffuse / PI;  
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);  
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);  
463  
464   float shadow = 1.0;  
465   #if CC_RECEIVE_SHADOW  
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {  
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);  
468     }  
469   #endif  
470  
471   dirlightContrib *= shadow;  
472   finalColor *= dirlightContrib;  
473  
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD  
475     if (s.lightmap_test > EPSILON_LOWP) {  
476       finalColor = diffuse * s.lightmap.rgb * shadow;  
477     }  
478   #endif  
479  
480   float fAmb = 0.5 - N.y * 0.5;  
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);  
482  
483  
484   #if CC_USE_IBL  
485     #if CC_USE_DIFFUSEMAP  
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);  
487       #if CC_USE_DIFFUSEMAP == 2  
488         ambDiff = unpackRGBE(diffuseMap);  
489       #else  
490         ambDiff = SRGBToLinear(diffuseMap.rgb);  
491       #endif  
492     #endif  
493  
494     vec3 R = normalize(reflect(-V, N));  
495  
496     #if USE_REFLECTION_DENOISE  
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);  
498     #else  
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);  
500  
501       #if CC_USE_IBL == 2  
502         vec3 env = unpackRGBE(envmap);  
503       #else  
504         vec3 env = SRGBToLinear(envmap.rgb);  
505       #endif  
506     #endif  
507  
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;  
509   #endif  
510  
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;  
512  
513  
514   finalColor += s.emissive;  
515  
516   return vec4(finalColor, s.albedo.a);  
517 }  
518  
519  
520  
521 vec3 ACESToneMap (vec3 color) {  
522   color = min(color, vec3(8.0));  
523   const float A = 2.51;  
524   const float B = 0.03;  
525   const float C = 2.43;  
526   const float D = 0.59;  
527   const float E = 0.14;  
528   return (color * (A * color + B)) / (color * (C * color + D) + E);  
529 }  
530  
531  
532  
533 vec4 CCFragOutput (vec4 color) {  
534   #if CC_USE_HDR  
535     color.rgb = ACESToneMap(color.rgb);  
536   #endif  
537   color.rgb = sqrt(color.rgb);  
538   return color;  
539 }  
540  
541  
542  
543      uniform vec4 rimColor;  
544      uniform vec4 albedo;  
545      uniform vec4 albedoScaleAndCutoff;  
546      uniform vec4 pbrParams;  
547      uniform vec4 emissive;  
548      uniform vec4 emissiveScaleParam;  
549  
550  
551  
552  
553 varying highp vec4 v_shadowPos;  
554  
555  
556  
557 #if CC_RECEIVE_SHADOW  
558  
559  
560  
561 #endif  
562  
563  
564 varying vec3 v_position;  
565 varying vec3 v_view_position;  
566 varying vec2 v_uv;  
567 varying vec2 v_uv1;  
568 varying vec3 v_normal;  
569 varying vec3 v_view_normal;  
570 varying vec4 v_shadowPos;  
571  
572 #if USE_VERTEX_COLOR  
573   varying vec3 v_color;  
574 #endif  
575  
576 #if USE_ALBEDO_MAP  
577   uniform sampler2D albedoMap;  
578 #endif  
579 #if USE_NORMAL_MAP  
580   varying vec3 v_tangent;  
581   varying vec3 v_bitangent;  
582   uniform sampler2D normalMap;  
583 #endif  
584 #if USE_PBR_MAP  
585   uniform sampler2D pbrMap;  
586 #endif  
587 #if USE_METALLIC_ROUGHNESS_MAP  
588   uniform sampler2D metallicRoughnessMap;  
589 #endif  
590 #if USE_OCCLUSION_MAP  
591   uniform sampler2D occlusionMap;  
592 #endif  
593 #if USE_EMISSIVE_MAP  
594   uniform sampler2D emissiveMap;  
595 #endif  
596 #if CC_USE_LIGHTMAP  
597   varying vec2 v_luv;  
598   uniform sampler2D cc_lightingMap;  
599 #endif  
600 #if USE_ALPHA_TEST  
601 #endif  
602  
603 void surf (out StandardSurface s) {  
604   vec4 baseColor = albedo;  
605   #if USE_VERTEX_COLOR  
606     baseColor.rgb *= v_color;  
607   #endif  
608   #if USE_ALBEDO_MAP  
609     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);  
610     texColor.rgb = SRGBToLinear(texColor.rgb);  
611     baseColor *= texColor;  
612   #endif  
613   s.albedo = baseColor;  
614   s.albedo.rgb *= albedoScaleAndCutoff.xyz;  
615  
616   #if USE_ALPHA_TEST  
617     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;  
618   #endif  
619   float density = 0.001;  
620   float dist2 = dot(v_view_position,v_view_position);  
621   float fogFactor = exp( -density*density * dist2);  
622   fogFactor = clamp(fogFactor, 0.0, 1.0);  
623  
624   vec3 fogColor = vec3(1.0,1,1.0);  
625   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);  
626  
627   s.normal = v_normal;  
628   #if USE_NORMAL_MAP  
629     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);  
630     s.normal =  
631       (nmmp.x * pbrParams.w) * normalize(v_tangent) +  
632       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +  
633       nmmp.z * normalize(s.normal);  
634   #endif  
635  
636   s.position = v_position;  
637  
638   vec4 pbr = pbrParams;  
639   #if USE_PBR_MAP  
640     vec4 res = texture2D(pbrMap, PBR_UV);  
641     pbr.x *= res.OCCLUSION_CHANNEL;  
642     pbr.y *= res.ROUGHNESS_CHANNEL;  
643     pbr.z *= res.METALLIC_CHANNEL;  
644   #endif  
645   #if USE_METALLIC_ROUGHNESS_MAP  
646     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);  
647     pbr.z *= metallicRoughness.METALLIC_CHANNEL;  
648     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;  
649   #endif  
650   #if USE_OCCLUSION_MAP  
651     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;  
652   #endif  
653   s.occlusion = clamp(pbr.x, 0.0, 0.96);  
654   s.roughness = clamp(pbr.y, 0.04, 1.0);  
655   s.specularIntensity = 0.5;  
656   s.metallic = pbr.z;  
657  
658   s.emissive = emissive.rgb * emissiveScaleParam.xyz;  
659   #if USE_EMISSIVE_MAP  
660     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);  
661   #endif  
662 }  
663  
664 vec4 frag () {  
665   StandardSurface s; surf(s);  
666   vec4 color = CCStandardShadingBase(s, v_shadowPos);  
667  
668   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING  
669     vec4 lighting = texture2D(cc_lightingMap, v_luv);  
670  
671     float fAmb = 0.5 - s.normal.y * 0.5;  
672     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;  
673  
674     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);  
675     finalColor += lighting.rgb *  s.albedo.rgb;  
676     finalColor = finalColor * s.occlusion;  
677     finalColor += s.emissive;  
678  
679     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;  
680   #endif  
681  
682   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;  
683  
684   color.rgb = mix(color.rgb,rimColor.rgb,fRim);  
685  
686   return CCFragOutput(color);  
687 }  
688  
689  
690 void main() { gl_FragColor = frag(); }  
691  
at Object.encode (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-worker/node_modules/v-stacks/index.js:14:17)  
at Logger._logHandler (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-worker/static/script.ccc:1:531)  
at Logger.record (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:458)  
at console.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:1414)  
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)  
at async ParallelQueue._generate (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/asset-db.ccc:1:2165)
2022-06-23T02:42:21.462Z - error: [Asset DB] ../res/rim_light.effect - standard-fs:frag: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:570: 'v_shadowPos' : redefinition
 

1 #version 100
2 #define USE_INSTANCING 1
3 #define USE_BATCHING 1
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
13 #define CC_USE_SKINNING 1
14 #define CC_USE_BAKED_ANIMATION 1
15 #define CC_USE_LIGHTMAP 1
16 #define CC_RECEIVE_SHADOW 1
17 #define CC_USE_MORPH 1
18 #define CC_MORPH_TARGET_COUNT 2
19 #define CC_MORPH_PRECOMPUTED 1
20 #define CC_MORPH_TARGET_HAS_POSITION 1
21 #define CC_MORPH_TARGET_HAS_NORMAL 1
22 #define CC_MORPH_TARGET_HAS_TANGENT 1
23 #define USE_VERTEX_COLOR 1
24 #define USE_NORMAL_MAP 1
25 #define HAS_SECOND_UV 1
26 #define CC_USE_IBL 0
27 #define CC_USE_DIFFUSEMAP 0
28 #define USE_REFLECTION_DENOISE 1
29 #define CC_FORWARD_ADD 1
30 #define CC_USE_HDR 1
31 #define USE_ALBEDO_MAP 1
32 #define ALBEDO_UV v_uv
33 #define NORMAL_UV v_uv
34 #define USE_PBR_MAP 1
35 #define PBR_UV v_uv
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define METALLIC_ROUGHNESS_UV v_uv
38 #define USE_OCCLUSION_MAP 1
39 #define OCCLUSION_UV v_uv
40 #define USE_EMISSIVE_MAP 1
41 #define EMISSIVE_UV v_uv
42 #define OCCLUSION_CHANNEL r
43 #define ROUGHNESS_CHANNEL g
44 #define METALLIC_CHANNEL b
45 #define USE_ALPHA_TEST 1
46 #define ALPHA_TEST_CHANNEL a
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp vec4 cc_cameraPos;
58   uniform mediump vec4 cc_mainLitDir;
59   uniform mediump vec4 cc_mainLitColor;
60   uniform mediump vec4 cc_ambientSky;
61   uniform mediump vec4 cc_ambientGround;
62 
63 
64 
65 
66 
67 
68 #define QUATER_PI         0.78539816340
69 #define HALF_PI           1.57079632679
70 #define PI                3.14159265359
71 #define PI2               6.28318530718
72 #define PI4               12.5663706144
73      
74 #define INV_QUATER_PI     1.27323954474
75 #define INV_HALF_PI       0.63661977237
76 #define INV_PI            0.31830988618
77 #define INV_PI2           0.15915494309
78 #define INV_PI4           0.07957747155
79      
80 #define EPSILON           1e-6
81 #define EPSILON_LOWP      1e-4
82 #define LOG2              1.442695
83 #define EXP_VALUE         2.71828183f
84 #define FP_MAX            65504.0
85 #define FP_SCALE          0.0009765625
86 #define FP_SCALE_INV      1024.0
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
88 
89 
90 
91 
92 
93 
94 
95 vec3 SRGBToLinear (vec3 gamma) {
96   return gamma * gamma;
97 }
98 uniform highp mat4 cc_matLightView;
99   uniform highp vec4 cc_shadowProjDepthInfo;
100   uniform highp vec4 cc_shadowProjInfo;
101   uniform mediump vec4 cc_shadowNFLSInfo;
102   uniform mediump vec4 cc_shadowWHPBInfo;
103   uniform mediump vec4 cc_shadowLPNNInfo;
104 
105 
106 
107 
108 
109 
110 
111 
112 highp float unpackHighpData (float mainPart, float modPart) {
113   highp float data = mainPart;
114   return data + modPart;
115 }
116 
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
118   highp float data = mainPart * modValue;
119   return data + modPart * modValue;
120 }
121 
122 
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
124   highp vec2 data = mainPart;
125   return data + modPart;
126 }
127 
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
129   highp vec2 data = mainPart * modValue;
130   return data + modPart * modValue;
131 }
132 
133 
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
135   highp vec3 data = mainPart;
136   return data + modPart;
137 }
138 
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
140   highp vec3 data = mainPart * modValue;
141   return data + modPart * modValue;
142 }
143 
144 
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
146   highp vec4 data = mainPart;
147   return data + modPart;
148 }
149 
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
151   highp vec4 data = mainPart * modValue;
152   return data + modPart * modValue;
153 }
154 #if CC_RECEIVE_SHADOW
155   uniform highp sampler2D cc_shadowMap;
156   uniform highp sampler2D cc_spotLightingMap;
157 
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
159   {
160     vec4 newShadowPos = shadowPos;
161     if(normalBias > EPSILON_LOWP)
162     {
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
164       if(viewNormal.z < 0.1)
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
166     }
167     return newShadowPos;
168   }
169   
170   
171 
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
173   {
174     float coeffA = cc_shadowProjDepthInfo.x;
175     float coeffB = cc_shadowProjDepthInfo.y;
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
177     viewSpacePos_z += viewspaceDepthBias;
178     vec4 result = shadowPos;
179     result.z = viewSpacePos_z * coeffA + coeffB;
180     return result;
181   }
182   
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
190 
191     float shadow = 0.0;
192     float closestDepth = 0.0;
193     if (cc_shadowLPNNInfo.y > EPSILON) {
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
195     } else {
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
197     }
198     shadow = step(clipPos.z, closestDepth);
199 
200     return shadow;
201   }
202 
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
210 
211     float offsetDepth = clipPos.z;
212     vec2 mapSize = cc_shadowWHPBInfo.xy;
213     vec2 oneTap = 1.0 / mapSize;
214     vec2 clipPos_offset = clipPos.xy + oneTap;
215 
216     float block0, block1, block2, block3;
217     if (cc_shadowLPNNInfo.y > EPSILON) {
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
222     } else {
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
227     }
228 
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
230     float resultX = mix(block0, block1, coefX);
231     float resultY = mix(block2, block3, coefX);
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
233 
234     return mix(resultX, resultY, coefY);
235   }
236 
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
244 
245     float offsetDepth = clipPos.z;
246     vec2 mapSize = cc_shadowWHPBInfo.xy;
247     vec2 oneTap = 1.0 / mapSize;
248     float clipPos_offset_L = clipPos.x - oneTap.x;
249     float clipPos_offset_R = clipPos.x + oneTap.x;
250     float clipPos_offset_U = clipPos.y - oneTap.y;
251     float clipPos_offset_D = clipPos.y + oneTap.y;
252 
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
254     if (cc_shadowLPNNInfo.y > EPSILON) {
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
264     } else {
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
274     }
275 
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
278 
279     float shadow = 0.0;
280     float resultX = mix(block0, block1, coefX);
281     float resultY = mix(block3, block4, coefX);
282     shadow += mix(resultX , resultY, coefY);
283 
284     resultX = mix(block1, block2, coefX);
285     resultY = mix(block4, block5, coefX);
286     shadow += mix(resultX , resultY, coefY);
287 
288     resultX = mix(block3, block4, coefX);
289     resultY = mix(block6, block7, coefX);
290     shadow += mix(resultX, resultY, coefY);
291 
292     resultX = mix(block4, block5, coefX);
293     resultY = mix(block7, block8, coefX);
294     shadow += mix(resultX, resultY, coefY);
295 
296     return shadow * 0.25;
297   }
298 
299   
300 
301   
302 
303   
304 
305 
306 
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
308 {
309   float realtimeShadow = 1.0;
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
311   
312   float pcf = cc_shadowWHPBInfo.z;
313   if (pcf > 1.9) { 
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
315   }else if (pcf > 0.9) {
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
317   }else { 
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
319   }
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
321 }
322 #endif
323 
324 
325 
326 #if CC_USE_IBL
327   uniform samplerCube cc_environment;
328   
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
330     
331       #ifdef GL_EXT_shader_texture_lod
332         return texture2DLodEXT(tex, coord, lod);
333       #else
334         return texture2D(tex, coord, lod);
335       #endif
336     
337   }
338   
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
340     
341       #ifdef GL_EXT_shader_texture_lod
342         return textureCubeLodEXT(tex, coord, lod);
343       #else
344         return textureCube(tex, coord, lod);
345       #endif
346     
347   }
348   
349   
350   
351   
352   
353   
354   
355   vec3 unpackRGBE (vec4 rgbe) {
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
357   }
358   
359 
360   #if CC_USE_DIFFUSEMAP
361     uniform samplerCube cc_diffuseMap;
362   #endif
363 #endif
364 
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
366   vec3 NxH = cross(N, H);
367   float OneMinusNoHSqr = dot(NxH, NxH);
368   float a = roughness * roughness;
369   float n = NoH * a;
370   float p = a / (OneMinusNoHSqr + n * n);
371   return p * p;
372 }
373 
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
376 }
377 
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
381   vec4 r = roughness * c0 + c1;
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
385   return specular * AB.x + AB.y;
386 }
387 
388 #if USE_REFLECTION_DENOISE
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
390     #if CC_USE_IBL
391     	float mip = roughness * mipCount;
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
394 
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
396      	vec4 filtered = textureCube(cc_environment, R);
397 
398       #if CC_USE_IBL == 2
399       	biased.rgb = unpackRGBE(biased);
400       	filtered.rgb = unpackRGBE(filtered);
401       #else
402       	biased.rgb = SRGBToLinear(biased.rgb);
403       	filtered.rgb = SRGBToLinear(filtered.rgb);
404       #endif
405       	
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
407     #else
408       return vec3(0.0, 0.0, 0.0);
409     #endif
410   }
411 #endif
412 
413 
414 struct StandardSurface {
415   vec4 albedo;
416   
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
418   vec3 position, position_fract_part;
419   #else
420   vec3 position;
421   #endif
422   vec3 normal;
423   vec3 emissive;
424   vec3 lightmap;
425   float lightmap_test;
426   float roughness;
427   float metallic;
428   float occlusion;
429   float specularIntensity;
430 
431   #if CC_RECEIVE_SHADOW
432     vec2 shadowBias;
433   #endif
434 };
435 
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
440 
441   vec3 position;
442   
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
444   position = unpackHighpData(s.position, s.position_fract_part);
445   #else
446   position = s.position;
447   #endif
448 
449   vec3 N = normalize(s.normal);
450   vec3 V = normalize(cc_cameraPos.xyz - position);
451 
452   float NV = max(abs(dot(N, V)), 0.0);
453   specular = BRDFApprox(specular, s.roughness, NV);
454 
455   vec3 L = normalize(-cc_mainLitDir.xyz);
456   vec3 H = normalize(L + V);
457   float NH = max(dot(N, H), 0.0);
458   float NL = max(dot(N, L), 0.0);
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
460   vec3 diffuseContrib = diffuse / PI;
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);
463 
464   float shadow = 1.0;
465   #if CC_RECEIVE_SHADOW
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
468     }
469   #endif
470 
471   dirlightContrib *= shadow;
472   finalColor *= dirlightContrib;
473 
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
475     if (s.lightmap_test > EPSILON_LOWP) {
476       finalColor = diffuse * s.lightmap.rgb * shadow;
477     }
478   #endif
479 
480   float fAmb = 0.5 - N.y * 0.5;
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
482 
483 
484   #if CC_USE_IBL
485     #if CC_USE_DIFFUSEMAP
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
487       #if CC_USE_DIFFUSEMAP == 2
488         ambDiff = unpackRGBE(diffuseMap);
489       #else
490         ambDiff = SRGBToLinear(diffuseMap.rgb);
491       #endif
492     #endif
493 
494     vec3 R = normalize(reflect(-V, N));
495 
496     #if USE_REFLECTION_DENOISE
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
498     #else
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
500 
501       #if CC_USE_IBL == 2
502         vec3 env = unpackRGBE(envmap);
503       #else
504         vec3 env = SRGBToLinear(envmap.rgb);
505       #endif
506     #endif
507 
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
509   #endif
510 
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
512   
513 
514   finalColor += s.emissive;
515 
516   return vec4(finalColor, s.albedo.a);
517 }
518 
519 
520 
521 vec3 ACESToneMap (vec3 color) {
522   color = min(color, vec3(8.0));
523   const float A = 2.51;
524   const float B = 0.03;
525   const float C = 2.43;
526   const float D = 0.59;
527   const float E = 0.14;
528   return (color * (A * color + B)) / (color * (C * color + D) + E);
529 }
530 
531 
532 
533 vec4 CCFragOutput (vec4 color) {
534   #if CC_USE_HDR
535     color.rgb = ACESToneMap(color.rgb);
536   #endif
537   color.rgb = sqrt(color.rgb);
538   return color;
539 }
540 
541 
542 
543      uniform vec4 rimColor;
544      uniform vec4 albedo;
545      uniform vec4 albedoScaleAndCutoff;
546      uniform vec4 pbrParams;
547      uniform vec4 emissive;
548      uniform vec4 emissiveScaleParam;
549 
550 
551 
552 
553 varying highp vec4 v_shadowPos;
554 
555 
556 
557 #if CC_RECEIVE_SHADOW
558 
559 
560 
561 #endif
562 
563 
564 varying vec3 v_position;
565 varying vec3 v_view_position;
566 varying vec2 v_uv;
567 varying vec2 v_uv1;
568 varying vec3 v_normal;
569 varying vec3 v_view_normal;
570 varying vec4 v_shadowPos;
571 
572 #if USE_VERTEX_COLOR
573   varying vec3 v_color;
574 #endif
575 
576 #if USE_ALBEDO_MAP
577   uniform sampler2D albedoMap;
578 #endif
579 #if USE_NORMAL_MAP
580   varying vec3 v_tangent;
581   varying vec3 v_bitangent;
582   uniform sampler2D normalMap;
583 #endif
584 #if USE_PBR_MAP
585   uniform sampler2D pbrMap;
586 #endif
587 #if USE_METALLIC_ROUGHNESS_MAP
588   uniform sampler2D metallicRoughnessMap;
589 #endif
590 #if USE_OCCLUSION_MAP
591   uniform sampler2D occlusionMap;
592 #endif
593 #if USE_EMISSIVE_MAP
594   uniform sampler2D emissiveMap;
595 #endif
596 #if CC_USE_LIGHTMAP
597   varying vec2 v_luv;
598   uniform sampler2D cc_lightingMap;
599 #endif
600 #if USE_ALPHA_TEST
601 #endif
602 
603 void surf (out StandardSurface s) {
604   vec4 baseColor = albedo;
605   #if USE_VERTEX_COLOR
606     baseColor.rgb *= v_color;
607   #endif
608   #if USE_ALBEDO_MAP
609     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);
610     texColor.rgb = SRGBToLinear(texColor.rgb);
611     baseColor *= texColor;
612   #endif
613   s.albedo = baseColor;
614   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
615 
616   #if USE_ALPHA_TEST
617     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
618   #endif
619   float density = 0.001;
620   float dist2 = dot(v_view_position,v_view_position);
621   float fogFactor = exp( -density*density * dist2);
622   fogFactor = clamp(fogFactor, 0.0, 1.0);
623 
624   vec3 fogColor = vec3(1.0,1,1.0);
625   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);
626 
627   s.normal = v_normal;
628   #if USE_NORMAL_MAP
629     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);
630     s.normal =
631       (nmmp.x * pbrParams.w) * normalize(v_tangent) +
632       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +
633       nmmp.z * normalize(s.normal);
634   #endif
635 
636   s.position = v_position;
637 
638   vec4 pbr = pbrParams;
639   #if USE_PBR_MAP
640     vec4 res = texture2D(pbrMap, PBR_UV);
641     pbr.x *= res.OCCLUSION_CHANNEL;
642     pbr.y *= res.ROUGHNESS_CHANNEL;
643     pbr.z *= res.METALLIC_CHANNEL;
644   #endif
645   #if USE_METALLIC_ROUGHNESS_MAP
646     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);
647     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
648     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
649   #endif
650   #if USE_OCCLUSION_MAP
651     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;
652   #endif
653   s.occlusion = clamp(pbr.x, 0.0, 0.96);
654   s.roughness = clamp(pbr.y, 0.04, 1.0);
655   s.specularIntensity = 0.5;
656   s.metallic = pbr.z;
657 
658   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
659   #if USE_EMISSIVE_MAP
660     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);
661   #endif
662 }
663 
664 vec4 frag () {
665   StandardSurface s; surf(s);
666   vec4 color = CCStandardShadingBase(s, v_shadowPos);
667 
668   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING
669     vec4 lighting = texture2D(cc_lightingMap, v_luv);
670 
671     float fAmb = 0.5 - s.normal.y * 0.5;
672     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
673 
674     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);
675     finalColor += lighting.rgb *  s.albedo.rgb;
676     finalColor = finalColor * s.occlusion;
677     finalColor += s.emissive;
678 
679     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;
680   #endif
681 
682   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;
683 
684   color.rgb = mix(color.rgb,rimColor.rgb,fRim);
685 
686   return CCFragOutput(color);
687 }
688 
689 
690 void main() { gl_FragColor = frag(); }
691 [Asset DB] ../res/rim_light.effect - standard-fs:frag: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:570: 'v_shadowPos' : redefinition
 

1 #version 100
2 #define USE_INSTANCING 1
3 #define USE_BATCHING 1
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
13 #define CC_USE_SKINNING 1
14 #define CC_USE_BAKED_ANIMATION 1
15 #define CC_USE_LIGHTMAP 1
16 #define CC_RECEIVE_SHADOW 1
17 #define CC_USE_MORPH 1
18 #define CC_MORPH_TARGET_COUNT 2
19 #define CC_MORPH_PRECOMPUTED 1
20 #define CC_MORPH_TARGET_HAS_POSITION 1
21 #define CC_MORPH_TARGET_HAS_NORMAL 1
22 #define CC_MORPH_TARGET_HAS_TANGENT 1
23 #define USE_VERTEX_COLOR 1
24 #define USE_NORMAL_MAP 1
25 #define HAS_SECOND_UV 1
26 #define CC_USE_IBL 0
27 #define CC_USE_DIFFUSEMAP 0
28 #define USE_REFLECTION_DENOISE 1
29 #define CC_FORWARD_ADD 1
30 #define CC_USE_HDR 1
31 #define USE_ALBEDO_MAP 1
32 #define ALBEDO_UV v_uv
33 #define NORMAL_UV v_uv
34 #define USE_PBR_MAP 1
35 #define PBR_UV v_uv
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define METALLIC_ROUGHNESS_UV v_uv
38 #define USE_OCCLUSION_MAP 1
39 #define OCCLUSION_UV v_uv
40 #define USE_EMISSIVE_MAP 1
41 #define EMISSIVE_UV v_uv
42 #define OCCLUSION_CHANNEL r
43 #define ROUGHNESS_CHANNEL g
44 #define METALLIC_CHANNEL b
45 #define USE_ALPHA_TEST 1
46 #define ALPHA_TEST_CHANNEL a
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp vec4 cc_cameraPos;
58   uniform mediump vec4 cc_mainLitDir;
59   uniform mediump vec4 cc_mainLitColor;
60   uniform mediump vec4 cc_ambientSky;
61   uniform mediump vec4 cc_ambientGround;
62 
63 
64 
65 
66 
67 
68 #define QUATER_PI         0.78539816340
69 #define HALF_PI           1.57079632679
70 #define PI                3.14159265359
71 #define PI2               6.28318530718
72 #define PI4               12.5663706144
73      
74 #define INV_QUATER_PI     1.27323954474
75 #define INV_HALF_PI       0.63661977237
76 #define INV_PI            0.31830988618
77 #define INV_PI2           0.15915494309
78 #define INV_PI4           0.07957747155
79      
80 #define EPSILON           1e-6
81 #define EPSILON_LOWP      1e-4
82 #define LOG2              1.442695
83 #define EXP_VALUE         2.71828183f
84 #define FP_MAX            65504.0
85 #define FP_SCALE          0.0009765625
86 #define FP_SCALE_INV      1024.0
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
88 
89 
90 
91 
92 
93 
94 
95 vec3 SRGBToLinear (vec3 gamma) {
96   return gamma * gamma;
97 }
98 uniform highp mat4 cc_matLightView;
99   uniform highp vec4 cc_shadowProjDepthInfo;
100   uniform highp vec4 cc_shadowProjInfo;
101   uniform mediump vec4 cc_shadowNFLSInfo;
102   uniform mediump vec4 cc_shadowWHPBInfo;
103   uniform mediump vec4 cc_shadowLPNNInfo;
104 
105 
106 
107 
108 
109 
110 
111 
112 highp float unpackHighpData (float mainPart, float modPart) {
113   highp float data = mainPart;
114   return data + modPart;
115 }
116 
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
118   highp float data = mainPart * modValue;
119   return data + modPart * modValue;
120 }
121 
122 
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
124   highp vec2 data = mainPart;
125   return data + modPart;
126 }
127 
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
129   highp vec2 data = mainPart * modValue;
130   return data + modPart * modValue;
131 }
132 
133 
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
135   highp vec3 data = mainPart;
136   return data + modPart;
137 }
138 
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
140   highp vec3 data = mainPart * modValue;
141   return data + modPart * modValue;
142 }
143 
144 
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
146   highp vec4 data = mainPart;
147   return data + modPart;
148 }
149 
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
151   highp vec4 data = mainPart * modValue;
152   return data + modPart * modValue;
153 }
154 #if CC_RECEIVE_SHADOW
155   uniform highp sampler2D cc_shadowMap;
156   uniform highp sampler2D cc_spotLightingMap;
157 
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
159   {
160     vec4 newShadowPos = shadowPos;
161     if(normalBias > EPSILON_LOWP)
162     {
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
164       if(viewNormal.z < 0.1)
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
166     }
167     return newShadowPos;
168   }
169   
170   
171 
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
173   {
174     float coeffA = cc_shadowProjDepthInfo.x;
175     float coeffB = cc_shadowProjDepthInfo.y;
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
177     viewSpacePos_z += viewspaceDepthBias;
178     vec4 result = shadowPos;
179     result.z = viewSpacePos_z * coeffA + coeffB;
180     return result;
181   }
182   
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
190 
191     float shadow = 0.0;
192     float closestDepth = 0.0;
193     if (cc_shadowLPNNInfo.y > EPSILON) {
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
195     } else {
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
197     }
198     shadow = step(clipPos.z, closestDepth);
199 
200     return shadow;
201   }
202 
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
210 
211     float offsetDepth = clipPos.z;
212     vec2 mapSize = cc_shadowWHPBInfo.xy;
213     vec2 oneTap = 1.0 / mapSize;
214     vec2 clipPos_offset = clipPos.xy + oneTap;
215 
216     float block0, block1, block2, block3;
217     if (cc_shadowLPNNInfo.y > EPSILON) {
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
222     } else {
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
227     }
228 
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
230     float resultX = mix(block0, block1, coefX);
231     float resultY = mix(block2, block3, coefX);
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
233 
234     return mix(resultX, resultY, coefY);
235   }
236 
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
244 
245     float offsetDepth = clipPos.z;
246     vec2 mapSize = cc_shadowWHPBInfo.xy;
247     vec2 oneTap = 1.0 / mapSize;
248     float clipPos_offset_L = clipPos.x - oneTap.x;
249     float clipPos_offset_R = clipPos.x + oneTap.x;
250     float clipPos_offset_U = clipPos.y - oneTap.y;
251     float clipPos_offset_D = clipPos.y + oneTap.y;
252 
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
254     if (cc_shadowLPNNInfo.y > EPSILON) {
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
264     } else {
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
274     }
275 
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
278 
279     float shadow = 0.0;
280     float resultX = mix(block0, block1, coefX);
281     float resultY = mix(block3, block4, coefX);
282     shadow += mix(resultX , resultY, coefY);
283 
284     resultX = mix(block1, block2, coefX);
285     resultY = mix(block4, block5, coefX);
286     shadow += mix(resultX , resultY, coefY);
287 
288     resultX = mix(block3, block4, coefX);
289     resultY = mix(block6, block7, coefX);
290     shadow += mix(resultX, resultY, coefY);
291 
292     resultX = mix(block4, block5, coefX);
293     resultY = mix(block7, block8, coefX);
294     shadow += mix(resultX, resultY, coefY);
295 
296     return shadow * 0.25;
297   }
298 
299   
300 
301   
302 
303   
304 
305 
306 
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
308 {
309   float realtimeShadow = 1.0;
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
311   
312   float pcf = cc_shadowWHPBInfo.z;
313   if (pcf > 1.9) { 
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
315   }else if (pcf > 0.9) {
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
317   }else { 
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
319   }
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
321 }
322 #endif
323 
324 
325 
326 #if CC_USE_IBL
327   uniform samplerCube cc_environment;
328   
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
330     
331       #ifdef GL_EXT_shader_texture_lod
332         return texture2DLodEXT(tex, coord, lod);
333       #else
334         return texture2D(tex, coord, lod);
335       #endif
336     
337   }
338   
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
340     
341       #ifdef GL_EXT_shader_texture_lod
342         return textureCubeLodEXT(tex, coord, lod);
343       #else
344         return textureCube(tex, coord, lod);
345       #endif
346     
347   }
348   
349   
350   
351   
352   
353   
354   
355   vec3 unpackRGBE (vec4 rgbe) {
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
357   }
358   
359 
360   #if CC_USE_DIFFUSEMAP
361     uniform samplerCube cc_diffuseMap;
362   #endif
363 #endif
364 
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
366   vec3 NxH = cross(N, H);
367   float OneMinusNoHSqr = dot(NxH, NxH);
368   float a = roughness * roughness;
369   float n = NoH * a;
370   float p = a / (OneMinusNoHSqr + n * n);
371   return p * p;
372 }
373 
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
376 }
377 
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
381   vec4 r = roughness * c0 + c1;
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
385   return specular * AB.x + AB.y;
386 }
387 
388 #if USE_REFLECTION_DENOISE
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
390     #if CC_USE_IBL
391     	float mip = roughness * mipCount;
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
394 
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
396      	vec4 filtered = textureCube(cc_environment, R);
397 
398       #if CC_USE_IBL == 2
399       	biased.rgb = unpackRGBE(biased);
400       	filtered.rgb = unpackRGBE(filtered);
401       #else
402       	biased.rgb = SRGBToLinear(biased.rgb);
403       	filtered.rgb = SRGBToLinear(filtered.rgb);
404       #endif
405       	
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
407     #else
408       return vec3(0.0, 0.0, 0.0);
409     #endif
410   }
411 #endif
412 
413 
414 struct StandardSurface {
415   vec4 albedo;
416   
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
418   vec3 position, position_fract_part;
419   #else
420   vec3 position;
421   #endif
422   vec3 normal;
423   vec3 emissive;
424   vec3 lightmap;
425   float lightmap_test;
426   float roughness;
427   float metallic;
428   float occlusion;
429   float specularIntensity;
430 
431   #if CC_RECEIVE_SHADOW
432     vec2 shadowBias;
433   #endif
434 };
435 
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
440 
441   vec3 position;
442   
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
444   position = unpackHighpData(s.position, s.position_fract_part);
445   #else
446   position = s.position;
447   #endif
448 
449   vec3 N = normalize(s.normal);
450   vec3 V = normalize(cc_cameraPos.xyz - position);
451 
452   float NV = max(abs(dot(N, V)), 0.0);
453   specular = BRDFApprox(specular, s.roughness, NV);
454 
455   vec3 L = normalize(-cc_mainLitDir.xyz);
456   vec3 H = normalize(L + V);
457   float NH = max(dot(N, H), 0.0);
458   float NL = max(dot(N, L), 0.0);
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
460   vec3 diffuseContrib = diffuse / PI;
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);
463 
464   float shadow = 1.0;
465   #if CC_RECEIVE_SHADOW
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
468     }
469   #endif
470 
471   dirlightContrib *= shadow;
472   finalColor *= dirlightContrib;
473 
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
475     if (s.lightmap_test > EPSILON_LOWP) {
476       finalColor = diffuse * s.lightmap.rgb * shadow;
477     }
478   #endif
479 
480   float fAmb = 0.5 - N.y * 0.5;
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
482 
483 
484   #if CC_USE_IBL
485     #if CC_USE_DIFFUSEMAP
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
487       #if CC_USE_DIFFUSEMAP == 2
488         ambDiff = unpackRGBE(diffuseMap);
489       #else
490         ambDiff = SRGBToLinear(diffuseMap.rgb);
491       #endif
492     #endif
493 
494     vec3 R = normalize(reflect(-V, N));
495 
496     #if USE_REFLECTION_DENOISE
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
498     #else
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
500 
501       #if CC_USE_IBL == 2
502         vec3 env = unpackRGBE(envmap);
503       #else
504         vec3 env = SRGBToLinear(envmap.rgb);
505       #endif
506     #endif
507 
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
509   #endif
510 
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
512   
513 
514   finalColor += s.emissive;
515 
516   return vec4(finalColor, s.albedo.a);
517 }
518 
519 
520 
521 vec3 ACESToneMap (vec3 color) {
522   color = min(color, vec3(8.0));
523   const float A = 2.51;
524   const float B = 0.03;
525   const float C = 2.43;
526   const float D = 0.59;
527   const float E = 0.14;
528   return (color * (A * color + B)) / (color * (C * color + D) + E);
529 }
530 
531 
532 
533 vec4 CCFragOutput (vec4 color) {
534   #if CC_USE_HDR
535     color.rgb = ACESToneMap(color.rgb);
536   #endif
537   color.rgb = sqrt(color.rgb);
538   return color;
539 }
540 
541 
542 
543      uniform vec4 rimColor;
544      uniform vec4 albedo;
545      uniform vec4 albedoScaleAndCutoff;
546      uniform vec4 pbrParams;
547      uniform vec4 emissive;
548      uniform vec4 emissiveScaleParam;
549 
550 
551 
552 
553 varying highp vec4 v_shadowPos;
554 
555 
556 
557 #if CC_RECEIVE_SHADOW
558 
559 
560 
561 #endif
562 
563 
564 varying vec3 v_position;
565 varying vec3 v_view_position;
566 varying vec2 v_uv;
567 varying vec2 v_uv1;
568 varying vec3 v_normal;
569 varying vec3 v_view_normal;
570 varying vec4 v_shadowPos;
571 
572 #if USE_VERTEX_COLOR
573   varying vec3 v_color;
574 #endif
575 
576 #if USE_ALBEDO_MAP
577   uniform sampler2D albedoMap;
578 #endif
579 #if USE_NORMAL_MAP
580   varying vec3 v_tangent;
581   varying vec3 v_bitangent;
582   uniform sampler2D normalMap;
583 #endif
584 #if USE_PBR_MAP
585   uniform sampler2D pbrMap;
586 #endif
587 #if USE_METALLIC_ROUGHNESS_MAP
588   uniform sampler2D metallicRoughnessMap;
589 #endif
590 #if USE_OCCLUSION_MAP
591   uniform sampler2D occlusionMap;
592 #endif
593 #if USE_EMISSIVE_MAP
594   uniform sampler2D emissiveMap;
595 #endif
596 #if CC_USE_LIGHTMAP
597   varying vec2 v_luv;
598   uniform sampler2D cc_lightingMap;
599 #endif
600 #if USE_ALPHA_TEST
601 #endif
602 
603 void surf (out StandardSurface s) {
604   vec4 baseColor = albedo;
605   #if USE_VERTEX_COLOR
606     baseColor.rgb *= v_color;
607   #endif
608   #if USE_ALBEDO_MAP
609     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);
610     texColor.rgb = SRGBToLinear(texColor.rgb);
611     baseColor *= texColor;
612   #endif
613   s.albedo = baseColor;
614   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
615 
616   #if USE_ALPHA_TEST
617     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
618   #endif
619   float density = 0.001;
620   float dist2 = dot(v_view_position,v_view_position);
621   float fogFactor = exp( -density*density * dist2);
622   fogFactor = clamp(fogFactor, 0.0, 1.0);
623 
624   vec3 fogColor = vec3(1.0,1,1.0);
625   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);
626 
627   s.normal = v_normal;
628   #if USE_NORMAL_MAP
629     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);
630     s.normal =
631       (nmmp.x * pbrParams.w) * normalize(v_tangent) +
632       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +
633       nmmp.z * normalize(s.normal);
634   #endif
635 
636   s.position = v_position;
637 
638   vec4 pbr = pbrParams;
639   #if USE_PBR_MAP
640     vec4 res = texture2D(pbrMap, PBR_UV);
641     pbr.x *= res.OCCLUSION_CHANNEL;
642     pbr.y *= res.ROUGHNESS_CHANNEL;
643     pbr.z *= res.METALLIC_CHANNEL;
644   #endif
645   #if USE_METALLIC_ROUGHNESS_MAP
646     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);
647     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
648     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
649   #endif
650   #if USE_OCCLUSION_MAP
651     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;
652   #endif
653   s.occlusion = clamp(pbr.x, 0.0, 0.96);
654   s.roughness = clamp(pbr.y, 0.04, 1.0);
655   s.specularIntensity = 0.5;
656   s.metallic = pbr.z;
657 
658   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
659   #if USE_EMISSIVE_MAP
660     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);
661   #endif
662 }
663 
664 vec4 frag () {
665   StandardSurface s; surf(s);
666   vec4 color = CCStandardShadingBase(s, v_shadowPos);
667 
668   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING
669     vec4 lighting = texture2D(cc_lightingMap, v_luv);
670 
671     float fAmb = 0.5 - s.normal.y * 0.5;
672     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
673 
674     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);
675     finalColor += lighting.rgb *  s.albedo.rgb;
676     finalColor = finalColor * s.occlusion;
677     finalColor += s.emissive;
678 
679     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;
680   #endif
681 
682   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;
683 
684   color.rgb = mix(color.rgb,rimColor.rgb,fRim);
685 
686   return CCFragOutput(color);
687 }
688 
689 
690 void main() { gl_FragColor = frag(); }
691   
2 #define USE_INSTANCING 1  
3 #define USE_BATCHING 1  
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1  
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024  
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024  
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128  
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128  
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0  
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0  
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0  
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0  
13 #define CC_USE_SKINNING 1  
14 #define CC_USE_BAKED_ANIMATION 1  
15 #define CC_USE_LIGHTMAP 1  
16 #define CC_RECEIVE_SHADOW 1  
17 #define CC_USE_MORPH 1  
18 #define CC_MORPH_TARGET_COUNT 2  
19 #define CC_MORPH_PRECOMPUTED 1  
20 #define CC_MORPH_TARGET_HAS_POSITION 1  
21 #define CC_MORPH_TARGET_HAS_NORMAL 1  
22 #define CC_MORPH_TARGET_HAS_TANGENT 1  
23 #define USE_VERTEX_COLOR 1  
24 #define USE_NORMAL_MAP 1  
25 #define HAS_SECOND_UV 1  
26 #define CC_USE_IBL 0  
27 #define CC_USE_DIFFUSEMAP 0  
28 #define USE_REFLECTION_DENOISE 1  
29 #define CC_FORWARD_ADD 1  
30 #define CC_USE_HDR 1  
31 #define USE_ALBEDO_MAP 1  
32 #define ALBEDO_UV v_uv  
33 #define NORMAL_UV v_uv  
34 #define USE_PBR_MAP 1  
35 #define PBR_UV v_uv  
36 #define USE_METALLIC_ROUGHNESS_MAP 1  
37 #define METALLIC_ROUGHNESS_UV v_uv  
38 #define USE_OCCLUSION_MAP 1  
39 #define OCCLUSION_UV v_uv  
40 #define USE_EMISSIVE_MAP 1  
41 #define EMISSIVE_UV v_uv  
42 #define OCCLUSION_CHANNEL r  
43 #define ROUGHNESS_CHANNEL g  
44 #define METALLIC_CHANNEL b  
45 #define USE_ALPHA_TEST 1  
46 #define ALPHA_TEST_CHANNEL a  
47  
48 #ifdef GL_OES_standard_derivatives  
49 #extension GL_OES_standard_derivatives: enable  
50 #endif  
51  
52 #ifdef GL_EXT_shader_texture_lod  
53 #extension GL_EXT_shader_texture_lod: enable  
54 #endif  
55  
56 precision highp float;  
57 uniform highp vec4 cc_cameraPos;  
58   uniform mediump vec4 cc_mainLitDir;  
59   uniform mediump vec4 cc_mainLitColor;  
60   uniform mediump vec4 cc_ambientSky;  
61   uniform mediump vec4 cc_ambientGround;  
62  
63  
64  
65  
66  
67  
68 #define QUATER_PI         0.78539816340  
69 #define HALF_PI           1.57079632679  
70 #define PI                3.14159265359  
71 #define PI2               6.28318530718  
72 #define PI4               12.5663706144  
73  
74 #define INV_QUATER_PI     1.27323954474  
75 #define INV_HALF_PI       0.63661977237  
76 #define INV_PI            0.31830988618  
77 #define INV_PI2           0.15915494309  
78 #define INV_PI4           0.07957747155  
79  
80 #define EPSILON           1e-6  
81 #define EPSILON_LOWP      1e-4  
82 #define LOG2              1.442695  
83 #define EXP_VALUE         2.71828183f  
84 #define FP_MAX            65504.0  
85 #define FP_SCALE          0.0009765625  
86 #define FP_SCALE_INV      1024.0  
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)  
88  
89  
90  
91  
92  
93  
94  
95 vec3 SRGBToLinear (vec3 gamma) {  
96   return gamma * gamma;  
97 }  
98 uniform highp mat4 cc_matLightView;  
99   uniform highp vec4 cc_shadowProjDepthInfo;  
100   uniform highp vec4 cc_shadowProjInfo;  
101   uniform mediump vec4 cc_shadowNFLSInfo;  
102   uniform mediump vec4 cc_shadowWHPBInfo;  
103   uniform mediump vec4 cc_shadowLPNNInfo;  
104  
105  
106  
107  
108  
109  
110  
111  
112 highp float unpackHighpData (float mainPart, float modPart) {  
113   highp float data = mainPart;  
114   return data + modPart;  
115 }  
116  
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {  
118   highp float data = mainPart * modValue;  
119   return data + modPart * modValue;  
120 }  
121  
122  
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {  
124   highp vec2 data = mainPart;  
125   return data + modPart;  
126 }  
127  
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {  
129   highp vec2 data = mainPart * modValue;  
130   return data + modPart * modValue;  
131 }  
132  
133  
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {  
135   highp vec3 data = mainPart;  
136   return data + modPart;  
137 }  
138  
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {  
140   highp vec3 data = mainPart * modValue;  
141   return data + modPart * modValue;  
142 }  
143  
144  
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {  
146   highp vec4 data = mainPart;  
147   return data + modPart;  
148 }  
149  
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {  
151   highp vec4 data = mainPart * modValue;  
152   return data + modPart * modValue;  
153 }  
154 #if CC_RECEIVE_SHADOW  
155   uniform highp sampler2D cc_shadowMap;  
156   uniform highp sampler2D cc_spotLightingMap;  
157  
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)  
159   {  
160     vec4 newShadowPos = shadowPos;  
161     if(normalBias > EPSILON_LOWP)  
162     {  
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);  
164       if(viewNormal.z < 0.1)  
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);  
166     }  
167     return newShadowPos;  
168   }  
169  
170  
171  
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)  
173   {  
174     float coeffA = cc_shadowProjDepthInfo.x;  
175     float coeffB = cc_shadowProjDepthInfo.y;  
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;  
177     viewSpacePos_z += viewspaceDepthBias;  
178     vec4 result = shadowPos;  
179     result.z = viewSpacePos_z * coeffA + coeffB;  
180     return result;  
181   }  
182  
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {  
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
190  
191     float shadow = 0.0;  
192     float closestDepth = 0.0;  
193     if (cc_shadowLPNNInfo.y > EPSILON) {  
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));  
195     } else {  
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;  
197     }  
198     shadow = step(clipPos.z, closestDepth);  
199  
200     return shadow;  
201   }  
202  
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {  
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
210  
211     float offsetDepth = clipPos.z;  
212     vec2 mapSize = cc_shadowWHPBInfo.xy;  
213     vec2 oneTap = 1.0 / mapSize;  
214     vec2 clipPos_offset = clipPos.xy + oneTap;  
215  
216     float block0, block1, block2, block3;  
217     if (cc_shadowLPNNInfo.y > EPSILON) {  
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
222     } else {  
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);  
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);  
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);  
227     }  
228  
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;  
230     float resultX = mix(block0, block1, coefX);  
231     float resultY = mix(block2, block3, coefX);  
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;  
233  
234     return mix(resultX, resultY, coefY);  
235   }  
236  
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {  
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
244  
245     float offsetDepth = clipPos.z;  
246     vec2 mapSize = cc_shadowWHPBInfo.xy;  
247     vec2 oneTap = 1.0 / mapSize;  
248     float clipPos_offset_L = clipPos.x - oneTap.x;  
249     float clipPos_offset_R = clipPos.x + oneTap.x;  
250     float clipPos_offset_U = clipPos.y - oneTap.y;  
251     float clipPos_offset_D = clipPos.y + oneTap.y;  
252  
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;  
254     if (cc_shadowLPNNInfo.y > EPSILON) {  
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
264     } else {  
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);  
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);  
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);  
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);  
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);  
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);  
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);  
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);  
274     }  
275  
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;  
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;  
278  
279     float shadow = 0.0;  
280     float resultX = mix(block0, block1, coefX);  
281     float resultY = mix(block3, block4, coefX);  
282     shadow += mix(resultX , resultY, coefY);  
283  
284     resultX = mix(block1, block2, coefX);  
285     resultY = mix(block4, block5, coefX);  
286     shadow += mix(resultX , resultY, coefY);  
287  
288     resultX = mix(block3, block4, coefX);  
289     resultY = mix(block6, block7, coefX);  
290     shadow += mix(resultX, resultY, coefY);  
291  
292     resultX = mix(block4, block5, coefX);  
293     resultY = mix(block7, block8, coefX);  
294     shadow += mix(resultX, resultY, coefY);  
295  
296     return shadow * 0.25;  
297   }  
298  
299  
300  
301  
302  
303  
304  
305  
306  
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)  
308 {  
309   float realtimeShadow = 1.0;  
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);  
311  
312   float pcf = cc_shadowWHPBInfo.z;  
313   if (pcf > 1.9) {  
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);  
315   }else if (pcf > 0.9) {  
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);  
317   }else {  
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);  
319   }  
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);  
321 }  
322 #endif  
323  
324  
325  
326 #if CC_USE_IBL  
327   uniform samplerCube cc_environment;  
328  
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {  
330  
331       #ifdef GL_EXT_shader_texture_lod  
332         return texture2DLodEXT(tex, coord, lod);  
333       #else  
334         return texture2D(tex, coord, lod);  
335       #endif  
336  
337   }  
338  
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {  
340  
341       #ifdef GL_EXT_shader_texture_lod  
342         return textureCubeLodEXT(tex, coord, lod);  
343       #else  
344         return textureCube(tex, coord, lod);  
345       #endif  
346  
347   }  
348  
349  
350  
351  
352  
353  
354  
355   vec3 unpackRGBE (vec4 rgbe) {  
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);  
357   }  
358  
359  
360   #if CC_USE_DIFFUSEMAP  
361     uniform samplerCube cc_diffuseMap;  
362   #endif  
363 #endif  
364  
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {  
366   vec3 NxH = cross(N, H);  
367   float OneMinusNoHSqr = dot(NxH, NxH);  
368   float a = roughness * roughness;  
369   float n = NoH * a;  
370   float p = a / (OneMinusNoHSqr + n * n);  
371   return p * p;  
372 }  
373  
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {  
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);  
376 }  
377  
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {  
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);  
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);  
381   vec4 r = roughness * c0 + c1;  
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;  
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;  
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);  
385   return specular * AB.x + AB.y;  
386 }  
387  
388 #if USE_REFLECTION_DENOISE  
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {  
390     #if CC_USE_IBL  
391     	float mip = roughness * mipCount;  
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;  
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));  
394  
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);  
396      	vec4 filtered = textureCube(cc_environment, R);  
397  
398       #if CC_USE_IBL == 2  
399       	biased.rgb = unpackRGBE(biased);  
400       	filtered.rgb = unpackRGBE(filtered);  
401       #else  
402       	biased.rgb = SRGBToLinear(biased.rgb);  
403       	filtered.rgb = SRGBToLinear(filtered.rgb);  
404       #endif  
405  
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);  
407     #else  
408       return vec3(0.0, 0.0, 0.0);  
409     #endif  
410   }  
411 #endif  
412  
413  
414 struct StandardSurface {  
415   vec4 albedo;  
416  
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
418   vec3 position, position_fract_part;  
419   #else  
420   vec3 position;  
421   #endif  
422   vec3 normal;  
423   vec3 emissive;  
424   vec3 lightmap;  
425   float lightmap_test;  
426   float roughness;  
427   float metallic;  
428   float occlusion;  
429   float specularIntensity;  
430  
431   #if CC_RECEIVE_SHADOW  
432     vec2 shadowBias;  
433   #endif  
434 };  
435  
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {  
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);  
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);  
440  
441   vec3 position;  
442  
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
444   position = unpackHighpData(s.position, s.position_fract_part);  
445   #else  
446   position = s.position;  
447   #endif  
448  
449   vec3 N = normalize(s.normal);  
450   vec3 V = normalize(cc_cameraPos.xyz - position);  
451  
452   float NV = max(abs(dot(N, V)), 0.0);  
453   specular = BRDFApprox(specular, s.roughness, NV);  
454  
455   vec3 L = normalize(-cc_mainLitDir.xyz);  
456   vec3 H = normalize(L + V);  
457   float NH = max(dot(N, H), 0.0);  
458   float NL = max(dot(N, L), 0.0);  
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;  
460   vec3 diffuseContrib = diffuse / PI;  
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);  
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);  
463  
464   float shadow = 1.0;  
465   #if CC_RECEIVE_SHADOW  
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {  
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);  
468     }  
469   #endif  
470  
471   dirlightContrib *= shadow;  
472   finalColor *= dirlightContrib;  
473  
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD  
475     if (s.lightmap_test > EPSILON_LOWP) {  
476       finalColor = diffuse * s.lightmap.rgb * shadow;  
477     }  
478   #endif  
479  
480   float fAmb = 0.5 - N.y * 0.5;  
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);  
482  
483  
484   #if CC_USE_IBL  
485     #if CC_USE_DIFFUSEMAP  
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);  
487       #if CC_USE_DIFFUSEMAP == 2  
488         ambDiff = unpackRGBE(diffuseMap);  
489       #else  
490         ambDiff = SRGBToLinear(diffuseMap.rgb);  
491       #endif  
492     #endif  
493  
494     vec3 R = normalize(reflect(-V, N));  
495  
496     #if USE_REFLECTION_DENOISE  
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);  
498     #else  
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);  
500  
501       #if CC_USE_IBL == 2  
502         vec3 env = unpackRGBE(envmap);  
503       #else  
504         vec3 env = SRGBToLinear(envmap.rgb);  
505       #endif  
506     #endif  
507  
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;  
509   #endif  
510  
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;  
512  
513  
514   finalColor += s.emissive;  
515  
516   return vec4(finalColor, s.albedo.a);  
517 }  
518  
519  
520  
521 vec3 ACESToneMap (vec3 color) {  
522   color = min(color, vec3(8.0));  
523   const float A = 2.51;  
524   const float B = 0.03;  
525   const float C = 2.43;  
526   const float D = 0.59;  
527   const float E = 0.14;  
528   return (color * (A * color + B)) / (color * (C * color + D) + E);  
529 }  
530  
531  
532  
533 vec4 CCFragOutput (vec4 color) {  
534   #if CC_USE_HDR  
535     color.rgb = ACESToneMap(color.rgb);  
536   #endif  
537   color.rgb = sqrt(color.rgb);  
538   return color;  
539 }  
540  
541  
542  
543      uniform vec4 rimColor;  
544      uniform vec4 albedo;  
545      uniform vec4 albedoScaleAndCutoff;  
546      uniform vec4 pbrParams;  
547      uniform vec4 emissive;  
548      uniform vec4 emissiveScaleParam;  
549  
550  
551  
552  
553 varying highp vec4 v_shadowPos;  
554  
555  
556  
557 #if CC_RECEIVE_SHADOW  
558  
559  
560  
561 #endif  
562  
563  
564 varying vec3 v_position;  
565 varying vec3 v_view_position;  
566 varying vec2 v_uv;  
567 varying vec2 v_uv1;  
568 varying vec3 v_normal;  
569 varying vec3 v_view_normal;  
570 varying vec4 v_shadowPos;  
571  
572 #if USE_VERTEX_COLOR  
573   varying vec3 v_color;  
574 #endif  
575  
576 #if USE_ALBEDO_MAP  
577   uniform sampler2D albedoMap;  
578 #endif  
579 #if USE_NORMAL_MAP  
580   varying vec3 v_tangent;  
581   varying vec3 v_bitangent;  
582   uniform sampler2D normalMap;  
583 #endif  
584 #if USE_PBR_MAP  
585   uniform sampler2D pbrMap;  
586 #endif  
587 #if USE_METALLIC_ROUGHNESS_MAP  
588   uniform sampler2D metallicRoughnessMap;  
589 #endif  
590 #if USE_OCCLUSION_MAP  
591   uniform sampler2D occlusionMap;  
592 #endif  
593 #if USE_EMISSIVE_MAP  
594   uniform sampler2D emissiveMap;  
595 #endif  
596 #if CC_USE_LIGHTMAP  
597   varying vec2 v_luv;  
598   uniform sampler2D cc_lightingMap;  
599 #endif  
600 #if USE_ALPHA_TEST  
601 #endif  
602  
603 void surf (out StandardSurface s) {  
604   vec4 baseColor = albedo;  
605   #if USE_VERTEX_COLOR  
606     baseColor.rgb *= v_color;  
607   #endif  
608   #if USE_ALBEDO_MAP  
609     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);  
610     texColor.rgb = SRGBToLinear(texColor.rgb);  
611     baseColor *= texColor;  
612   #endif  
613   s.albedo = baseColor;  
614   s.albedo.rgb *= albedoScaleAndCutoff.xyz;  
615  
616   #if USE_ALPHA_TEST  
617     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;  
618   #endif  
619   float density = 0.001;  
620   float dist2 = dot(v_view_position,v_view_position);  
621   float fogFactor = exp( -density*density * dist2);  
622   fogFactor = clamp(fogFactor, 0.0, 1.0);  
623  
624   vec3 fogColor = vec3(1.0,1,1.0);  
625   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);  
626  
627   s.normal = v_normal;  
628   #if USE_NORMAL_MAP  
629     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);  
630     s.normal =  
631       (nmmp.x * pbrParams.w) * normalize(v_tangent) +  
632       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +  
633       nmmp.z * normalize(s.normal);  
634   #endif  
635  
636   s.position = v_position;  
637  
638   vec4 pbr = pbrParams;  
639   #if USE_PBR_MAP  
640     vec4 res = texture2D(pbrMap, PBR_UV);  
641     pbr.x *= res.OCCLUSION_CHANNEL;  
642     pbr.y *= res.ROUGHNESS_CHANNEL;  
643     pbr.z *= res.METALLIC_CHANNEL;  
644   #endif  
645   #if USE_METALLIC_ROUGHNESS_MAP  
646     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);  
647     pbr.z *= metallicRoughness.METALLIC_CHANNEL;  
648     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;  
649   #endif  
650   #if USE_OCCLUSION_MAP  
651     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;  
652   #endif  
653   s.occlusion = clamp(pbr.x, 0.0, 0.96);  
654   s.roughness = clamp(pbr.y, 0.04, 1.0);  
655   s.specularIntensity = 0.5;  
656   s.metallic = pbr.z;  
657  
658   s.emissive = emissive.rgb * emissiveScaleParam.xyz;  
659   #if USE_EMISSIVE_MAP  
660     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);  
661   #endif  
662 }  
663  
664 vec4 frag () {  
665   StandardSurface s; surf(s);  
666   vec4 color = CCStandardShadingBase(s, v_shadowPos);  
667  
668   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING  
669     vec4 lighting = texture2D(cc_lightingMap, v_luv);  
670  
671     float fAmb = 0.5 - s.normal.y * 0.5;  
672     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;  
673  
674     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);  
675     finalColor += lighting.rgb *  s.albedo.rgb;  
676     finalColor = finalColor * s.occlusion;  
677     finalColor += s.emissive;  
678  
679     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;  
680   #endif  
681  
682   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;  
683  
684   color.rgb = mix(color.rgb,rimColor.rgb,fRim);  
685  
686   return CCFragOutput(color);  
687 }  
688  
689  
690 void main() { gl_FragColor = frag(); }  
691  
at Object.encode (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-worker/node_modules/v-stacks/index.js:14:17)  
at Logger._logHandler (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-worker/static/script.ccc:1:531)  
at Logger.record (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:458)  
at console.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:1414)  
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at runMicrotasks (<anonymous>)  
at runNextTicks (internal/process/task_queues.js:58:5)  
at processImmediate (internal/timers.js:434:9)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)
2022-06-23T02:42:27.821Z - error: [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos   
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)  
at async ParallelQueue._generate (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/asset-db.ccc:1:2165)
2022-06-23T02:43:08.501Z - error: [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos   
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at runMicrotasks (<anonymous>)  
at runNextTicks (internal/process/task_queues.js:58:5)  
at processImmediate (internal/timers.js:434:9)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)
2022-06-23T02:43:34.353Z - error: [Asset DB] ../res/rim_light.effect - standard-fs:frag: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:653: 'v_shadowPos' : undeclared identifier
ERROR: 0:653: 'CCStandardShadingBase' : no matching overloaded function found
ERROR: 0:653: '=' : dimension mismatch
ERROR: 0:653: '=' : cannot convert from 'const mediump float' to 'highp 4-component vector of float'
 

1 #version 100
2 #define USE_INSTANCING 1
3 #define USE_BATCHING 1
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
13 #define CC_USE_SKINNING 1
14 #define CC_USE_BAKED_ANIMATION 1
15 #define CC_USE_LIGHTMAP 1
16 #define CC_RECEIVE_SHADOW 1
17 #define CC_USE_MORPH 1
18 #define CC_MORPH_TARGET_COUNT 2
19 #define CC_MORPH_PRECOMPUTED 1
20 #define CC_MORPH_TARGET_HAS_POSITION 1
21 #define CC_MORPH_TARGET_HAS_NORMAL 1
22 #define CC_MORPH_TARGET_HAS_TANGENT 1
23 #define USE_VERTEX_COLOR 1
24 #define USE_NORMAL_MAP 1
25 #define HAS_SECOND_UV 1
26 #define CC_USE_IBL 0
27 #define CC_USE_DIFFUSEMAP 0
28 #define USE_REFLECTION_DENOISE 1
29 #define CC_FORWARD_ADD 1
30 #define CC_USE_HDR 1
31 #define USE_ALBEDO_MAP 1
32 #define ALBEDO_UV v_uv
33 #define NORMAL_UV v_uv
34 #define USE_PBR_MAP 1
35 #define PBR_UV v_uv
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define METALLIC_ROUGHNESS_UV v_uv
38 #define USE_OCCLUSION_MAP 1
39 #define OCCLUSION_UV v_uv
40 #define USE_EMISSIVE_MAP 1
41 #define EMISSIVE_UV v_uv
42 #define OCCLUSION_CHANNEL r
43 #define ROUGHNESS_CHANNEL g
44 #define METALLIC_CHANNEL b
45 #define USE_ALPHA_TEST 1
46 #define ALPHA_TEST_CHANNEL a
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp vec4 cc_cameraPos;
58   uniform mediump vec4 cc_mainLitDir;
59   uniform mediump vec4 cc_mainLitColor;
60   uniform mediump vec4 cc_ambientSky;
61   uniform mediump vec4 cc_ambientGround;
62 
63 
64 
65 
66 
67 
68 #define QUATER_PI         0.78539816340
69 #define HALF_PI           1.57079632679
70 #define PI                3.14159265359
71 #define PI2               6.28318530718
72 #define PI4               12.5663706144
73      
74 #define INV_QUATER_PI     1.27323954474
75 #define INV_HALF_PI       0.63661977237
76 #define INV_PI            0.31830988618
77 #define INV_PI2           0.15915494309
78 #define INV_PI4           0.07957747155
79      
80 #define EPSILON           1e-6
81 #define EPSILON_LOWP      1e-4
82 #define LOG2              1.442695
83 #define EXP_VALUE         2.71828183f
84 #define FP_MAX            65504.0
85 #define FP_SCALE          0.0009765625
86 #define FP_SCALE_INV      1024.0
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
88 
89 
90 
91 
92 
93 
94 
95 vec3 SRGBToLinear (vec3 gamma) {
96   return gamma * gamma;
97 }
98 uniform highp mat4 cc_matLightView;
99   uniform highp vec4 cc_shadowProjDepthInfo;
100   uniform highp vec4 cc_shadowProjInfo;
101   uniform mediump vec4 cc_shadowNFLSInfo;
102   uniform mediump vec4 cc_shadowWHPBInfo;
103   uniform mediump vec4 cc_shadowLPNNInfo;
104 
105 
106 
107 
108 
109 
110 
111 
112 highp float unpackHighpData (float mainPart, float modPart) {
113   highp float data = mainPart;
114   return data + modPart;
115 }
116 
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
118   highp float data = mainPart * modValue;
119   return data + modPart * modValue;
120 }
121 
122 
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
124   highp vec2 data = mainPart;
125   return data + modPart;
126 }
127 
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
129   highp vec2 data = mainPart * modValue;
130   return data + modPart * modValue;
131 }
132 
133 
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
135   highp vec3 data = mainPart;
136   return data + modPart;
137 }
138 
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
140   highp vec3 data = mainPart * modValue;
141   return data + modPart * modValue;
142 }
143 
144 
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
146   highp vec4 data = mainPart;
147   return data + modPart;
148 }
149 
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
151   highp vec4 data = mainPart * modValue;
152   return data + modPart * modValue;
153 }
154 #if CC_RECEIVE_SHADOW
155   uniform highp sampler2D cc_shadowMap;
156   uniform highp sampler2D cc_spotLightingMap;
157 
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
159   {
160     vec4 newShadowPos = shadowPos;
161     if(normalBias > EPSILON_LOWP)
162     {
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
164       if(viewNormal.z < 0.1)
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
166     }
167     return newShadowPos;
168   }
169   
170   
171 
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
173   {
174     float coeffA = cc_shadowProjDepthInfo.x;
175     float coeffB = cc_shadowProjDepthInfo.y;
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
177     viewSpacePos_z += viewspaceDepthBias;
178     vec4 result = shadowPos;
179     result.z = viewSpacePos_z * coeffA + coeffB;
180     return result;
181   }
182   
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
190 
191     float shadow = 0.0;
192     float closestDepth = 0.0;
193     if (cc_shadowLPNNInfo.y > EPSILON) {
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
195     } else {
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
197     }
198     shadow = step(clipPos.z, closestDepth);
199 
200     return shadow;
201   }
202 
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
210 
211     float offsetDepth = clipPos.z;
212     vec2 mapSize = cc_shadowWHPBInfo.xy;
213     vec2 oneTap = 1.0 / mapSize;
214     vec2 clipPos_offset = clipPos.xy + oneTap;
215 
216     float block0, block1, block2, block3;
217     if (cc_shadowLPNNInfo.y > EPSILON) {
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
222     } else {
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
227     }
228 
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
230     float resultX = mix(block0, block1, coefX);
231     float resultY = mix(block2, block3, coefX);
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
233 
234     return mix(resultX, resultY, coefY);
235   }
236 
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
244 
245     float offsetDepth = clipPos.z;
246     vec2 mapSize = cc_shadowWHPBInfo.xy;
247     vec2 oneTap = 1.0 / mapSize;
248     float clipPos_offset_L = clipPos.x - oneTap.x;
249     float clipPos_offset_R = clipPos.x + oneTap.x;
250     float clipPos_offset_U = clipPos.y - oneTap.y;
251     float clipPos_offset_D = clipPos.y + oneTap.y;
252 
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
254     if (cc_shadowLPNNInfo.y > EPSILON) {
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
264     } else {
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
274     }
275 
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
278 
279     float shadow = 0.0;
280     float resultX = mix(block0, block1, coefX);
281     float resultY = mix(block3, block4, coefX);
282     shadow += mix(resultX , resultY, coefY);
283 
284     resultX = mix(block1, block2, coefX);
285     resultY = mix(block4, block5, coefX);
286     shadow += mix(resultX , resultY, coefY);
287 
288     resultX = mix(block3, block4, coefX);
289     resultY = mix(block6, block7, coefX);
290     shadow += mix(resultX, resultY, coefY);
291 
292     resultX = mix(block4, block5, coefX);
293     resultY = mix(block7, block8, coefX);
294     shadow += mix(resultX, resultY, coefY);
295 
296     return shadow * 0.25;
297   }
298 
299   
300 
301   
302 
303   
304 
305 
306 
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
308 {
309   float realtimeShadow = 1.0;
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
311   
312   float pcf = cc_shadowWHPBInfo.z;
313   if (pcf > 1.9) { 
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
315   }else if (pcf > 0.9) {
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
317   }else { 
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
319   }
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
321 }
322 #endif
323 
324 
325 
326 #if CC_USE_IBL
327   uniform samplerCube cc_environment;
328   
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
330     
331       #ifdef GL_EXT_shader_texture_lod
332         return texture2DLodEXT(tex, coord, lod);
333       #else
334         return texture2D(tex, coord, lod);
335       #endif
336     
337   }
338   
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
340     
341       #ifdef GL_EXT_shader_texture_lod
342         return textureCubeLodEXT(tex, coord, lod);
343       #else
344         return textureCube(tex, coord, lod);
345       #endif
346     
347   }
348   
349   
350   
351   
352   
353   
354   
355   vec3 unpackRGBE (vec4 rgbe) {
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
357   }
358   
359 
360   #if CC_USE_DIFFUSEMAP
361     uniform samplerCube cc_diffuseMap;
362   #endif
363 #endif
364 
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
366   vec3 NxH = cross(N, H);
367   float OneMinusNoHSqr = dot(NxH, NxH);
368   float a = roughness * roughness;
369   float n = NoH * a;
370   float p = a / (OneMinusNoHSqr + n * n);
371   return p * p;
372 }
373 
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
376 }
377 
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
381   vec4 r = roughness * c0 + c1;
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
385   return specular * AB.x + AB.y;
386 }
387 
388 #if USE_REFLECTION_DENOISE
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
390     #if CC_USE_IBL
391     	float mip = roughness * mipCount;
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
394 
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
396      	vec4 filtered = textureCube(cc_environment, R);
397 
398       #if CC_USE_IBL == 2
399       	biased.rgb = unpackRGBE(biased);
400       	filtered.rgb = unpackRGBE(filtered);
401       #else
402       	biased.rgb = SRGBToLinear(biased.rgb);
403       	filtered.rgb = SRGBToLinear(filtered.rgb);
404       #endif
405       	
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
407     #else
408       return vec3(0.0, 0.0, 0.0);
409     #endif
410   }
411 #endif
412 
413 
414 struct StandardSurface {
415   vec4 albedo;
416   
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
418   vec3 position, position_fract_part;
419   #else
420   vec3 position;
421   #endif
422   vec3 normal;
423   vec3 emissive;
424   vec3 lightmap;
425   float lightmap_test;
426   float roughness;
427   float metallic;
428   float occlusion;
429   float specularIntensity;
430 
431   #if CC_RECEIVE_SHADOW
432     vec2 shadowBias;
433   #endif
434 };
435 
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
440 
441   vec3 position;
442   
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
444   position = unpackHighpData(s.position, s.position_fract_part);
445   #else
446   position = s.position;
447   #endif
448 
449   vec3 N = normalize(s.normal);
450   vec3 V = normalize(cc_cameraPos.xyz - position);
451 
452   float NV = max(abs(dot(N, V)), 0.0);
453   specular = BRDFApprox(specular, s.roughness, NV);
454 
455   vec3 L = normalize(-cc_mainLitDir.xyz);
456   vec3 H = normalize(L + V);
457   float NH = max(dot(N, H), 0.0);
458   float NL = max(dot(N, L), 0.0);
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
460   vec3 diffuseContrib = diffuse / PI;
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);
463 
464   float shadow = 1.0;
465   #if CC_RECEIVE_SHADOW
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
468     }
469   #endif
470 
471   dirlightContrib *= shadow;
472   finalColor *= dirlightContrib;
473 
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
475     if (s.lightmap_test > EPSILON_LOWP) {
476       finalColor = diffuse * s.lightmap.rgb * shadow;
477     }
478   #endif
479 
480   float fAmb = 0.5 - N.y * 0.5;
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
482 
483 
484   #if CC_USE_IBL
485     #if CC_USE_DIFFUSEMAP
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
487       #if CC_USE_DIFFUSEMAP == 2
488         ambDiff = unpackRGBE(diffuseMap);
489       #else
490         ambDiff = SRGBToLinear(diffuseMap.rgb);
491       #endif
492     #endif
493 
494     vec3 R = normalize(reflect(-V, N));
495 
496     #if USE_REFLECTION_DENOISE
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
498     #else
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
500 
501       #if CC_USE_IBL == 2
502         vec3 env = unpackRGBE(envmap);
503       #else
504         vec3 env = SRGBToLinear(envmap.rgb);
505       #endif
506     #endif
507 
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
509   #endif
510 
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
512   
513 
514   finalColor += s.emissive;
515 
516   return vec4(finalColor, s.albedo.a);
517 }
518 
519 
520 
521 vec3 ACESToneMap (vec3 color) {
522   color = min(color, vec3(8.0));
523   const float A = 2.51;
524   const float B = 0.03;
525   const float C = 2.43;
526   const float D = 0.59;
527   const float E = 0.14;
528   return (color * (A * color + B)) / (color * (C * color + D) + E);
529 }
530 
531 
532 
533 vec4 CCFragOutput (vec4 color) {
534   #if CC_USE_HDR
535     color.rgb = ACESToneMap(color.rgb);
536   #endif
537   color.rgb = sqrt(color.rgb);
538   return color;
539 }
540 
541 
542 
543      uniform vec4 rimColor;
544      uniform vec4 albedo;
545      uniform vec4 albedoScaleAndCutoff;
546      uniform vec4 pbrParams;
547      uniform vec4 emissive;
548      uniform vec4 emissiveScaleParam;
549 
550 
551 
552 varying vec3 v_position;
553 varying vec3 v_view_position;
554 varying vec2 v_uv;
555 varying vec2 v_uv1;
556 varying vec3 v_normal;
557 varying vec3 v_view_normal;
558 
559 #if USE_VERTEX_COLOR
560   varying vec3 v_color;
561 #endif
562 
563 #if USE_ALBEDO_MAP
564   uniform sampler2D albedoMap;
565 #endif
566 #if USE_NORMAL_MAP
567   varying vec3 v_tangent;
568   varying vec3 v_bitangent;
569   uniform sampler2D normalMap;
570 #endif
571 #if USE_PBR_MAP
572   uniform sampler2D pbrMap;
573 #endif
574 #if USE_METALLIC_ROUGHNESS_MAP
575   uniform sampler2D metallicRoughnessMap;
576 #endif
577 #if USE_OCCLUSION_MAP
578   uniform sampler2D occlusionMap;
579 #endif
580 #if USE_EMISSIVE_MAP
581   uniform sampler2D emissiveMap;
582 #endif
583 #if CC_USE_LIGHTMAP
584   varying vec2 v_luv;
585   uniform sampler2D cc_lightingMap;
586 #endif
587 #if USE_ALPHA_TEST
588 #endif
589 
590 void surf (out StandardSurface s) {
591   vec4 baseColor = albedo;
592   #if USE_VERTEX_COLOR
593     baseColor.rgb *= v_color;
594   #endif
595   #if USE_ALBEDO_MAP
596     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);
597     texColor.rgb = SRGBToLinear(texColor.rgb);
598     baseColor *= texColor;
599   #endif
600   s.albedo = baseColor;
601   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
602 
603   #if USE_ALPHA_TEST
604     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
605   #endif
606   float density = 0.001;
607   float dist2 = dot(v_view_position,v_view_position);
608   float fogFactor = exp( -density*density * dist2);
609   fogFactor = clamp(fogFactor, 0.0, 1.0);
610 
611   vec3 fogColor = vec3(1.0,1,1.0);
612   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);
613 
614   s.normal = v_normal;
615   #if USE_NORMAL_MAP
616     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);
617     s.normal =
618       (nmmp.x * pbrParams.w) * normalize(v_tangent) +
619       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +
620       nmmp.z * normalize(s.normal);
621   #endif
622 
623   s.position = v_position;
624 
625   vec4 pbr = pbrParams;
626   #if USE_PBR_MAP
627     vec4 res = texture2D(pbrMap, PBR_UV);
628     pbr.x *= res.OCCLUSION_CHANNEL;
629     pbr.y *= res.ROUGHNESS_CHANNEL;
630     pbr.z *= res.METALLIC_CHANNEL;
631   #endif
632   #if USE_METALLIC_ROUGHNESS_MAP
633     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);
634     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
635     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
636   #endif
637   #if USE_OCCLUSION_MAP
638     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;
639   #endif
640   s.occlusion = clamp(pbr.x, 0.0, 0.96);
641   s.roughness = clamp(pbr.y, 0.04, 1.0);
642   s.specularIntensity = 0.5;
643   s.metallic = pbr.z;
644 
645   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
646   #if USE_EMISSIVE_MAP
647     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);
648   #endif
649 }
650 
651 vec4 frag () {
652   StandardSurface s; surf(s);
653   vec4 color = CCStandardShadingBase(s, v_shadowPos);
654 
655   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING
656     vec4 lighting = texture2D(cc_lightingMap, v_luv);
657 
658     float fAmb = 0.5 - s.normal.y * 0.5;
659     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
660 
661     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);
662     finalColor += lighting.rgb *  s.albedo.rgb;
663     finalColor = finalColor * s.occlusion;
664     finalColor += s.emissive;
665 
666     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;
667   #endif
668 
669   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;
670 
671   color.rgb = mix(color.rgb,rimColor.rgb,fRim);
672 
673   return CCFragOutput(color);
674 }
675 
676 
677 void main() { gl_FragColor = frag(); }
678 [Asset DB] ../res/rim_light.effect - standard-fs:frag: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:653: 'v_shadowPos' : undeclared identifier
ERROR: 0:653: 'CCStandardShadingBase' : no matching overloaded function found
ERROR: 0:653: '=' : dimension mismatch
ERROR: 0:653: '=' : cannot convert from 'const mediump float' to 'highp 4-component vector of float'
 

1 #version 100
2 #define USE_INSTANCING 1
3 #define USE_BATCHING 1
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
13 #define CC_USE_SKINNING 1
14 #define CC_USE_BAKED_ANIMATION 1
15 #define CC_USE_LIGHTMAP 1
16 #define CC_RECEIVE_SHADOW 1
17 #define CC_USE_MORPH 1
18 #define CC_MORPH_TARGET_COUNT 2
19 #define CC_MORPH_PRECOMPUTED 1
20 #define CC_MORPH_TARGET_HAS_POSITION 1
21 #define CC_MORPH_TARGET_HAS_NORMAL 1
22 #define CC_MORPH_TARGET_HAS_TANGENT 1
23 #define USE_VERTEX_COLOR 1
24 #define USE_NORMAL_MAP 1
25 #define HAS_SECOND_UV 1
26 #define CC_USE_IBL 0
27 #define CC_USE_DIFFUSEMAP 0
28 #define USE_REFLECTION_DENOISE 1
29 #define CC_FORWARD_ADD 1
30 #define CC_USE_HDR 1
31 #define USE_ALBEDO_MAP 1
32 #define ALBEDO_UV v_uv
33 #define NORMAL_UV v_uv
34 #define USE_PBR_MAP 1
35 #define PBR_UV v_uv
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define METALLIC_ROUGHNESS_UV v_uv
38 #define USE_OCCLUSION_MAP 1
39 #define OCCLUSION_UV v_uv
40 #define USE_EMISSIVE_MAP 1
41 #define EMISSIVE_UV v_uv
42 #define OCCLUSION_CHANNEL r
43 #define ROUGHNESS_CHANNEL g
44 #define METALLIC_CHANNEL b
45 #define USE_ALPHA_TEST 1
46 #define ALPHA_TEST_CHANNEL a
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp vec4 cc_cameraPos;
58   uniform mediump vec4 cc_mainLitDir;
59   uniform mediump vec4 cc_mainLitColor;
60   uniform mediump vec4 cc_ambientSky;
61   uniform mediump vec4 cc_ambientGround;
62 
63 
64 
65 
66 
67 
68 #define QUATER_PI         0.78539816340
69 #define HALF_PI           1.57079632679
70 #define PI                3.14159265359
71 #define PI2               6.28318530718
72 #define PI4               12.5663706144
73      
74 #define INV_QUATER_PI     1.27323954474
75 #define INV_HALF_PI       0.63661977237
76 #define INV_PI            0.31830988618
77 #define INV_PI2           0.15915494309
78 #define INV_PI4           0.07957747155
79      
80 #define EPSILON           1e-6
81 #define EPSILON_LOWP      1e-4
82 #define LOG2              1.442695
83 #define EXP_VALUE         2.71828183f
84 #define FP_MAX            65504.0
85 #define FP_SCALE          0.0009765625
86 #define FP_SCALE_INV      1024.0
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
88 
89 
90 
91 
92 
93 
94 
95 vec3 SRGBToLinear (vec3 gamma) {
96   return gamma * gamma;
97 }
98 uniform highp mat4 cc_matLightView;
99   uniform highp vec4 cc_shadowProjDepthInfo;
100   uniform highp vec4 cc_shadowProjInfo;
101   uniform mediump vec4 cc_shadowNFLSInfo;
102   uniform mediump vec4 cc_shadowWHPBInfo;
103   uniform mediump vec4 cc_shadowLPNNInfo;
104 
105 
106 
107 
108 
109 
110 
111 
112 highp float unpackHighpData (float mainPart, float modPart) {
113   highp float data = mainPart;
114   return data + modPart;
115 }
116 
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
118   highp float data = mainPart * modValue;
119   return data + modPart * modValue;
120 }
121 
122 
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
124   highp vec2 data = mainPart;
125   return data + modPart;
126 }
127 
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
129   highp vec2 data = mainPart * modValue;
130   return data + modPart * modValue;
131 }
132 
133 
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
135   highp vec3 data = mainPart;
136   return data + modPart;
137 }
138 
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
140   highp vec3 data = mainPart * modValue;
141   return data + modPart * modValue;
142 }
143 
144 
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
146   highp vec4 data = mainPart;
147   return data + modPart;
148 }
149 
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
151   highp vec4 data = mainPart * modValue;
152   return data + modPart * modValue;
153 }
154 #if CC_RECEIVE_SHADOW
155   uniform highp sampler2D cc_shadowMap;
156   uniform highp sampler2D cc_spotLightingMap;
157 
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
159   {
160     vec4 newShadowPos = shadowPos;
161     if(normalBias > EPSILON_LOWP)
162     {
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
164       if(viewNormal.z < 0.1)
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
166     }
167     return newShadowPos;
168   }
169   
170   
171 
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
173   {
174     float coeffA = cc_shadowProjDepthInfo.x;
175     float coeffB = cc_shadowProjDepthInfo.y;
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
177     viewSpacePos_z += viewspaceDepthBias;
178     vec4 result = shadowPos;
179     result.z = viewSpacePos_z * coeffA + coeffB;
180     return result;
181   }
182   
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
190 
191     float shadow = 0.0;
192     float closestDepth = 0.0;
193     if (cc_shadowLPNNInfo.y > EPSILON) {
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
195     } else {
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
197     }
198     shadow = step(clipPos.z, closestDepth);
199 
200     return shadow;
201   }
202 
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
210 
211     float offsetDepth = clipPos.z;
212     vec2 mapSize = cc_shadowWHPBInfo.xy;
213     vec2 oneTap = 1.0 / mapSize;
214     vec2 clipPos_offset = clipPos.xy + oneTap;
215 
216     float block0, block1, block2, block3;
217     if (cc_shadowLPNNInfo.y > EPSILON) {
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
222     } else {
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
227     }
228 
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
230     float resultX = mix(block0, block1, coefX);
231     float resultY = mix(block2, block3, coefX);
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
233 
234     return mix(resultX, resultY, coefY);
235   }
236 
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
244 
245     float offsetDepth = clipPos.z;
246     vec2 mapSize = cc_shadowWHPBInfo.xy;
247     vec2 oneTap = 1.0 / mapSize;
248     float clipPos_offset_L = clipPos.x - oneTap.x;
249     float clipPos_offset_R = clipPos.x + oneTap.x;
250     float clipPos_offset_U = clipPos.y - oneTap.y;
251     float clipPos_offset_D = clipPos.y + oneTap.y;
252 
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
254     if (cc_shadowLPNNInfo.y > EPSILON) {
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
264     } else {
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
274     }
275 
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
278 
279     float shadow = 0.0;
280     float resultX = mix(block0, block1, coefX);
281     float resultY = mix(block3, block4, coefX);
282     shadow += mix(resultX , resultY, coefY);
283 
284     resultX = mix(block1, block2, coefX);
285     resultY = mix(block4, block5, coefX);
286     shadow += mix(resultX , resultY, coefY);
287 
288     resultX = mix(block3, block4, coefX);
289     resultY = mix(block6, block7, coefX);
290     shadow += mix(resultX, resultY, coefY);
291 
292     resultX = mix(block4, block5, coefX);
293     resultY = mix(block7, block8, coefX);
294     shadow += mix(resultX, resultY, coefY);
295 
296     return shadow * 0.25;
297   }
298 
299   
300 
301   
302 
303   
304 
305 
306 
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
308 {
309   float realtimeShadow = 1.0;
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
311   
312   float pcf = cc_shadowWHPBInfo.z;
313   if (pcf > 1.9) { 
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
315   }else if (pcf > 0.9) {
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
317   }else { 
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
319   }
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
321 }
322 #endif
323 
324 
325 
326 #if CC_USE_IBL
327   uniform samplerCube cc_environment;
328   
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
330     
331       #ifdef GL_EXT_shader_texture_lod
332         return texture2DLodEXT(tex, coord, lod);
333       #else
334         return texture2D(tex, coord, lod);
335       #endif
336     
337   }
338   
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
340     
341       #ifdef GL_EXT_shader_texture_lod
342         return textureCubeLodEXT(tex, coord, lod);
343       #else
344         return textureCube(tex, coord, lod);
345       #endif
346     
347   }
348   
349   
350   
351   
352   
353   
354   
355   vec3 unpackRGBE (vec4 rgbe) {
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
357   }
358   
359 
360   #if CC_USE_DIFFUSEMAP
361     uniform samplerCube cc_diffuseMap;
362   #endif
363 #endif
364 
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
366   vec3 NxH = cross(N, H);
367   float OneMinusNoHSqr = dot(NxH, NxH);
368   float a = roughness * roughness;
369   float n = NoH * a;
370   float p = a / (OneMinusNoHSqr + n * n);
371   return p * p;
372 }
373 
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
376 }
377 
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
381   vec4 r = roughness * c0 + c1;
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
385   return specular * AB.x + AB.y;
386 }
387 
388 #if USE_REFLECTION_DENOISE
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
390     #if CC_USE_IBL
391     	float mip = roughness * mipCount;
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
394 
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
396      	vec4 filtered = textureCube(cc_environment, R);
397 
398       #if CC_USE_IBL == 2
399       	biased.rgb = unpackRGBE(biased);
400       	filtered.rgb = unpackRGBE(filtered);
401       #else
402       	biased.rgb = SRGBToLinear(biased.rgb);
403       	filtered.rgb = SRGBToLinear(filtered.rgb);
404       #endif
405       	
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
407     #else
408       return vec3(0.0, 0.0, 0.0);
409     #endif
410   }
411 #endif
412 
413 
414 struct StandardSurface {
415   vec4 albedo;
416   
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
418   vec3 position, position_fract_part;
419   #else
420   vec3 position;
421   #endif
422   vec3 normal;
423   vec3 emissive;
424   vec3 lightmap;
425   float lightmap_test;
426   float roughness;
427   float metallic;
428   float occlusion;
429   float specularIntensity;
430 
431   #if CC_RECEIVE_SHADOW
432     vec2 shadowBias;
433   #endif
434 };
435 
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
440 
441   vec3 position;
442   
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
444   position = unpackHighpData(s.position, s.position_fract_part);
445   #else
446   position = s.position;
447   #endif
448 
449   vec3 N = normalize(s.normal);
450   vec3 V = normalize(cc_cameraPos.xyz - position);
451 
452   float NV = max(abs(dot(N, V)), 0.0);
453   specular = BRDFApprox(specular, s.roughness, NV);
454 
455   vec3 L = normalize(-cc_mainLitDir.xyz);
456   vec3 H = normalize(L + V);
457   float NH = max(dot(N, H), 0.0);
458   float NL = max(dot(N, L), 0.0);
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
460   vec3 diffuseContrib = diffuse / PI;
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);
463 
464   float shadow = 1.0;
465   #if CC_RECEIVE_SHADOW
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
468     }
469   #endif
470 
471   dirlightContrib *= shadow;
472   finalColor *= dirlightContrib;
473 
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
475     if (s.lightmap_test > EPSILON_LOWP) {
476       finalColor = diffuse * s.lightmap.rgb * shadow;
477     }
478   #endif
479 
480   float fAmb = 0.5 - N.y * 0.5;
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
482 
483 
484   #if CC_USE_IBL
485     #if CC_USE_DIFFUSEMAP
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
487       #if CC_USE_DIFFUSEMAP == 2
488         ambDiff = unpackRGBE(diffuseMap);
489       #else
490         ambDiff = SRGBToLinear(diffuseMap.rgb);
491       #endif
492     #endif
493 
494     vec3 R = normalize(reflect(-V, N));
495 
496     #if USE_REFLECTION_DENOISE
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
498     #else
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
500 
501       #if CC_USE_IBL == 2
502         vec3 env = unpackRGBE(envmap);
503       #else
504         vec3 env = SRGBToLinear(envmap.rgb);
505       #endif
506     #endif
507 
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
509   #endif
510 
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
512   
513 
514   finalColor += s.emissive;
515 
516   return vec4(finalColor, s.albedo.a);
517 }
518 
519 
520 
521 vec3 ACESToneMap (vec3 color) {
522   color = min(color, vec3(8.0));
523   const float A = 2.51;
524   const float B = 0.03;
525   const float C = 2.43;
526   const float D = 0.59;
527   const float E = 0.14;
528   return (color * (A * color + B)) / (color * (C * color + D) + E);
529 }
530 
531 
532 
533 vec4 CCFragOutput (vec4 color) {
534   #if CC_USE_HDR
535     color.rgb = ACESToneMap(color.rgb);
536   #endif
537   color.rgb = sqrt(color.rgb);
538   return color;
539 }
540 
541 
542 
543      uniform vec4 rimColor;
544      uniform vec4 albedo;
545      uniform vec4 albedoScaleAndCutoff;
546      uniform vec4 pbrParams;
547      uniform vec4 emissive;
548      uniform vec4 emissiveScaleParam;
549 
550 
551 
552 varying vec3 v_position;
553 varying vec3 v_view_position;
554 varying vec2 v_uv;
555 varying vec2 v_uv1;
556 varying vec3 v_normal;
557 varying vec3 v_view_normal;
558 
559 #if USE_VERTEX_COLOR
560   varying vec3 v_color;
561 #endif
562 
563 #if USE_ALBEDO_MAP
564   uniform sampler2D albedoMap;
565 #endif
566 #if USE_NORMAL_MAP
567   varying vec3 v_tangent;
568   varying vec3 v_bitangent;
569   uniform sampler2D normalMap;
570 #endif
571 #if USE_PBR_MAP
572   uniform sampler2D pbrMap;
573 #endif
574 #if USE_METALLIC_ROUGHNESS_MAP
575   uniform sampler2D metallicRoughnessMap;
576 #endif
577 #if USE_OCCLUSION_MAP
578   uniform sampler2D occlusionMap;
579 #endif
580 #if USE_EMISSIVE_MAP
581   uniform sampler2D emissiveMap;
582 #endif
583 #if CC_USE_LIGHTMAP
584   varying vec2 v_luv;
585   uniform sampler2D cc_lightingMap;
586 #endif
587 #if USE_ALPHA_TEST
588 #endif
589 
590 void surf (out StandardSurface s) {
591   vec4 baseColor = albedo;
592   #if USE_VERTEX_COLOR
593     baseColor.rgb *= v_color;
594   #endif
595   #if USE_ALBEDO_MAP
596     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);
597     texColor.rgb = SRGBToLinear(texColor.rgb);
598     baseColor *= texColor;
599   #endif
600   s.albedo = baseColor;
601   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
602 
603   #if USE_ALPHA_TEST
604     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
605   #endif
606   float density = 0.001;
607   float dist2 = dot(v_view_position,v_view_position);
608   float fogFactor = exp( -density*density * dist2);
609   fogFactor = clamp(fogFactor, 0.0, 1.0);
610 
611   vec3 fogColor = vec3(1.0,1,1.0);
612   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);
613 
614   s.normal = v_normal;
615   #if USE_NORMAL_MAP
616     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);
617     s.normal =
618       (nmmp.x * pbrParams.w) * normalize(v_tangent) +
619       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +
620       nmmp.z * normalize(s.normal);
621   #endif
622 
623   s.position = v_position;
624 
625   vec4 pbr = pbrParams;
626   #if USE_PBR_MAP
627     vec4 res = texture2D(pbrMap, PBR_UV);
628     pbr.x *= res.OCCLUSION_CHANNEL;
629     pbr.y *= res.ROUGHNESS_CHANNEL;
630     pbr.z *= res.METALLIC_CHANNEL;
631   #endif
632   #if USE_METALLIC_ROUGHNESS_MAP
633     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);
634     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
635     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
636   #endif
637   #if USE_OCCLUSION_MAP
638     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;
639   #endif
640   s.occlusion = clamp(pbr.x, 0.0, 0.96);
641   s.roughness = clamp(pbr.y, 0.04, 1.0);
642   s.specularIntensity = 0.5;
643   s.metallic = pbr.z;
644 
645   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
646   #if USE_EMISSIVE_MAP
647     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);
648   #endif
649 }
650 
651 vec4 frag () {
652   StandardSurface s; surf(s);
653   vec4 color = CCStandardShadingBase(s, v_shadowPos);
654 
655   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING
656     vec4 lighting = texture2D(cc_lightingMap, v_luv);
657 
658     float fAmb = 0.5 - s.normal.y * 0.5;
659     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
660 
661     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);
662     finalColor += lighting.rgb *  s.albedo.rgb;
663     finalColor = finalColor * s.occlusion;
664     finalColor += s.emissive;
665 
666     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;
667   #endif
668 
669   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;
670 
671   color.rgb = mix(color.rgb,rimColor.rgb,fRim);
672 
673   return CCFragOutput(color);
674 }
675 
676 
677 void main() { gl_FragColor = frag(); }
678   
   
  
1 #version 100  
2 #define USE_INSTANCING 1  
3 #define USE_BATCHING 1  
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1  
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024  
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024  
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128  
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128  
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0  
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0  
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0  
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0  
13 #define CC_USE_SKINNING 1  
14 #define CC_USE_BAKED_ANIMATION 1  
15 #define CC_USE_LIGHTMAP 1  
16 #define CC_RECEIVE_SHADOW 1  
17 #define CC_USE_MORPH 1  
18 #define CC_MORPH_TARGET_COUNT 2  
19 #define CC_MORPH_PRECOMPUTED 1  
20 #define CC_MORPH_TARGET_HAS_POSITION 1  
21 #define CC_MORPH_TARGET_HAS_NORMAL 1  
22 #define CC_MORPH_TARGET_HAS_TANGENT 1  
23 #define USE_VERTEX_COLOR 1  
24 #define USE_NORMAL_MAP 1  
25 #define HAS_SECOND_UV 1  
26 #define CC_USE_IBL 0  
27 #define CC_USE_DIFFUSEMAP 0  
28 #define USE_REFLECTION_DENOISE 1  
29 #define CC_FORWARD_ADD 1  
30 #define CC_USE_HDR 1  
31 #define USE_ALBEDO_MAP 1  
32 #define ALBEDO_UV v_uv  
33 #define NORMAL_UV v_uv  
34 #define USE_PBR_MAP 1  
35 #define PBR_UV v_uv  
36 #define USE_METALLIC_ROUGHNESS_MAP 1  
37 #define METALLIC_ROUGHNESS_UV v_uv  
38 #define USE_OCCLUSION_MAP 1  
39 #define OCCLUSION_UV v_uv  
40 #define USE_EMISSIVE_MAP 1  
41 #define EMISSIVE_UV v_uv  
42 #define OCCLUSION_CHANNEL r  
43 #define ROUGHNESS_CHANNEL g  
44 #define METALLIC_CHANNEL b  
45 #define USE_ALPHA_TEST 1  
46 #define ALPHA_TEST_CHANNEL a  
47  
48 #ifdef GL_OES_standard_derivatives  
49 #extension GL_OES_standard_derivatives: enable  
50 #endif  
51  
52 #ifdef GL_EXT_shader_texture_lod  
53 #extension GL_EXT_shader_texture_lod: enable  
54 #endif  
55  
56 precision highp float;  
57 uniform highp vec4 cc_cameraPos;  
58   uniform mediump vec4 cc_mainLitDir;  
59   uniform mediump vec4 cc_mainLitColor;  
60   uniform mediump vec4 cc_ambientSky;  
61   uniform mediump vec4 cc_ambientGround;  
62  
63  
64  
65  
66  
67  
68 #define QUATER_PI         0.78539816340  
69 #define HALF_PI           1.57079632679  
70 #define PI                3.14159265359  
71 #define PI2               6.28318530718  
72 #define PI4               12.5663706144  
73  
74 #define INV_QUATER_PI     1.27323954474  
75 #define INV_HALF_PI       0.63661977237  
76 #define INV_PI            0.31830988618  
77 #define INV_PI2           0.15915494309  
78 #define INV_PI4           0.07957747155  
79  
80 #define EPSILON           1e-6  
81 #define EPSILON_LOWP      1e-4  
82 #define LOG2              1.442695  
83 #define EXP_VALUE         2.71828183f  
84 #define FP_MAX            65504.0  
85 #define FP_SCALE          0.0009765625  
86 #define FP_SCALE_INV      1024.0  
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)  
88  
89  
90  
91  
92  
93  
94  
95 vec3 SRGBToLinear (vec3 gamma) {  
96   return gamma * gamma;  
97 }  
98 uniform highp mat4 cc_matLightView;  
99   uniform highp vec4 cc_shadowProjDepthInfo;  
100   uniform highp vec4 cc_shadowProjInfo;  
101   uniform mediump vec4 cc_shadowNFLSInfo;  
102   uniform mediump vec4 cc_shadowWHPBInfo;  
103   uniform mediump vec4 cc_shadowLPNNInfo;  
104  
105  
106  
107  
108  
109  
110  
111  
112 highp float unpackHighpData (float mainPart, float modPart) {  
113   highp float data = mainPart;  
114   return data + modPart;  
115 }  
116  
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {  
118   highp float data = mainPart * modValue;  
119   return data + modPart * modValue;  
120 }  
121  
122  
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {  
124   highp vec2 data = mainPart;  
125   return data + modPart;  
126 }  
127  
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {  
129   highp vec2 data = mainPart * modValue;  
130   return data + modPart * modValue;  
131 }  
132  
133  
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {  
135   highp vec3 data = mainPart;  
136   return data + modPart;  
137 }  
138  
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {  
140   highp vec3 data = mainPart * modValue;  
141   return data + modPart * modValue;  
142 }  
143  
144  
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {  
146   highp vec4 data = mainPart;  
147   return data + modPart;  
148 }  
149  
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {  
151   highp vec4 data = mainPart * modValue;  
152   return data + modPart * modValue;  
153 }  
154 #if CC_RECEIVE_SHADOW  
155   uniform highp sampler2D cc_shadowMap;  
156   uniform highp sampler2D cc_spotLightingMap;  
157  
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)  
159   {  
160     vec4 newShadowPos = shadowPos;  
161     if(normalBias > EPSILON_LOWP)  
162     {  
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);  
164       if(viewNormal.z < 0.1)  
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);  
166     }  
167     return newShadowPos;  
168   }  
169  
170  
171  
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)  
173   {  
174     float coeffA = cc_shadowProjDepthInfo.x;  
175     float coeffB = cc_shadowProjDepthInfo.y;  
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;  
177     viewSpacePos_z += viewspaceDepthBias;  
178     vec4 result = shadowPos;  
179     result.z = viewSpacePos_z * coeffA + coeffB;  
180     return result;  
181   }  
182  
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {  
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
190  
191     float shadow = 0.0;  
192     float closestDepth = 0.0;  
193     if (cc_shadowLPNNInfo.y > EPSILON) {  
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));  
195     } else {  
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;  
197     }  
198     shadow = step(clipPos.z, closestDepth);  
199  
200     return shadow;  
201   }  
202  
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {  
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
210  
211     float offsetDepth = clipPos.z;  
212     vec2 mapSize = cc_shadowWHPBInfo.xy;  
213     vec2 oneTap = 1.0 / mapSize;  
214     vec2 clipPos_offset = clipPos.xy + oneTap;  
215  
216     float block0, block1, block2, block3;  
217     if (cc_shadowLPNNInfo.y > EPSILON) {  
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
222     } else {  
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);  
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);  
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);  
227     }  
228  
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;  
230     float resultX = mix(block0, block1, coefX);  
231     float resultY = mix(block2, block3, coefX);  
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;  
233  
234     return mix(resultX, resultY, coefY);  
235   }  
236  
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {  
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
244  
245     float offsetDepth = clipPos.z;  
246     vec2 mapSize = cc_shadowWHPBInfo.xy;  
247     vec2 oneTap = 1.0 / mapSize;  
248     float clipPos_offset_L = clipPos.x - oneTap.x;  
249     float clipPos_offset_R = clipPos.x + oneTap.x;  
250     float clipPos_offset_U = clipPos.y - oneTap.y;  
251     float clipPos_offset_D = clipPos.y + oneTap.y;  
252  
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;  
254     if (cc_shadowLPNNInfo.y > EPSILON) {  
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
264     } else {  
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);  
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);  
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);  
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);  
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);  
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);  
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);  
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);  
274     }  
275  
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;  
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;  
278  
279     float shadow = 0.0;  
280     float resultX = mix(block0, block1, coefX);  
281     float resultY = mix(block3, block4, coefX);  
282     shadow += mix(resultX , resultY, coefY);  
283  
284     resultX = mix(block1, block2, coefX);  
285     resultY = mix(block4, block5, coefX);  
286     shadow += mix(resultX , resultY, coefY);  
287  
288     resultX = mix(block3, block4, coefX);  
289     resultY = mix(block6, block7, coefX);  
290     shadow += mix(resultX, resultY, coefY);  
291  
292     resultX = mix(block4, block5, coefX);  
293     resultY = mix(block7, block8, coefX);  
294     shadow += mix(resultX, resultY, coefY);  
295  
296     return shadow * 0.25;  
297   }  
298  
299  
300  
301  
302  
303  
304  
305  
306  
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)  
308 {  
309   float realtimeShadow = 1.0;  
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);  
311  
312   float pcf = cc_shadowWHPBInfo.z;  
313   if (pcf > 1.9) {  
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);  
315   }else if (pcf > 0.9) {  
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);  
317   }else {  
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);  
319   }  
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);  
321 }  
322 #endif  
323  
324  
325  
326 #if CC_USE_IBL  
327   uniform samplerCube cc_environment;  
328  
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {  
330  
331       #ifdef GL_EXT_shader_texture_lod  
332         return texture2DLodEXT(tex, coord, lod);  
333       #else  
334         return texture2D(tex, coord, lod);  
335       #endif  
336  
337   }  
338  
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {  
340  
341       #ifdef GL_EXT_shader_texture_lod  
342         return textureCubeLodEXT(tex, coord, lod);  
343       #else  
344         return textureCube(tex, coord, lod);  
345       #endif  
346  
347   }  
348  
349  
350  
351  
352  
353  
354  
355   vec3 unpackRGBE (vec4 rgbe) {  
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);  
357   }  
358  
359  
360   #if CC_USE_DIFFUSEMAP  
361     uniform samplerCube cc_diffuseMap;  
362   #endif  
363 #endif  
364  
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {  
366   vec3 NxH = cross(N, H);  
367   float OneMinusNoHSqr = dot(NxH, NxH);  
368   float a = roughness * roughness;  
369   float n = NoH * a;  
370   float p = a / (OneMinusNoHSqr + n * n);  
371   return p * p;  
372 }  
373  
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {  
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);  
376 }  
377  
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {  
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);  
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);  
381   vec4 r = roughness * c0 + c1;  
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;  
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;  
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);  
385   return specular * AB.x + AB.y;  
386 }  
387  
388 #if USE_REFLECTION_DENOISE  
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {  
390     #if CC_USE_IBL  
391     	float mip = roughness * mipCount;  
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;  
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));  
394  
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);  
396      	vec4 filtered = textureCube(cc_environment, R);  
397  
398       #if CC_USE_IBL == 2  
399       	biased.rgb = unpackRGBE(biased);  
400       	filtered.rgb = unpackRGBE(filtered);  
401       #else  
402       	biased.rgb = SRGBToLinear(biased.rgb);  
403       	filtered.rgb = SRGBToLinear(filtered.rgb);  
404       #endif  
405  
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);  
407     #else  
408       return vec3(0.0, 0.0, 0.0);  
409     #endif  
410   }  
411 #endif  
412  
413  
414 struct StandardSurface {  
415   vec4 albedo;  
416  
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
418   vec3 position, position_fract_part;  
419   #else  
420   vec3 position;  
421   #endif  
422   vec3 normal;  
423   vec3 emissive;  
424   vec3 lightmap;  
425   float lightmap_test;  
426   float roughness;  
427   float metallic;  
428   float occlusion;  
429   float specularIntensity;  
430  
431   #if CC_RECEIVE_SHADOW  
432     vec2 shadowBias;  
433   #endif  
434 };  
435  
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {  
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);  
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);  
440  
441   vec3 position;  
442  
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
444   position = unpackHighpData(s.position, s.position_fract_part);  
445   #else  
446   position = s.position;  
447   #endif  
448  
449   vec3 N = normalize(s.normal);  
450   vec3 V = normalize(cc_cameraPos.xyz - position);  
451  
452   float NV = max(abs(dot(N, V)), 0.0);  
453   specular = BRDFApprox(specular, s.roughness, NV);  
454  
455   vec3 L = normalize(-cc_mainLitDir.xyz);  
456   vec3 H = normalize(L + V);  
457   float NH = max(dot(N, H), 0.0);  
458   float NL = max(dot(N, L), 0.0);  
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;  
460   vec3 diffuseContrib = diffuse / PI;  
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);  
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);  
463  
464   float shadow = 1.0;  
465   #if CC_RECEIVE_SHADOW  
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {  
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);  
468     }  
469   #endif  
470  
471   dirlightContrib *= shadow;  
472   finalColor *= dirlightContrib;  
473  
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD  
475     if (s.lightmap_test > EPSILON_LOWP) {  
476       finalColor = diffuse * s.lightmap.rgb * shadow;  
477     }  
478   #endif  
479  
480   float fAmb = 0.5 - N.y * 0.5;  
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);  
482  
483  
484   #if CC_USE_IBL  
485     #if CC_USE_DIFFUSEMAP  
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);  
487       #if CC_USE_DIFFUSEMAP == 2  
488         ambDiff = unpackRGBE(diffuseMap);  
489       #else  
490         ambDiff = SRGBToLinear(diffuseMap.rgb);  
491       #endif  
492     #endif  
493  
494     vec3 R = normalize(reflect(-V, N));  
495  
496     #if USE_REFLECTION_DENOISE  
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);  
498     #else  
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);  
500  
501       #if CC_USE_IBL == 2  
502         vec3 env = unpackRGBE(envmap);  
503       #else  
504         vec3 env = SRGBToLinear(envmap.rgb);  
505       #endif  
506     #endif  
507  
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;  
509   #endif  
510  
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;  
512  
513  
514   finalColor += s.emissive;  
515  
516   return vec4(finalColor, s.albedo.a);  
517 }  
518  
519  
520  
521 vec3 ACESToneMap (vec3 color) {  
522   color = min(color, vec3(8.0));  
523   const float A = 2.51;  
524   const float B = 0.03;  
525   const float C = 2.43;  
526   const float D = 0.59;  
527   const float E = 0.14;  
528   return (color * (A * color + B)) / (color * (C * color + D) + E);  
529 }  
530  
531  
532  
533 vec4 CCFragOutput (vec4 color) {  
534   #if CC_USE_HDR  
535     color.rgb = ACESToneMap(color.rgb);  
536   #endif  
537   color.rgb = sqrt(color.rgb);  
538   return color;  
539 }  
540  
541  
542  
543      uniform vec4 rimColor;  
544      uniform vec4 albedo;  
545      uniform vec4 albedoScaleAndCutoff;  
546      uniform vec4 pbrParams;  
547      uniform vec4 emissive;  
548      uniform vec4 emissiveScaleParam;  
549  
550  
551  
552 varying vec3 v_position;  
553 varying vec3 v_view_position;  
554 varying vec2 v_uv;  
555 varying vec2 v_uv1;  
556 varying vec3 v_normal;  
557 varying vec3 v_view_normal;  
558  
559 #if USE_VERTEX_COLOR  
560   varying vec3 v_color;  
561 #endif  
562  
563 #if USE_ALBEDO_MAP  
564   uniform sampler2D albedoMap;  
565 #endif  
566 #if USE_NORMAL_MAP  
567   varying vec3 v_tangent;  
568   varying vec3 v_bitangent;  
569   uniform sampler2D normalMap;  
570 #endif  
571 #if USE_PBR_MAP  
572   uniform sampler2D pbrMap;  
573 #endif  
574 #if USE_METALLIC_ROUGHNESS_MAP  
575   uniform sampler2D metallicRoughnessMap;  
576 #endif  
577 #if USE_OCCLUSION_MAP  
578   uniform sampler2D occlusionMap;  
579 #endif  
580 #if USE_EMISSIVE_MAP  
581   uniform sampler2D emissiveMap;  
582 #endif  
583 #if CC_USE_LIGHTMAP  
584   varying vec2 v_luv;  
585   uniform sampler2D cc_lightingMap;  
586 #endif  
587 #if USE_ALPHA_TEST  
588 #endif  
589  
590 void surf (out StandardSurface s) {  
591   vec4 baseColor = albedo;  
592   #if USE_VERTEX_COLOR  
593     baseColor.rgb *= v_color;  
594   #endif  
595   #if USE_ALBEDO_MAP  
596     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);  
597     texColor.rgb = SRGBToLinear(texColor.rgb);  
598     baseColor *= texColor;  
599   #endif  
600   s.albedo = baseColor;  
601   s.albedo.rgb *= albedoScaleAndCutoff.xyz;  
602  
603   #if USE_ALPHA_TEST  
604     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;  
605   #endif  
606   float density = 0.001;  
607   float dist2 = dot(v_view_position,v_view_position);  
608   float fogFactor = exp( -density*density * dist2);  
609   fogFactor = clamp(fogFactor, 0.0, 1.0);  
610  
611   vec3 fogColor = vec3(1.0,1,1.0);  
612   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);  
613  
614   s.normal = v_normal;  
615   #if USE_NORMAL_MAP  
616     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);  
617     s.normal =  
618       (nmmp.x * pbrParams.w) * normalize(v_tangent) +  
619       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +  
620       nmmp.z * normalize(s.normal);  
621   #endif  
622  
623   s.position = v_position;  
624  
625   vec4 pbr = pbrParams;  
626   #if USE_PBR_MAP  
627     vec4 res = texture2D(pbrMap, PBR_UV);  
628     pbr.x *= res.OCCLUSION_CHANNEL;  
629     pbr.y *= res.ROUGHNESS_CHANNEL;  
630     pbr.z *= res.METALLIC_CHANNEL;  
631   #endif  
632   #if USE_METALLIC_ROUGHNESS_MAP  
633     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);  
634     pbr.z *= metallicRoughness.METALLIC_CHANNEL;  
635     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;  
636   #endif  
637   #if USE_OCCLUSION_MAP  
638     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;  
639   #endif  
640   s.occlusion = clamp(pbr.x, 0.0, 0.96);  
641   s.roughness = clamp(pbr.y, 0.04, 1.0);  
642   s.specularIntensity = 0.5;  
643   s.metallic = pbr.z;  
644  
645   s.emissive = emissive.rgb * emissiveScaleParam.xyz;  
646   #if USE_EMISSIVE_MAP  
647     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);  
648   #endif  
649 }  
650  
651 vec4 frag () {  
652   StandardSurface s; surf(s);  
653   vec4 color = CCStandardShadingBase(s, v_shadowPos);  
654  
655   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING  
656     vec4 lighting = texture2D(cc_lightingMap, v_luv);  
657  
658     float fAmb = 0.5 - s.normal.y * 0.5;  
659     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;  
660  
661     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);  
662     finalColor += lighting.rgb *  s.albedo.rgb;  
663     finalColor = finalColor * s.occlusion;  
664     finalColor += s.emissive;  
665  
666     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;  
667   #endif  
668  
669   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;  
670  
671   color.rgb = mix(color.rgb,rimColor.rgb,fRim);  
672  
673   return CCFragOutput(color);  
674 }  
675  
676  
677 void main() { gl_FragColor = frag(); }  
678  
at Object.encode (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-worker/node_modules/v-stacks/index.js:14:17)  
at Logger._logHandler (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-worker/static/script.ccc:1:531)  
at Logger.record (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:458)  
at console.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:1414)  
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at runMicrotasks (<anonymous>)  
at runNextTicks (internal/process/task_queues.js:58:5)  
at processImmediate (internal/timers.js:434:9)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)
2022-06-23T02:44:06.201Z - error: [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos   
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at runMicrotasks (<anonymous>)  
at runNextTicks (internal/process/task_queues.js:58:5)  
at processImmediate (internal/timers.js:434:9)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)
2022-06-23T02:44:48.002Z - error: [Asset DB] ../res/rim_light.effect - standard-fs:frag: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:570: 'v_shadowPos' : redefinition
 

1 #version 100
2 #define USE_INSTANCING 1
3 #define USE_BATCHING 1
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
13 #define CC_USE_SKINNING 1
14 #define CC_USE_BAKED_ANIMATION 1
15 #define CC_USE_LIGHTMAP 1
16 #define CC_RECEIVE_SHADOW 1
17 #define CC_USE_MORPH 1
18 #define CC_MORPH_TARGET_COUNT 2
19 #define CC_MORPH_PRECOMPUTED 1
20 #define CC_MORPH_TARGET_HAS_POSITION 1
21 #define CC_MORPH_TARGET_HAS_NORMAL 1
22 #define CC_MORPH_TARGET_HAS_TANGENT 1
23 #define USE_VERTEX_COLOR 1
24 #define USE_NORMAL_MAP 1
25 #define HAS_SECOND_UV 1
26 #define CC_USE_IBL 0
27 #define CC_USE_DIFFUSEMAP 0
28 #define USE_REFLECTION_DENOISE 1
29 #define CC_FORWARD_ADD 1
30 #define CC_USE_HDR 1
31 #define USE_ALBEDO_MAP 1
32 #define ALBEDO_UV v_uv
33 #define NORMAL_UV v_uv
34 #define USE_PBR_MAP 1
35 #define PBR_UV v_uv
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define METALLIC_ROUGHNESS_UV v_uv
38 #define USE_OCCLUSION_MAP 1
39 #define OCCLUSION_UV v_uv
40 #define USE_EMISSIVE_MAP 1
41 #define EMISSIVE_UV v_uv
42 #define OCCLUSION_CHANNEL r
43 #define ROUGHNESS_CHANNEL g
44 #define METALLIC_CHANNEL b
45 #define USE_ALPHA_TEST 1
46 #define ALPHA_TEST_CHANNEL a
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp vec4 cc_cameraPos;
58   uniform mediump vec4 cc_mainLitDir;
59   uniform mediump vec4 cc_mainLitColor;
60   uniform mediump vec4 cc_ambientSky;
61   uniform mediump vec4 cc_ambientGround;
62 
63 
64 
65 
66 
67 
68 #define QUATER_PI         0.78539816340
69 #define HALF_PI           1.57079632679
70 #define PI                3.14159265359
71 #define PI2               6.28318530718
72 #define PI4               12.5663706144
73      
74 #define INV_QUATER_PI     1.27323954474
75 #define INV_HALF_PI       0.63661977237
76 #define INV_PI            0.31830988618
77 #define INV_PI2           0.15915494309
78 #define INV_PI4           0.07957747155
79      
80 #define EPSILON           1e-6
81 #define EPSILON_LOWP      1e-4
82 #define LOG2              1.442695
83 #define EXP_VALUE         2.71828183f
84 #define FP_MAX            65504.0
85 #define FP_SCALE          0.0009765625
86 #define FP_SCALE_INV      1024.0
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
88 
89 
90 
91 
92 
93 
94 
95 vec3 SRGBToLinear (vec3 gamma) {
96   return gamma * gamma;
97 }
98 uniform highp mat4 cc_matLightView;
99   uniform highp vec4 cc_shadowProjDepthInfo;
100   uniform highp vec4 cc_shadowProjInfo;
101   uniform mediump vec4 cc_shadowNFLSInfo;
102   uniform mediump vec4 cc_shadowWHPBInfo;
103   uniform mediump vec4 cc_shadowLPNNInfo;
104 
105 
106 
107 
108 
109 
110 
111 
112 highp float unpackHighpData (float mainPart, float modPart) {
113   highp float data = mainPart;
114   return data + modPart;
115 }
116 
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
118   highp float data = mainPart * modValue;
119   return data + modPart * modValue;
120 }
121 
122 
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
124   highp vec2 data = mainPart;
125   return data + modPart;
126 }
127 
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
129   highp vec2 data = mainPart * modValue;
130   return data + modPart * modValue;
131 }
132 
133 
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
135   highp vec3 data = mainPart;
136   return data + modPart;
137 }
138 
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
140   highp vec3 data = mainPart * modValue;
141   return data + modPart * modValue;
142 }
143 
144 
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
146   highp vec4 data = mainPart;
147   return data + modPart;
148 }
149 
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
151   highp vec4 data = mainPart * modValue;
152   return data + modPart * modValue;
153 }
154 #if CC_RECEIVE_SHADOW
155   uniform highp sampler2D cc_shadowMap;
156   uniform highp sampler2D cc_spotLightingMap;
157 
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
159   {
160     vec4 newShadowPos = shadowPos;
161     if(normalBias > EPSILON_LOWP)
162     {
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
164       if(viewNormal.z < 0.1)
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
166     }
167     return newShadowPos;
168   }
169   
170   
171 
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
173   {
174     float coeffA = cc_shadowProjDepthInfo.x;
175     float coeffB = cc_shadowProjDepthInfo.y;
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
177     viewSpacePos_z += viewspaceDepthBias;
178     vec4 result = shadowPos;
179     result.z = viewSpacePos_z * coeffA + coeffB;
180     return result;
181   }
182   
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
190 
191     float shadow = 0.0;
192     float closestDepth = 0.0;
193     if (cc_shadowLPNNInfo.y > EPSILON) {
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
195     } else {
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
197     }
198     shadow = step(clipPos.z, closestDepth);
199 
200     return shadow;
201   }
202 
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
210 
211     float offsetDepth = clipPos.z;
212     vec2 mapSize = cc_shadowWHPBInfo.xy;
213     vec2 oneTap = 1.0 / mapSize;
214     vec2 clipPos_offset = clipPos.xy + oneTap;
215 
216     float block0, block1, block2, block3;
217     if (cc_shadowLPNNInfo.y > EPSILON) {
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
222     } else {
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
227     }
228 
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
230     float resultX = mix(block0, block1, coefX);
231     float resultY = mix(block2, block3, coefX);
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
233 
234     return mix(resultX, resultY, coefY);
235   }
236 
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
244 
245     float offsetDepth = clipPos.z;
246     vec2 mapSize = cc_shadowWHPBInfo.xy;
247     vec2 oneTap = 1.0 / mapSize;
248     float clipPos_offset_L = clipPos.x - oneTap.x;
249     float clipPos_offset_R = clipPos.x + oneTap.x;
250     float clipPos_offset_U = clipPos.y - oneTap.y;
251     float clipPos_offset_D = clipPos.y + oneTap.y;
252 
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
254     if (cc_shadowLPNNInfo.y > EPSILON) {
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
264     } else {
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
274     }
275 
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
278 
279     float shadow = 0.0;
280     float resultX = mix(block0, block1, coefX);
281     float resultY = mix(block3, block4, coefX);
282     shadow += mix(resultX , resultY, coefY);
283 
284     resultX = mix(block1, block2, coefX);
285     resultY = mix(block4, block5, coefX);
286     shadow += mix(resultX , resultY, coefY);
287 
288     resultX = mix(block3, block4, coefX);
289     resultY = mix(block6, block7, coefX);
290     shadow += mix(resultX, resultY, coefY);
291 
292     resultX = mix(block4, block5, coefX);
293     resultY = mix(block7, block8, coefX);
294     shadow += mix(resultX, resultY, coefY);
295 
296     return shadow * 0.25;
297   }
298 
299   
300 
301   
302 
303   
304 
305 
306 
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
308 {
309   float realtimeShadow = 1.0;
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
311   
312   float pcf = cc_shadowWHPBInfo.z;
313   if (pcf > 1.9) { 
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
315   }else if (pcf > 0.9) {
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
317   }else { 
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
319   }
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
321 }
322 #endif
323 
324 
325 
326 #if CC_USE_IBL
327   uniform samplerCube cc_environment;
328   
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
330     
331       #ifdef GL_EXT_shader_texture_lod
332         return texture2DLodEXT(tex, coord, lod);
333       #else
334         return texture2D(tex, coord, lod);
335       #endif
336     
337   }
338   
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
340     
341       #ifdef GL_EXT_shader_texture_lod
342         return textureCubeLodEXT(tex, coord, lod);
343       #else
344         return textureCube(tex, coord, lod);
345       #endif
346     
347   }
348   
349   
350   
351   
352   
353   
354   
355   vec3 unpackRGBE (vec4 rgbe) {
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
357   }
358   
359 
360   #if CC_USE_DIFFUSEMAP
361     uniform samplerCube cc_diffuseMap;
362   #endif
363 #endif
364 
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
366   vec3 NxH = cross(N, H);
367   float OneMinusNoHSqr = dot(NxH, NxH);
368   float a = roughness * roughness;
369   float n = NoH * a;
370   float p = a / (OneMinusNoHSqr + n * n);
371   return p * p;
372 }
373 
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
376 }
377 
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
381   vec4 r = roughness * c0 + c1;
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
385   return specular * AB.x + AB.y;
386 }
387 
388 #if USE_REFLECTION_DENOISE
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
390     #if CC_USE_IBL
391     	float mip = roughness * mipCount;
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
394 
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
396      	vec4 filtered = textureCube(cc_environment, R);
397 
398       #if CC_USE_IBL == 2
399       	biased.rgb = unpackRGBE(biased);
400       	filtered.rgb = unpackRGBE(filtered);
401       #else
402       	biased.rgb = SRGBToLinear(biased.rgb);
403       	filtered.rgb = SRGBToLinear(filtered.rgb);
404       #endif
405       	
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
407     #else
408       return vec3(0.0, 0.0, 0.0);
409     #endif
410   }
411 #endif
412 
413 
414 struct StandardSurface {
415   vec4 albedo;
416   
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
418   vec3 position, position_fract_part;
419   #else
420   vec3 position;
421   #endif
422   vec3 normal;
423   vec3 emissive;
424   vec3 lightmap;
425   float lightmap_test;
426   float roughness;
427   float metallic;
428   float occlusion;
429   float specularIntensity;
430 
431   #if CC_RECEIVE_SHADOW
432     vec2 shadowBias;
433   #endif
434 };
435 
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
440 
441   vec3 position;
442   
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
444   position = unpackHighpData(s.position, s.position_fract_part);
445   #else
446   position = s.position;
447   #endif
448 
449   vec3 N = normalize(s.normal);
450   vec3 V = normalize(cc_cameraPos.xyz - position);
451 
452   float NV = max(abs(dot(N, V)), 0.0);
453   specular = BRDFApprox(specular, s.roughness, NV);
454 
455   vec3 L = normalize(-cc_mainLitDir.xyz);
456   vec3 H = normalize(L + V);
457   float NH = max(dot(N, H), 0.0);
458   float NL = max(dot(N, L), 0.0);
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
460   vec3 diffuseContrib = diffuse / PI;
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);
463 
464   float shadow = 1.0;
465   #if CC_RECEIVE_SHADOW
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
468     }
469   #endif
470 
471   dirlightContrib *= shadow;
472   finalColor *= dirlightContrib;
473 
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
475     if (s.lightmap_test > EPSILON_LOWP) {
476       finalColor = diffuse * s.lightmap.rgb * shadow;
477     }
478   #endif
479 
480   float fAmb = 0.5 - N.y * 0.5;
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
482 
483 
484   #if CC_USE_IBL
485     #if CC_USE_DIFFUSEMAP
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
487       #if CC_USE_DIFFUSEMAP == 2
488         ambDiff = unpackRGBE(diffuseMap);
489       #else
490         ambDiff = SRGBToLinear(diffuseMap.rgb);
491       #endif
492     #endif
493 
494     vec3 R = normalize(reflect(-V, N));
495 
496     #if USE_REFLECTION_DENOISE
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
498     #else
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
500 
501       #if CC_USE_IBL == 2
502         vec3 env = unpackRGBE(envmap);
503       #else
504         vec3 env = SRGBToLinear(envmap.rgb);
505       #endif
506     #endif
507 
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
509   #endif
510 
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
512   
513 
514   finalColor += s.emissive;
515 
516   return vec4(finalColor, s.albedo.a);
517 }
518 
519 
520 
521 vec3 ACESToneMap (vec3 color) {
522   color = min(color, vec3(8.0));
523   const float A = 2.51;
524   const float B = 0.03;
525   const float C = 2.43;
526   const float D = 0.59;
527   const float E = 0.14;
528   return (color * (A * color + B)) / (color * (C * color + D) + E);
529 }
530 
531 
532 
533 vec4 CCFragOutput (vec4 color) {
534   #if CC_USE_HDR
535     color.rgb = ACESToneMap(color.rgb);
536   #endif
537   color.rgb = sqrt(color.rgb);
538   return color;
539 }
540 
541 
542 
543      uniform vec4 rimColor;
544      uniform vec4 albedo;
545      uniform vec4 albedoScaleAndCutoff;
546      uniform vec4 pbrParams;
547      uniform vec4 emissive;
548      uniform vec4 emissiveScaleParam;
549 
550 
551 
552 
553 varying highp vec4 v_shadowPos;
554 
555 
556 
557 #if CC_RECEIVE_SHADOW
558 
559 
560 
561 #endif
562 
563 
564 varying vec3 v_position;
565 varying vec3 v_view_position;
566 varying vec2 v_uv;
567 varying vec2 v_uv1;
568 varying vec3 v_normal;
569 varying vec3 v_view_normal;
570 varying highp vec4 v_shadowPos;
571 
572 #if USE_VERTEX_COLOR
573   varying vec3 v_color;
574 #endif
575 
576 #if USE_ALBEDO_MAP
577   uniform sampler2D albedoMap;
578 #endif
579 #if USE_NORMAL_MAP
580   varying vec3 v_tangent;
581   varying vec3 v_bitangent;
582   uniform sampler2D normalMap;
583 #endif
584 #if USE_PBR_MAP
585   uniform sampler2D pbrMap;
586 #endif
587 #if USE_METALLIC_ROUGHNESS_MAP
588   uniform sampler2D metallicRoughnessMap;
589 #endif
590 #if USE_OCCLUSION_MAP
591   uniform sampler2D occlusionMap;
592 #endif
593 #if USE_EMISSIVE_MAP
594   uniform sampler2D emissiveMap;
595 #endif
596 #if CC_USE_LIGHTMAP
597   varying vec2 v_luv;
598   uniform sampler2D cc_lightingMap;
599 #endif
600 #if USE_ALPHA_TEST
601 #endif
602 
603 void surf (out StandardSurface s) {
604   vec4 baseColor = albedo;
605   #if USE_VERTEX_COLOR
606     baseColor.rgb *= v_color;
607   #endif
608   #if USE_ALBEDO_MAP
609     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);
610     texColor.rgb = SRGBToLinear(texColor.rgb);
611     baseColor *= texColor;
612   #endif
613   s.albedo = baseColor;
614   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
615 
616   #if USE_ALPHA_TEST
617     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
618   #endif
619   float density = 0.001;
620   float dist2 = dot(v_view_position,v_view_position);
621   float fogFactor = exp( -density*density * dist2);
622   fogFactor = clamp(fogFactor, 0.0, 1.0);
623 
624   vec3 fogColor = vec3(1.0,1,1.0);
625   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);
626 
627   s.normal = v_normal;
628   #if USE_NORMAL_MAP
629     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);
630     s.normal =
631       (nmmp.x * pbrParams.w) * normalize(v_tangent) +
632       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +
633       nmmp.z * normalize(s.normal);
634   #endif
635 
636   s.position = v_position;
637 
638   vec4 pbr = pbrParams;
639   #if USE_PBR_MAP
640     vec4 res = texture2D(pbrMap, PBR_UV);
641     pbr.x *= res.OCCLUSION_CHANNEL;
642     pbr.y *= res.ROUGHNESS_CHANNEL;
643     pbr.z *= res.METALLIC_CHANNEL;
644   #endif
645   #if USE_METALLIC_ROUGHNESS_MAP
646     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);
647     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
648     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
649   #endif
650   #if USE_OCCLUSION_MAP
651     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;
652   #endif
653   s.occlusion = clamp(pbr.x, 0.0, 0.96);
654   s.roughness = clamp(pbr.y, 0.04, 1.0);
655   s.specularIntensity = 0.5;
656   s.metallic = pbr.z;
657 
658   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
659   #if USE_EMISSIVE_MAP
660     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);
661   #endif
662 }
663 
664 vec4 frag () {
665   StandardSurface s; surf(s);
666   vec4 color = CCStandardShadingBase(s, v_shadowPos);
667 
668   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING
669     vec4 lighting = texture2D(cc_lightingMap, v_luv);
670 
671     float fAmb = 0.5 - s.normal.y * 0.5;
672     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
673 
674     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);
675     finalColor += lighting.rgb *  s.albedo.rgb;
676     finalColor = finalColor * s.occlusion;
677     finalColor += s.emissive;
678 
679     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;
680   #endif
681 
682   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;
683 
684   color.rgb = mix(color.rgb,rimColor.rgb,fRim);
685 
686   return CCFragOutput(color);
687 }
688 
689 
690 void main() { gl_FragColor = frag(); }
691 [Asset DB] ../res/rim_light.effect - standard-fs:frag: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:570: 'v_shadowPos' : redefinition
 

1 #version 100
2 #define USE_INSTANCING 1
3 #define USE_BATCHING 1
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
13 #define CC_USE_SKINNING 1
14 #define CC_USE_BAKED_ANIMATION 1
15 #define CC_USE_LIGHTMAP 1
16 #define CC_RECEIVE_SHADOW 1
17 #define CC_USE_MORPH 1
18 #define CC_MORPH_TARGET_COUNT 2
19 #define CC_MORPH_PRECOMPUTED 1
20 #define CC_MORPH_TARGET_HAS_POSITION 1
21 #define CC_MORPH_TARGET_HAS_NORMAL 1
22 #define CC_MORPH_TARGET_HAS_TANGENT 1
23 #define USE_VERTEX_COLOR 1
24 #define USE_NORMAL_MAP 1
25 #define HAS_SECOND_UV 1
26 #define CC_USE_IBL 0
27 #define CC_USE_DIFFUSEMAP 0
28 #define USE_REFLECTION_DENOISE 1
29 #define CC_FORWARD_ADD 1
30 #define CC_USE_HDR 1
31 #define USE_ALBEDO_MAP 1
32 #define ALBEDO_UV v_uv
33 #define NORMAL_UV v_uv
34 #define USE_PBR_MAP 1
35 #define PBR_UV v_uv
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define METALLIC_ROUGHNESS_UV v_uv
38 #define USE_OCCLUSION_MAP 1
39 #define OCCLUSION_UV v_uv
40 #define USE_EMISSIVE_MAP 1
41 #define EMISSIVE_UV v_uv
42 #define OCCLUSION_CHANNEL r
43 #define ROUGHNESS_CHANNEL g
44 #define METALLIC_CHANNEL b
45 #define USE_ALPHA_TEST 1
46 #define ALPHA_TEST_CHANNEL a
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp vec4 cc_cameraPos;
58   uniform mediump vec4 cc_mainLitDir;
59   uniform mediump vec4 cc_mainLitColor;
60   uniform mediump vec4 cc_ambientSky;
61   uniform mediump vec4 cc_ambientGround;
62 
63 
64 
65 
66 
67 
68 #define QUATER_PI         0.78539816340
69 #define HALF_PI           1.57079632679
70 #define PI                3.14159265359
71 #define PI2               6.28318530718
72 #define PI4               12.5663706144
73      
74 #define INV_QUATER_PI     1.27323954474
75 #define INV_HALF_PI       0.63661977237
76 #define INV_PI            0.31830988618
77 #define INV_PI2           0.15915494309
78 #define INV_PI4           0.07957747155
79      
80 #define EPSILON           1e-6
81 #define EPSILON_LOWP      1e-4
82 #define LOG2              1.442695
83 #define EXP_VALUE         2.71828183f
84 #define FP_MAX            65504.0
85 #define FP_SCALE          0.0009765625
86 #define FP_SCALE_INV      1024.0
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
88 
89 
90 
91 
92 
93 
94 
95 vec3 SRGBToLinear (vec3 gamma) {
96   return gamma * gamma;
97 }
98 uniform highp mat4 cc_matLightView;
99   uniform highp vec4 cc_shadowProjDepthInfo;
100   uniform highp vec4 cc_shadowProjInfo;
101   uniform mediump vec4 cc_shadowNFLSInfo;
102   uniform mediump vec4 cc_shadowWHPBInfo;
103   uniform mediump vec4 cc_shadowLPNNInfo;
104 
105 
106 
107 
108 
109 
110 
111 
112 highp float unpackHighpData (float mainPart, float modPart) {
113   highp float data = mainPart;
114   return data + modPart;
115 }
116 
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
118   highp float data = mainPart * modValue;
119   return data + modPart * modValue;
120 }
121 
122 
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
124   highp vec2 data = mainPart;
125   return data + modPart;
126 }
127 
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
129   highp vec2 data = mainPart * modValue;
130   return data + modPart * modValue;
131 }
132 
133 
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
135   highp vec3 data = mainPart;
136   return data + modPart;
137 }
138 
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
140   highp vec3 data = mainPart * modValue;
141   return data + modPart * modValue;
142 }
143 
144 
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
146   highp vec4 data = mainPart;
147   return data + modPart;
148 }
149 
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
151   highp vec4 data = mainPart * modValue;
152   return data + modPart * modValue;
153 }
154 #if CC_RECEIVE_SHADOW
155   uniform highp sampler2D cc_shadowMap;
156   uniform highp sampler2D cc_spotLightingMap;
157 
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
159   {
160     vec4 newShadowPos = shadowPos;
161     if(normalBias > EPSILON_LOWP)
162     {
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
164       if(viewNormal.z < 0.1)
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
166     }
167     return newShadowPos;
168   }
169   
170   
171 
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
173   {
174     float coeffA = cc_shadowProjDepthInfo.x;
175     float coeffB = cc_shadowProjDepthInfo.y;
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
177     viewSpacePos_z += viewspaceDepthBias;
178     vec4 result = shadowPos;
179     result.z = viewSpacePos_z * coeffA + coeffB;
180     return result;
181   }
182   
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
190 
191     float shadow = 0.0;
192     float closestDepth = 0.0;
193     if (cc_shadowLPNNInfo.y > EPSILON) {
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
195     } else {
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
197     }
198     shadow = step(clipPos.z, closestDepth);
199 
200     return shadow;
201   }
202 
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
210 
211     float offsetDepth = clipPos.z;
212     vec2 mapSize = cc_shadowWHPBInfo.xy;
213     vec2 oneTap = 1.0 / mapSize;
214     vec2 clipPos_offset = clipPos.xy + oneTap;
215 
216     float block0, block1, block2, block3;
217     if (cc_shadowLPNNInfo.y > EPSILON) {
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
222     } else {
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
227     }
228 
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
230     float resultX = mix(block0, block1, coefX);
231     float resultY = mix(block2, block3, coefX);
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
233 
234     return mix(resultX, resultY, coefY);
235   }
236 
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
244 
245     float offsetDepth = clipPos.z;
246     vec2 mapSize = cc_shadowWHPBInfo.xy;
247     vec2 oneTap = 1.0 / mapSize;
248     float clipPos_offset_L = clipPos.x - oneTap.x;
249     float clipPos_offset_R = clipPos.x + oneTap.x;
250     float clipPos_offset_U = clipPos.y - oneTap.y;
251     float clipPos_offset_D = clipPos.y + oneTap.y;
252 
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
254     if (cc_shadowLPNNInfo.y > EPSILON) {
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
264     } else {
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
274     }
275 
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
278 
279     float shadow = 0.0;
280     float resultX = mix(block0, block1, coefX);
281     float resultY = mix(block3, block4, coefX);
282     shadow += mix(resultX , resultY, coefY);
283 
284     resultX = mix(block1, block2, coefX);
285     resultY = mix(block4, block5, coefX);
286     shadow += mix(resultX , resultY, coefY);
287 
288     resultX = mix(block3, block4, coefX);
289     resultY = mix(block6, block7, coefX);
290     shadow += mix(resultX, resultY, coefY);
291 
292     resultX = mix(block4, block5, coefX);
293     resultY = mix(block7, block8, coefX);
294     shadow += mix(resultX, resultY, coefY);
295 
296     return shadow * 0.25;
297   }
298 
299   
300 
301   
302 
303   
304 
305 
306 
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
308 {
309   float realtimeShadow = 1.0;
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
311   
312   float pcf = cc_shadowWHPBInfo.z;
313   if (pcf > 1.9) { 
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
315   }else if (pcf > 0.9) {
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
317   }else { 
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
319   }
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
321 }
322 #endif
323 
324 
325 
326 #if CC_USE_IBL
327   uniform samplerCube cc_environment;
328   
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
330     
331       #ifdef GL_EXT_shader_texture_lod
332         return texture2DLodEXT(tex, coord, lod);
333       #else
334         return texture2D(tex, coord, lod);
335       #endif
336     
337   }
338   
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
340     
341       #ifdef GL_EXT_shader_texture_lod
342         return textureCubeLodEXT(tex, coord, lod);
343       #else
344         return textureCube(tex, coord, lod);
345       #endif
346     
347   }
348   
349   
350   
351   
352   
353   
354   
355   vec3 unpackRGBE (vec4 rgbe) {
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
357   }
358   
359 
360   #if CC_USE_DIFFUSEMAP
361     uniform samplerCube cc_diffuseMap;
362   #endif
363 #endif
364 
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
366   vec3 NxH = cross(N, H);
367   float OneMinusNoHSqr = dot(NxH, NxH);
368   float a = roughness * roughness;
369   float n = NoH * a;
370   float p = a / (OneMinusNoHSqr + n * n);
371   return p * p;
372 }
373 
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
376 }
377 
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
381   vec4 r = roughness * c0 + c1;
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
385   return specular * AB.x + AB.y;
386 }
387 
388 #if USE_REFLECTION_DENOISE
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
390     #if CC_USE_IBL
391     	float mip = roughness * mipCount;
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
394 
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
396      	vec4 filtered = textureCube(cc_environment, R);
397 
398       #if CC_USE_IBL == 2
399       	biased.rgb = unpackRGBE(biased);
400       	filtered.rgb = unpackRGBE(filtered);
401       #else
402       	biased.rgb = SRGBToLinear(biased.rgb);
403       	filtered.rgb = SRGBToLinear(filtered.rgb);
404       #endif
405       	
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
407     #else
408       return vec3(0.0, 0.0, 0.0);
409     #endif
410   }
411 #endif
412 
413 
414 struct StandardSurface {
415   vec4 albedo;
416   
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
418   vec3 position, position_fract_part;
419   #else
420   vec3 position;
421   #endif
422   vec3 normal;
423   vec3 emissive;
424   vec3 lightmap;
425   float lightmap_test;
426   float roughness;
427   float metallic;
428   float occlusion;
429   float specularIntensity;
430 
431   #if CC_RECEIVE_SHADOW
432     vec2 shadowBias;
433   #endif
434 };
435 
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
440 
441   vec3 position;
442   
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
444   position = unpackHighpData(s.position, s.position_fract_part);
445   #else
446   position = s.position;
447   #endif
448 
449   vec3 N = normalize(s.normal);
450   vec3 V = normalize(cc_cameraPos.xyz - position);
451 
452   float NV = max(abs(dot(N, V)), 0.0);
453   specular = BRDFApprox(specular, s.roughness, NV);
454 
455   vec3 L = normalize(-cc_mainLitDir.xyz);
456   vec3 H = normalize(L + V);
457   float NH = max(dot(N, H), 0.0);
458   float NL = max(dot(N, L), 0.0);
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
460   vec3 diffuseContrib = diffuse / PI;
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);
463 
464   float shadow = 1.0;
465   #if CC_RECEIVE_SHADOW
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
468     }
469   #endif
470 
471   dirlightContrib *= shadow;
472   finalColor *= dirlightContrib;
473 
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
475     if (s.lightmap_test > EPSILON_LOWP) {
476       finalColor = diffuse * s.lightmap.rgb * shadow;
477     }
478   #endif
479 
480   float fAmb = 0.5 - N.y * 0.5;
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
482 
483 
484   #if CC_USE_IBL
485     #if CC_USE_DIFFUSEMAP
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
487       #if CC_USE_DIFFUSEMAP == 2
488         ambDiff = unpackRGBE(diffuseMap);
489       #else
490         ambDiff = SRGBToLinear(diffuseMap.rgb);
491       #endif
492     #endif
493 
494     vec3 R = normalize(reflect(-V, N));
495 
496     #if USE_REFLECTION_DENOISE
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
498     #else
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
500 
501       #if CC_USE_IBL == 2
502         vec3 env = unpackRGBE(envmap);
503       #else
504         vec3 env = SRGBToLinear(envmap.rgb);
505       #endif
506     #endif
507 
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
509   #endif
510 
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
512   
513 
514   finalColor += s.emissive;
515 
516   return vec4(finalColor, s.albedo.a);
517 }
518 
519 
520 
521 vec3 ACESToneMap (vec3 color) {
522   color = min(color, vec3(8.0));
523   const float A = 2.51;
524   const float B = 0.03;
525   const float C = 2.43;
526   const float D = 0.59;
527   const float E = 0.14;
528   return (color * (A * color + B)) / (color * (C * color + D) + E);
529 }
530 
531 
532 
533 vec4 CCFragOutput (vec4 color) {
534   #if CC_USE_HDR
535     color.rgb = ACESToneMap(color.rgb);
536   #endif
537   color.rgb = sqrt(color.rgb);
538   return color;
539 }
540 
541 
542 
543      uniform vec4 rimColor;
544      uniform vec4 albedo;
545      uniform vec4 albedoScaleAndCutoff;
546      uniform vec4 pbrParams;
547      uniform vec4 emissive;
548      uniform vec4 emissiveScaleParam;
549 
550 
551 
552 
553 varying highp vec4 v_shadowPos;
554 
555 
556 
557 #if CC_RECEIVE_SHADOW
558 
559 
560 
561 #endif
562 
563 
564 varying vec3 v_position;
565 varying vec3 v_view_position;
566 varying vec2 v_uv;
567 varying vec2 v_uv1;
568 varying vec3 v_normal;
569 varying vec3 v_view_normal;
570 varying highp vec4 v_shadowPos;
571 
572 #if USE_VERTEX_COLOR
573   varying vec3 v_color;
574 #endif
575 
576 #if USE_ALBEDO_MAP
577   uniform sampler2D albedoMap;
578 #endif
579 #if USE_NORMAL_MAP
580   varying vec3 v_tangent;
581   varying vec3 v_bitangent;
582   uniform sampler2D normalMap;
583 #endif
584 #if USE_PBR_MAP
585   uniform sampler2D pbrMap;
586 #endif
587 #if USE_METALLIC_ROUGHNESS_MAP
588   uniform sampler2D metallicRoughnessMap;
589 #endif
590 #if USE_OCCLUSION_MAP
591   uniform sampler2D occlusionMap;
592 #endif
593 #if USE_EMISSIVE_MAP
594   uniform sampler2D emissiveMap;
595 #endif
596 #if CC_USE_LIGHTMAP
597   varying vec2 v_luv;
598   uniform sampler2D cc_lightingMap;
599 #endif
600 #if USE_ALPHA_TEST
601 #endif
602 
603 void surf (out StandardSurface s) {
604   vec4 baseColor = albedo;
605   #if USE_VERTEX_COLOR
606     baseColor.rgb *= v_color;
607   #endif
608   #if USE_ALBEDO_MAP
609     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);
610     texColor.rgb = SRGBToLinear(texColor.rgb);
611     baseColor *= texColor;
612   #endif
613   s.albedo = baseColor;
614   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
615 
616   #if USE_ALPHA_TEST
617     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
618   #endif
619   float density = 0.001;
620   float dist2 = dot(v_view_position,v_view_position);
621   float fogFactor = exp( -density*density * dist2);
622   fogFactor = clamp(fogFactor, 0.0, 1.0);
623 
624   vec3 fogColor = vec3(1.0,1,1.0);
625   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);
626 
627   s.normal = v_normal;
628   #if USE_NORMAL_MAP
629     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);
630     s.normal =
631       (nmmp.x * pbrParams.w) * normalize(v_tangent) +
632       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +
633       nmmp.z * normalize(s.normal);
634   #endif
635 
636   s.position = v_position;
637 
638   vec4 pbr = pbrParams;
639   #if USE_PBR_MAP
640     vec4 res = texture2D(pbrMap, PBR_UV);
641     pbr.x *= res.OCCLUSION_CHANNEL;
642     pbr.y *= res.ROUGHNESS_CHANNEL;
643     pbr.z *= res.METALLIC_CHANNEL;
644   #endif
645   #if USE_METALLIC_ROUGHNESS_MAP
646     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);
647     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
648     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
649   #endif
650   #if USE_OCCLUSION_MAP
651     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;
652   #endif
653   s.occlusion = clamp(pbr.x, 0.0, 0.96);
654   s.roughness = clamp(pbr.y, 0.04, 1.0);
655   s.specularIntensity = 0.5;
656   s.metallic = pbr.z;
657 
658   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
659   #if USE_EMISSIVE_MAP
660     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);
661   #endif
662 }
663 
664 vec4 frag () {
665   StandardSurface s; surf(s);
666   vec4 color = CCStandardShadingBase(s, v_shadowPos);
667 
668   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING
669     vec4 lighting = texture2D(cc_lightingMap, v_luv);
670 
671     float fAmb = 0.5 - s.normal.y * 0.5;
672     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
673 
674     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);
675     finalColor += lighting.rgb *  s.albedo.rgb;
676     finalColor = finalColor * s.occlusion;
677     finalColor += s.emissive;
678 
679     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;
680   #endif
681 
682   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;
683 
684   color.rgb = mix(color.rgb,rimColor.rgb,fRim);
685 
686   return CCFragOutput(color);
687 }
688 
689 
690 void main() { gl_FragColor = frag(); }
691   
2 #define USE_INSTANCING 1  
3 #define USE_BATCHING 1  
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1  
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024  
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024  
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128  
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128  
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0  
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0  
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0  
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0  
13 #define CC_USE_SKINNING 1  
14 #define CC_USE_BAKED_ANIMATION 1  
15 #define CC_USE_LIGHTMAP 1  
16 #define CC_RECEIVE_SHADOW 1  
17 #define CC_USE_MORPH 1  
18 #define CC_MORPH_TARGET_COUNT 2  
19 #define CC_MORPH_PRECOMPUTED 1  
20 #define CC_MORPH_TARGET_HAS_POSITION 1  
21 #define CC_MORPH_TARGET_HAS_NORMAL 1  
22 #define CC_MORPH_TARGET_HAS_TANGENT 1  
23 #define USE_VERTEX_COLOR 1  
24 #define USE_NORMAL_MAP 1  
25 #define HAS_SECOND_UV 1  
26 #define CC_USE_IBL 0  
27 #define CC_USE_DIFFUSEMAP 0  
28 #define USE_REFLECTION_DENOISE 1  
29 #define CC_FORWARD_ADD 1  
30 #define CC_USE_HDR 1  
31 #define USE_ALBEDO_MAP 1  
32 #define ALBEDO_UV v_uv  
33 #define NORMAL_UV v_uv  
34 #define USE_PBR_MAP 1  
35 #define PBR_UV v_uv  
36 #define USE_METALLIC_ROUGHNESS_MAP 1  
37 #define METALLIC_ROUGHNESS_UV v_uv  
38 #define USE_OCCLUSION_MAP 1  
39 #define OCCLUSION_UV v_uv  
40 #define USE_EMISSIVE_MAP 1  
41 #define EMISSIVE_UV v_uv  
42 #define OCCLUSION_CHANNEL r  
43 #define ROUGHNESS_CHANNEL g  
44 #define METALLIC_CHANNEL b  
45 #define USE_ALPHA_TEST 1  
46 #define ALPHA_TEST_CHANNEL a  
47  
48 #ifdef GL_OES_standard_derivatives  
49 #extension GL_OES_standard_derivatives: enable  
50 #endif  
51  
52 #ifdef GL_EXT_shader_texture_lod  
53 #extension GL_EXT_shader_texture_lod: enable  
54 #endif  
55  
56 precision highp float;  
57 uniform highp vec4 cc_cameraPos;  
58   uniform mediump vec4 cc_mainLitDir;  
59   uniform mediump vec4 cc_mainLitColor;  
60   uniform mediump vec4 cc_ambientSky;  
61   uniform mediump vec4 cc_ambientGround;  
62  
63  
64  
65  
66  
67  
68 #define QUATER_PI         0.78539816340  
69 #define HALF_PI           1.57079632679  
70 #define PI                3.14159265359  
71 #define PI2               6.28318530718  
72 #define PI4               12.5663706144  
73  
74 #define INV_QUATER_PI     1.27323954474  
75 #define INV_HALF_PI       0.63661977237  
76 #define INV_PI            0.31830988618  
77 #define INV_PI2           0.15915494309  
78 #define INV_PI4           0.07957747155  
79  
80 #define EPSILON           1e-6  
81 #define EPSILON_LOWP      1e-4  
82 #define LOG2              1.442695  
83 #define EXP_VALUE         2.71828183f  
84 #define FP_MAX            65504.0  
85 #define FP_SCALE          0.0009765625  
86 #define FP_SCALE_INV      1024.0  
87 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)  
88  
89  
90  
91  
92  
93  
94  
95 vec3 SRGBToLinear (vec3 gamma) {  
96   return gamma * gamma;  
97 }  
98 uniform highp mat4 cc_matLightView;  
99   uniform highp vec4 cc_shadowProjDepthInfo;  
100   uniform highp vec4 cc_shadowProjInfo;  
101   uniform mediump vec4 cc_shadowNFLSInfo;  
102   uniform mediump vec4 cc_shadowWHPBInfo;  
103   uniform mediump vec4 cc_shadowLPNNInfo;  
104  
105  
106  
107  
108  
109  
110  
111  
112 highp float unpackHighpData (float mainPart, float modPart) {  
113   highp float data = mainPart;  
114   return data + modPart;  
115 }  
116  
117 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {  
118   highp float data = mainPart * modValue;  
119   return data + modPart * modValue;  
120 }  
121  
122  
123 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {  
124   highp vec2 data = mainPart;  
125   return data + modPart;  
126 }  
127  
128 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {  
129   highp vec2 data = mainPart * modValue;  
130   return data + modPart * modValue;  
131 }  
132  
133  
134 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {  
135   highp vec3 data = mainPart;  
136   return data + modPart;  
137 }  
138  
139 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {  
140   highp vec3 data = mainPart * modValue;  
141   return data + modPart * modValue;  
142 }  
143  
144  
145 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {  
146   highp vec4 data = mainPart;  
147   return data + modPart;  
148 }  
149  
150 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {  
151   highp vec4 data = mainPart * modValue;  
152   return data + modPart * modValue;  
153 }  
154 #if CC_RECEIVE_SHADOW  
155   uniform highp sampler2D cc_shadowMap;  
156   uniform highp sampler2D cc_spotLightingMap;  
157  
158   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)  
159   {  
160     vec4 newShadowPos = shadowPos;  
161     if(normalBias > EPSILON_LOWP)  
162     {  
163       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);  
164       if(viewNormal.z < 0.1)  
165         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);  
166     }  
167     return newShadowPos;  
168   }  
169  
170  
171  
172   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)  
173   {  
174     float coeffA = cc_shadowProjDepthInfo.x;  
175     float coeffB = cc_shadowProjDepthInfo.y;  
176     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;  
177     viewSpacePos_z += viewspaceDepthBias;  
178     vec4 result = shadowPos;  
179     result.z = viewSpacePos_z * coeffA + coeffB;  
180     return result;  
181   }  
182  
183   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {  
184     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
185     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
186     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
187         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
188         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
189     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
190  
191     float shadow = 0.0;  
192     float closestDepth = 0.0;  
193     if (cc_shadowLPNNInfo.y > EPSILON) {  
194       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));  
195     } else {  
196       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;  
197     }  
198     shadow = step(clipPos.z, closestDepth);  
199  
200     return shadow;  
201   }  
202  
203   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {  
204     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
205     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
206     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
207         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
208         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
209     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
210  
211     float offsetDepth = clipPos.z;  
212     vec2 mapSize = cc_shadowWHPBInfo.xy;  
213     vec2 oneTap = 1.0 / mapSize;  
214     vec2 clipPos_offset = clipPos.xy + oneTap;  
215  
216     float block0, block1, block2, block3;  
217     if (cc_shadowLPNNInfo.y > EPSILON) {  
218       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
219       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
220       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
221       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
222     } else {  
223       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
224       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);  
225       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);  
226       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);  
227     }  
228  
229     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;  
230     float resultX = mix(block0, block1, coefX);  
231     float resultY = mix(block2, block3, coefX);  
232     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;  
233  
234     return mix(resultX, resultY, coefY);  
235   }  
236  
237   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {  
238     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
239     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
240     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
241         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
242         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
243     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
244  
245     float offsetDepth = clipPos.z;  
246     vec2 mapSize = cc_shadowWHPBInfo.xy;  
247     vec2 oneTap = 1.0 / mapSize;  
248     float clipPos_offset_L = clipPos.x - oneTap.x;  
249     float clipPos_offset_R = clipPos.x + oneTap.x;  
250     float clipPos_offset_U = clipPos.y - oneTap.y;  
251     float clipPos_offset_D = clipPos.y + oneTap.y;  
252  
253     float block0, block1, block2, block3, block4, block5, block6, block7, block8;  
254     if (cc_shadowLPNNInfo.y > EPSILON) {  
255       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
256       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
257       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
258       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
259       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
260       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
261       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
262       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
263       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
264     } else {  
265       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);  
266       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);  
267       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);  
268       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);  
269       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
270       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);  
271       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);  
272       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);  
273       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);  
274     }  
275  
276     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;  
277     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;  
278  
279     float shadow = 0.0;  
280     float resultX = mix(block0, block1, coefX);  
281     float resultY = mix(block3, block4, coefX);  
282     shadow += mix(resultX , resultY, coefY);  
283  
284     resultX = mix(block1, block2, coefX);  
285     resultY = mix(block4, block5, coefX);  
286     shadow += mix(resultX , resultY, coefY);  
287  
288     resultX = mix(block3, block4, coefX);  
289     resultY = mix(block6, block7, coefX);  
290     shadow += mix(resultX, resultY, coefY);  
291  
292     resultX = mix(block4, block5, coefX);  
293     resultY = mix(block7, block8, coefX);  
294     shadow += mix(resultX, resultY, coefY);  
295  
296     return shadow * 0.25;  
297   }  
298  
299  
300  
301  
302  
303  
304  
305  
306  
307 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)  
308 {  
309   float realtimeShadow = 1.0;  
310   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);  
311  
312   float pcf = cc_shadowWHPBInfo.z;  
313   if (pcf > 1.9) {  
314     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);  
315   }else if (pcf > 0.9) {  
316     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);  
317   }else {  
318     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);  
319   }  
320   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);  
321 }  
322 #endif  
323  
324  
325  
326 #if CC_USE_IBL  
327   uniform samplerCube cc_environment;  
328  
329   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {  
330  
331       #ifdef GL_EXT_shader_texture_lod  
332         return texture2DLodEXT(tex, coord, lod);  
333       #else  
334         return texture2D(tex, coord, lod);  
335       #endif  
336  
337   }  
338  
339   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {  
340  
341       #ifdef GL_EXT_shader_texture_lod  
342         return textureCubeLodEXT(tex, coord, lod);  
343       #else  
344         return textureCube(tex, coord, lod);  
345       #endif  
346  
347   }  
348  
349  
350  
351  
352  
353  
354  
355   vec3 unpackRGBE (vec4 rgbe) {  
356     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);  
357   }  
358  
359  
360   #if CC_USE_DIFFUSEMAP  
361     uniform samplerCube cc_diffuseMap;  
362   #endif  
363 #endif  
364  
365 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {  
366   vec3 NxH = cross(N, H);  
367   float OneMinusNoHSqr = dot(NxH, NxH);  
368   float a = roughness * roughness;  
369   float n = NoH * a;  
370   float p = a / (OneMinusNoHSqr + n * n);  
371   return p * p;  
372 }  
373  
374 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {  
375   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);  
376 }  
377  
378 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {  
379   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);  
380   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);  
381   vec4 r = roughness * c0 + c1;  
382   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;  
383   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;  
384   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);  
385   return specular * AB.x + AB.y;  
386 }  
387  
388 #if USE_REFLECTION_DENOISE  
389   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {  
390     #if CC_USE_IBL  
391     	float mip = roughness * mipCount;  
392     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;  
393     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));  
394  
395     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);  
396      	vec4 filtered = textureCube(cc_environment, R);  
397  
398       #if CC_USE_IBL == 2  
399       	biased.rgb = unpackRGBE(biased);  
400       	filtered.rgb = unpackRGBE(filtered);  
401       #else  
402       	biased.rgb = SRGBToLinear(biased.rgb);  
403       	filtered.rgb = SRGBToLinear(filtered.rgb);  
404       #endif  
405  
406       return mix(biased.rgb, filtered.rgb, denoiseIntensity);  
407     #else  
408       return vec3(0.0, 0.0, 0.0);  
409     #endif  
410   }  
411 #endif  
412  
413  
414 struct StandardSurface {  
415   vec4 albedo;  
416  
417   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
418   vec3 position, position_fract_part;  
419   #else  
420   vec3 position;  
421   #endif  
422   vec3 normal;  
423   vec3 emissive;  
424   vec3 lightmap;  
425   float lightmap_test;  
426   float roughness;  
427   float metallic;  
428   float occlusion;  
429   float specularIntensity;  
430  
431   #if CC_RECEIVE_SHADOW  
432     vec2 shadowBias;  
433   #endif  
434 };  
435  
436 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {  
437   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);  
438  
439   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);  
440  
441   vec3 position;  
442  
443   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
444   position = unpackHighpData(s.position, s.position_fract_part);  
445   #else  
446   position = s.position;  
447   #endif  
448  
449   vec3 N = normalize(s.normal);  
450   vec3 V = normalize(cc_cameraPos.xyz - position);  
451  
452   float NV = max(abs(dot(N, V)), 0.0);  
453   specular = BRDFApprox(specular, s.roughness, NV);  
454  
455   vec3 L = normalize(-cc_mainLitDir.xyz);  
456   vec3 H = normalize(L + V);  
457   float NH = max(dot(N, H), 0.0);  
458   float NL = max(dot(N, L), 0.0);  
459   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;  
460   vec3 diffuseContrib = diffuse / PI;  
461   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);  
462   vec3 dirlightContrib = (diffuseContrib + specularContrib);  
463  
464   float shadow = 1.0;  
465   #if CC_RECEIVE_SHADOW  
466     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {  
467       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);  
468     }  
469   #endif  
470  
471   dirlightContrib *= shadow;  
472   finalColor *= dirlightContrib;  
473  
474   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD  
475     if (s.lightmap_test > EPSILON_LOWP) {  
476       finalColor = diffuse * s.lightmap.rgb * shadow;  
477     }  
478   #endif  
479  
480   float fAmb = 0.5 - N.y * 0.5;  
481   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);  
482  
483  
484   #if CC_USE_IBL  
485     #if CC_USE_DIFFUSEMAP  
486       vec4 diffuseMap = textureCube(cc_diffuseMap, N);  
487       #if CC_USE_DIFFUSEMAP == 2  
488         ambDiff = unpackRGBE(diffuseMap);  
489       #else  
490         ambDiff = SRGBToLinear(diffuseMap.rgb);  
491       #endif  
492     #endif  
493  
494     vec3 R = normalize(reflect(-V, N));  
495  
496     #if USE_REFLECTION_DENOISE  
497       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);  
498     #else  
499       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);  
500  
501       #if CC_USE_IBL == 2  
502         vec3 env = unpackRGBE(envmap);  
503       #else  
504         vec3 env = SRGBToLinear(envmap.rgb);  
505       #endif  
506     #endif  
507  
508     finalColor += env * cc_ambientSky.w * specular * s.occlusion;  
509   #endif  
510  
511   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;  
512  
513  
514   finalColor += s.emissive;  
515  
516   return vec4(finalColor, s.albedo.a);  
517 }  
518  
519  
520  
521 vec3 ACESToneMap (vec3 color) {  
522   color = min(color, vec3(8.0));  
523   const float A = 2.51;  
524   const float B = 0.03;  
525   const float C = 2.43;  
526   const float D = 0.59;  
527   const float E = 0.14;  
528   return (color * (A * color + B)) / (color * (C * color + D) + E);  
529 }  
530  
531  
532  
533 vec4 CCFragOutput (vec4 color) {  
534   #if CC_USE_HDR  
535     color.rgb = ACESToneMap(color.rgb);  
536   #endif  
537   color.rgb = sqrt(color.rgb);  
538   return color;  
539 }  
540  
541  
542  
543      uniform vec4 rimColor;  
544      uniform vec4 albedo;  
545      uniform vec4 albedoScaleAndCutoff;  
546      uniform vec4 pbrParams;  
547      uniform vec4 emissive;  
548      uniform vec4 emissiveScaleParam;  
549  
550  
551  
552  
553 varying highp vec4 v_shadowPos;  
554  
555  
556  
557 #if CC_RECEIVE_SHADOW  
558  
559  
560  
561 #endif  
562  
563  
564 varying vec3 v_position;  
565 varying vec3 v_view_position;  
566 varying vec2 v_uv;  
567 varying vec2 v_uv1;  
568 varying vec3 v_normal;  
569 varying vec3 v_view_normal;  
570 varying highp vec4 v_shadowPos;  
571  
572 #if USE_VERTEX_COLOR  
573   varying vec3 v_color;  
574 #endif  
575  
576 #if USE_ALBEDO_MAP  
577   uniform sampler2D albedoMap;  
578 #endif  
579 #if USE_NORMAL_MAP  
580   varying vec3 v_tangent;  
581   varying vec3 v_bitangent;  
582   uniform sampler2D normalMap;  
583 #endif  
584 #if USE_PBR_MAP  
585   uniform sampler2D pbrMap;  
586 #endif  
587 #if USE_METALLIC_ROUGHNESS_MAP  
588   uniform sampler2D metallicRoughnessMap;  
589 #endif  
590 #if USE_OCCLUSION_MAP  
591   uniform sampler2D occlusionMap;  
592 #endif  
593 #if USE_EMISSIVE_MAP  
594   uniform sampler2D emissiveMap;  
595 #endif  
596 #if CC_USE_LIGHTMAP  
597   varying vec2 v_luv;  
598   uniform sampler2D cc_lightingMap;  
599 #endif  
600 #if USE_ALPHA_TEST  
601 #endif  
602  
603 void surf (out StandardSurface s) {  
604   vec4 baseColor = albedo;  
605   #if USE_VERTEX_COLOR  
606     baseColor.rgb *= v_color;  
607   #endif  
608   #if USE_ALBEDO_MAP  
609     vec4 texColor = texture2D(albedoMap, ALBEDO_UV);  
610     texColor.rgb = SRGBToLinear(texColor.rgb);  
611     baseColor *= texColor;  
612   #endif  
613   s.albedo = baseColor;  
614   s.albedo.rgb *= albedoScaleAndCutoff.xyz;  
615  
616   #if USE_ALPHA_TEST  
617     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;  
618   #endif  
619   float density = 0.001;  
620   float dist2 = dot(v_view_position,v_view_position);  
621   float fogFactor = exp( -density*density * dist2);  
622   fogFactor = clamp(fogFactor, 0.0, 1.0);  
623  
624   vec3 fogColor = vec3(1.0,1,1.0);  
625   s.albedo.rgb = mix(fogColor,s.albedo.rgb,fogFactor);  
626  
627   s.normal = v_normal;  
628   #if USE_NORMAL_MAP  
629     vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);  
630     s.normal =  
631       (nmmp.x * pbrParams.w) * normalize(v_tangent) +  
632       (nmmp.y * pbrParams.w) * normalize(v_bitangent) +  
633       nmmp.z * normalize(s.normal);  
634   #endif  
635  
636   s.position = v_position;  
637  
638   vec4 pbr = pbrParams;  
639   #if USE_PBR_MAP  
640     vec4 res = texture2D(pbrMap, PBR_UV);  
641     pbr.x *= res.OCCLUSION_CHANNEL;  
642     pbr.y *= res.ROUGHNESS_CHANNEL;  
643     pbr.z *= res.METALLIC_CHANNEL;  
644   #endif  
645   #if USE_METALLIC_ROUGHNESS_MAP  
646     vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);  
647     pbr.z *= metallicRoughness.METALLIC_CHANNEL;  
648     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;  
649   #endif  
650   #if USE_OCCLUSION_MAP  
651     pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;  
652   #endif  
653   s.occlusion = clamp(pbr.x, 0.0, 0.96);  
654   s.roughness = clamp(pbr.y, 0.04, 1.0);  
655   s.specularIntensity = 0.5;  
656   s.metallic = pbr.z;  
657  
658   s.emissive = emissive.rgb * emissiveScaleParam.xyz;  
659   #if USE_EMISSIVE_MAP  
660     s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);  
661   #endif  
662 }  
663  
664 vec4 frag () {  
665   StandardSurface s; surf(s);  
666   vec4 color = CCStandardShadingBase(s, v_shadowPos);  
667  
668   #if CC_USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING  
669     vec4 lighting = texture2D(cc_lightingMap, v_luv);  
670  
671     float fAmb = 0.5 - s.normal.y * 0.5;  
672     vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;  
673  
674     vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);  
675     finalColor += lighting.rgb *  s.albedo.rgb;  
676     finalColor = finalColor * s.occlusion;  
677     finalColor += s.emissive;  
678  
679     color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;  
680   #endif  
681  
682   float fRim = (1.0 - dot(normalize(v_view_normal),vec3(0,0,1.0))) * rimColor.w;  
683  
684   color.rgb = mix(color.rgb,rimColor.rgb,fRim);  
685  
686   return CCFragOutput(color);  
687 }  
688  
689  
690 void main() { gl_FragColor = frag(); }  
691  
at Object.encode (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-worker/node_modules/v-stacks/index.js:14:17)  
at Logger._logHandler (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-worker/static/script.ccc:1:531)  
at Logger.record (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:458)  
at console.error (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@base/electron-logger/lib/renderer.ccc:1:1414)  
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)  
at async ParallelQueue._generate (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/asset-db.ccc:1:2165)
2022-06-23T02:44:59.878Z - error: [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos   
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)  
at async ParallelQueue._generate (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/asset-db.ccc:1:2165)
2022-06-23T02:45:15.537Z - error: [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos [Asset DB] ../res/rim_light.effect - linking: Error EFX2407: link failed: Varyings with the same name but different type, or statically used varyings in fragment shader are not declared in vertex shader: v_shadowPos   
at EffectImporter.import (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/modules/engine-extensions/extensions/engine-extends/dist/importer/importers/effect.ccc:1:1959)  
at ImportTask.importAsset (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:2325)  
at async ImportTask.exec (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/task.ccc:1:596)  
at async ParallelQueue._generate (/Applications/CocosCreator/Creator/3.5.2/CocosCreator.app/Contents/Resources/app.asar/node_modules/@editor/asset-db/libs/asset-db.ccc:1:2165)
2022-06-23T02:46:41.588Z - warn: Metrics: no valid info
